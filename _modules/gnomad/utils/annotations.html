<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.annotations &mdash; gnomad master documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/broadinstitute/gnomad_methods/releases">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gnomad.utils.annotations</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.annotations</h1><div class="highlight"><pre>
<span></span><span class="c1"># noqa: D100</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>

<span class="kn">import</span> <span class="nn">gnomad.utils.filtering</span> <span class="k">as</span> <span class="nn">filter_utils</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.gen_stats</span> <span class="kn">import</span> <span class="n">to_phred</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">ANNOTATIONS_HISTS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;FS&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (0,20)</span>
    <span class="s2">&quot;InbreedingCoeff&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.25</span><span class="p">,</span> <span class="mf">0.25</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;MQ&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">80</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;RAW_MQ&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">13</span><span class="p">,</span> <span class="mi">33</span><span class="p">),</span>
    <span class="s2">&quot;MQRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;QD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">40</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;SOR&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;BaseQRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;ClippingRankSum&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">40</span><span class="p">),</span>
    <span class="s2">&quot;DP&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">32</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (0,8)</span>
    <span class="s2">&quot;VQSLOD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>  <span class="c1"># NOTE: in 2.0.2 release this was on (-20,20)</span>
    <span class="s2">&quot;AS_VQSLOD&quot;</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">60</span><span class="p">),</span>
    <span class="s2">&quot;rf_tp_probability&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
    <span class="s2">&quot;pab_max&quot;</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span>
<span class="p">}</span>

<span class="n">VRS_CHROM_IDS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;GRCh38&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;chr1&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.Ya6Rs7DHhDeg7YaOSg1EoNi3U_nQ9SvO&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr2&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.pnAqCRBrTsUoBghSD1yp_jXWSmlbdh4g&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr3&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.Zu7h9AggXxhTaGVsy7h_EZSChSZGcmgX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr4&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.HxuclGHh0XCDuF8x6yQrpHUBL7ZntAHc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr5&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.aUiQCzCPZ2d0csHbMSbh2NzInhonSXwI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr6&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.0iKlIQk2oZLoeOG9P1riRU6hvL5Ux8TV&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr7&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.F-LrLMe1SRpfUZHkQmvkVKFEGaoDeHul&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr8&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.209Z7zJ-mFypBEWLk4rNC6S_OxY5p7bs&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr9&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.KEO-4XBcm1cxeo_DIQ8_ofqGUkp4iZhI&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr10&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.ss8r_wB0-b9r44TQTMmVTI92884QvBiB&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr11&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.2NkFm8HK88MqeNkCgj78KidCAXgnsfV1&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr12&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.6wlJpONE3oNb4D69ULmEXhqyDZ4vwNfl&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr13&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ._0wi-qoDrvram155UmcSC-zA5ZK4fpLT&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr14&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.eK4D2MosgK_ivBkgi6FVPg5UXs1bYESm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr15&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.AsXvWL1-2i5U_buw6_niVIxD6zTbAuS6&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr16&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.yC_0RBj3fgBlvgyAuycbzdubtLxq-rE0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr17&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.dLZ15tNO1Ur0IcGjwc3Sdi_0A6Yf4zm7&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr18&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.vWwFhJ5lQDMhh-czg06YtlWqu0lvFAZV&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr19&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.IIB53T8CNeJJdUqzn9V_JnRtQadwWCbl&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr20&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.-A1QmD_MatoqxvgVxBLZTONHz9-c7nQo&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr21&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.5ZUqxCmDDgN4xTRbaSjN8LwgZironmB8&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chr22&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.7B7SHsmchAR0dFcDCuSFjJAo7tX87krQ&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chrX&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.w0WZEvgJF0zf_P4yyTzjjv9oW1z61HHP&quot;</span><span class="p">,</span>
        <span class="s2">&quot;chrY&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.8_liLu1aycC0tPQPFmUaGXJLDs5SbPZ5&quot;</span><span class="p">,</span>
    <span class="p">},</span>
    <span class="s2">&quot;GRCh37&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;1&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.S_KjnFVz-FE7M0W6yoaUDgYxLPc1jyWU&quot;</span><span class="p">,</span>
        <span class="s2">&quot;2&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.9KdcA9ZpY1Cpvxvg8bMSLYDUpsX6GDLO&quot;</span><span class="p">,</span>
        <span class="s2">&quot;3&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.VNBualIltAyi2AI_uXcKU7M9XUOuA7MS&quot;</span><span class="p">,</span>
        <span class="s2">&quot;4&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.iy7Zfceb5_VGtTQzJ-v5JpPbpeifHD_V&quot;</span><span class="p">,</span>
        <span class="s2">&quot;5&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.vbjOdMfHJvTjK_nqvFvpaSKhZillW0SX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;6&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.KqaUhJMW3CDjhoVtBetdEKT1n6hM-7Ek&quot;</span><span class="p">,</span>
        <span class="s2">&quot;7&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.IW78mgV5Cqf6M24hy52hPjyyo5tCCd86&quot;</span><span class="p">,</span>
        <span class="s2">&quot;8&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.tTm7wmhz0G4lpt8wPspcNkAD_qiminj6&quot;</span><span class="p">,</span>
        <span class="s2">&quot;9&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.HBckYGQ4wYG9APHLpjoQ9UUe9v7NxExt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;10&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.-BOZ8Esn8J88qDwNiSEwUr5425UXdiGX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;11&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.XXi2_O1ly-CCOi3HP5TypAw7LtC6niFG&quot;</span><span class="p">,</span>
        <span class="s2">&quot;12&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.105bBysLoDFQHhajooTAUyUkNiZ8LJEH&quot;</span><span class="p">,</span>
        <span class="s2">&quot;13&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.Ewb9qlgTqN6e_XQiRVYpoUfZJHXeiUfH&quot;</span><span class="p">,</span>
        <span class="s2">&quot;14&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.5Ji6FGEKfejK1U6BMScqrdKJK8GqmIGf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;15&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.zIMZb3Ft7RdWa5XYq0PxIlezLY2ccCgt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;16&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.W6wLoIFOn4G7cjopxPxYNk2lcEqhLQFb&quot;</span><span class="p">,</span>
        <span class="s2">&quot;17&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.AjWXsI7AkTK35XW9pgd3UbjpC3MAevlz&quot;</span><span class="p">,</span>
        <span class="s2">&quot;18&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.BTj4BDaaHYoPhD3oY2GdwC_l0uqZ92UD&quot;</span><span class="p">,</span>
        <span class="s2">&quot;19&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.ItRDD47aMoioDCNW_occY5fWKZBKlxCX&quot;</span><span class="p">,</span>
        <span class="s2">&quot;20&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.iy_UbUrvECxFRX5LPTH_KPojdlT7BKsf&quot;</span><span class="p">,</span>
        <span class="s2">&quot;21&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.LpTaNW-hwuY_yARP0rtarCnpCQLkgVCg&quot;</span><span class="p">,</span>
        <span class="s2">&quot;22&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.XOgHwwR3Upfp5sZYk6ZKzvV25a4RBVu8&quot;</span><span class="p">,</span>
        <span class="s2">&quot;X&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.v7noePfnNpK8ghYXEqZ9NukMXW7YeNsm&quot;</span><span class="p">,</span>
        <span class="s2">&quot;Y&quot;</span><span class="p">:</span> <span class="s2">&quot;ga4gh:SQ.BT7QyW5iXaX_1PSX-msSGYsqRdMKqkj-&quot;</span><span class="p">,</span>
    <span class="p">},</span>
<span class="p">}</span>


<span class="k">def</span> <span class="nf">_sum_or_diff_values</span><span class="p">(</span>
    <span class="n">val_1_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span> <span class="n">val_2_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span> <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Sum or subtract values based on the operation.</span>

<span class="sd">    :param val_1_expr: First value to sum or diff.</span>
<span class="sd">    :param val_2_expr: Second value to sum or diff.</span>
<span class="sd">    :param operation: Operation to perform (&quot;sum&quot; or &quot;diff&quot;).</span>
<span class="sd">    :return: Merged value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
        <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">val_1_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">val_2_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">val_1_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">val_2_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">)</span>


<span class="k">def</span> <span class="nf">_handle_negative_values</span><span class="p">(</span>
    <span class="n">value_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
    <span class="n">set_negatives_to_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">error_msg</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;Negative values found in merged values. Review data or set `set_negatives_to_zero` to True to set negative values to 0.&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Handle negative values in merged expressions.</span>

<span class="sd">    :param value_expr: The value expression to check for negative values.</span>
<span class="sd">    :param set_negatives_to_zero: If True, set negative values to 0. If False, raise an error.</span>
<span class="sd">    :param error_msg: Custom error message to display when negative values are found.</span>
<span class="sd">    :return: Value expression with negative value handling applied.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">value_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">value_expr</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">value_expr</span><span class="p">)</span>
        <span class="o">.</span><span class="n">or_error</span><span class="p">(</span><span class="n">error_msg</span><span class="p">)</span>
    <span class="p">)</span>


<div class="viewcode-block" id="annotate_with_ht"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_with_ht">[docs]</a><span class="k">def</span> <span class="nf">annotate_with_ht</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
    <span class="n">annotation_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">fields</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">annotate_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">filter_missing</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate a MatrixTable/Table with additional annotations from another Table.</span>

<span class="sd">    :param t: MatrixTable/Table to be annotated.</span>
<span class="sd">    :param annotation_ht: Table containing additional annotations to be joined on `t`.</span>
<span class="sd">    :param fields: Optional list of fields to select from `annotation_ht` and add to `t`</span>
<span class="sd">    :param annotate_cols: If True, annotate columns instead of rows. Default is False.</span>
<span class="sd">    :param filter_missing: If True, filter out missing rows/cols in `t` that are not</span>
<span class="sd">        present in `annotation_ht`. Default is False.</span>
<span class="sd">    :return: Annotated MatrixTable/Table.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">annotation_ht</span> <span class="o">=</span> <span class="n">annotation_ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">filter_missing</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Filtering input to variants in the supplied annotation HT...&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">):</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">semi_join</span><span class="p">(</span><span class="n">annotation_ht</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">annotate_cols</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">semi_join_cols</span><span class="p">(</span><span class="n">annotation_ht</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">semi_join_rows</span><span class="p">(</span><span class="n">annotation_ht</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">annotation_ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
    <span class="k">elif</span> <span class="n">annotate_cols</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="o">**</span><span class="n">annotation_ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">col_key</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="n">annotation_ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">row_key</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">t</span></div>


<div class="viewcode-block" id="grpmax_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.grpmax_expr">[docs]</a><span class="k">def</span> <span class="nf">grpmax_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">gen_anc_groups_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gen_anc_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gen_anc&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    Create an expression containing the frequency information about the genetic ancestry group that has the highest AF in `freq_meta`.</span>

<span class="sd">    Genetic ancestry groups specified in `gen_anc_groups_to_exclude` are excluded and only frequencies from adj genetic ancestry groups are considered.</span>

<span class="sd">    This resulting struct contains the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - gen_anc: str</span>

<span class="sd">    :param freq: ArrayExpression of Structs with fields [&#39;AC&#39;, &#39;AF&#39;, &#39;AN&#39;, &#39;homozygote_count&#39;]</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (as returned by annotate_freq)</span>
<span class="sd">    :param gen_anc_groups_to_exclude: Set of genetic ancestry groups to skip for genetic ancestry max calculation</span>
<span class="sd">    :param gen_anc_label: Label of the genetic ancestry group field in the meta dictionary</span>
<span class="sd">    :return: Genetic ancestry max struct</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gen_anc_groups_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">gen_anc_groups_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_anc_groups_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
    <span class="n">gen_anc_max_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">gen_anc_label</span><span class="p">})</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_gen_anc_groups_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">gen_anc_label</span><span class="p">]))</span>
    <span class="p">)</span>
    <span class="n">freq_filtered</span> <span class="o">=</span> <span class="n">gen_anc_max_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">gen_anc_label</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">gen_anc_label</span><span class="p">]})</span>
    <span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="n">sorted_freqs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">freq_filtered</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">AF</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">sorted_freqs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sorted_freqs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>


<div class="viewcode-block" id="project_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.project_max_expr">[docs]</a><span class="k">def</span> <span class="nf">project_max_expr</span><span class="p">(</span>
    <span class="n">project_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">alleles_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">n_projects</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create an expression that computes allele frequency information by project for the `n_projects` with the largest AF at this row.</span>

<span class="sd">    Will return an array with one element per non-reference allele.</span>

<span class="sd">    Each of these elements is itself an array of structs with the following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>
<span class="sd">        - project: str</span>

<span class="sd">    .. note::</span>

<span class="sd">        Only projects with AF &gt; 0 are returned.</span>
<span class="sd">        In case of ties, the project ordering is not guaranteed, and at most `n_projects` are returned.</span>

<span class="sd">    :param project_expr: column expression containing the project</span>
<span class="sd">    :param gt_expr: entry expression containing the genotype</span>
<span class="sd">    :param alleles_expr: row expression containing the alleles</span>
<span class="sd">    :param n_projects: Maximum number of projects to return for each row</span>
<span class="sd">    :return: projectmax expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">n_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles_expr</span><span class="p">)</span>

    <span class="c1"># compute call stats by  project</span>
    <span class="n">project_cs</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">project_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">alleles_expr</span><span class="p">))</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">n_alleles</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span>  <span class="c1"># Exclude monomorphic sites</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">n_alleles</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span>
                <span class="n">project_cs</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="c1"># filter to projects with AF &gt; 0</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">]</span>
                    <span class="o">&gt;</span> <span class="mi">0</span>
                <span class="p">),</span>
                <span class="c1"># order the callstats computed by AF in decreasing order</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="o">-</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                <span class="c1"># take the n_projects projects with largest AF</span>
            <span class="p">)[:</span><span class="n">n_projects</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="c1"># add the project in the callstats struct</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="n">AC</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AF</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">AN</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span>
                    <span class="n">homozygote_count</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="n">ai</span><span class="p">],</span>
                    <span class="n">project</span><span class="o">=</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="faf_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.faf_expr">[docs]</a><span class="k">def</span> <span class="nf">faf_expr</span><span class="p">(</span>
    <span class="n">freq</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">gen_anc_groups_to_exclude</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">faf_thresholds</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.95</span><span class="p">,</span> <span class="mf">0.99</span><span class="p">],</span>
    <span class="n">gen_anc_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gen_anc&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the filtering allele frequency (FAF) for each threshold specified in `faf_thresholds`.</span>

<span class="sd">    See http://cardiodb.org/allelefrequencyapp/ for more information.</span>

<span class="sd">    The FAF is computed for each of the following genetic ancestry group stratification if found in `freq_meta`:</span>

<span class="sd">        - All samples, with adj criteria</span>
<span class="sd">        - For each genetic ancestry group, with adj criteria</span>
<span class="sd">        - For all sex/genetic ancestry group on the non-PAR regions of sex chromosomes (will be missing on autosomes and PAR regions of sex chromosomes)</span>

<span class="sd">    Each of the FAF entry is a struct with one entry per threshold specified in `faf_thresholds` of type float64.</span>

<span class="sd">    This returns a tuple with two expressions:</span>

<span class="sd">        1. An array of FAF expressions as described above</span>
<span class="sd">        2. An array of dict containing the metadata for each of the array elements, in the same format as that produced by `annotate_freq`.</span>

<span class="sd">    :param freq: ArrayExpression of call stats structs (typically generated by hl.agg.call_stats)</span>
<span class="sd">    :param freq_meta: ArrayExpression of meta dictionaries corresponding to freq (typically generated using annotate_freq)</span>
<span class="sd">    :param locus: locus</span>
<span class="sd">    :param gen_anc_groups_to_exclude: Set of genetic ancestry groups to exclude from faf calculation (typically bottlenecked or consanguineous genetic ancestry groups)</span>
<span class="sd">    :param faf_thresholds: List of FAF thresholds to compute</span>
<span class="sd">    :param gen_anc_label: Label of the genetic ancestry group field in the meta dictionary</span>
<span class="sd">    :return: (FAF expression, FAF metadata)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">_gen_anc_groups_to_exclude</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">gen_anc_groups_to_exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">gen_anc_groups_to_exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># pylint: disable=invalid-unary-operand-type</span>
    <span class="n">faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="n">gen_anc_label</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_gen_anc_groups_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">gen_anc_label</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sex_faf_freq_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">))</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;sex&quot;</span><span class="p">))</span>
        <span class="o">&amp;</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span>
            <span class="o">|</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="n">gen_anc_label</span><span class="p">,</span> <span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">})</span>
                <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">_gen_anc_groups_to_exclude</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">gen_anc_label</span><span class="p">]))</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;faf</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                    <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_expr</span> <span class="o">=</span> <span class="n">faf_expr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
        <span class="n">sex_faf_freq_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                <span class="o">~</span><span class="n">locus</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="sa">f</span><span class="s2">&quot;faf</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">threshold</span><span class="p">)[</span><span class="mi">2</span><span class="p">:]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">filtering_allele_frequency</span><span class="p">(</span>
                                <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span><span class="p">,</span> <span class="n">freq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span><span class="p">,</span> <span class="n">threshold</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf_thresholds</span>
                    <span class="p">}</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">faf_meta</span> <span class="o">=</span> <span class="n">faf_freq_indices</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">sex_faf_freq_indices</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">faf_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">faf_meta</span><span class="p">)</span></div>


<div class="viewcode-block" id="gen_anc_faf_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.gen_anc_faf_max_expr">[docs]</a><span class="k">def</span> <span class="nf">gen_anc_faf_max_expr</span><span class="p">(</span>
    <span class="n">faf</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">faf_meta</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">gen_anc_label</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gen_anc&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve the maximum FAF and corresponding genetic ancestry for each of the thresholds in `faf`.</span>

<span class="sd">    This resulting struct contains the following fields:</span>

<span class="sd">        - faf95_max: float64</span>
<span class="sd">        - faf95_max_gen_anc: str</span>
<span class="sd">        - faf99_max: float64</span>
<span class="sd">        - faf99_max_gen_anc: str</span>

<span class="sd">    :param faf: ArrayExpression of Structs of FAF thresholds previously computed. When</span>
<span class="sd">        `faf_expr` is used, contains fields &#39;faf95&#39; and &#39;faf99&#39;.</span>
<span class="sd">    :param faf_meta: ArrayExpression of meta dictionaries corresponding to faf (as</span>
<span class="sd">        returned by faf_expr)</span>
<span class="sd">    :param gen_anc_label: Label of the genetic ancestry group field in the meta dictionary</span>
<span class="sd">    :return: Genetic ancestry group struct for FAF max</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">faf_gen_anc_indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">faf_meta</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">set</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="o">==</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="n">gen_anc_label</span><span class="p">})</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">max_fafs_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">()</span>

    <span class="c1"># Iterate through faf thresholds, generally &#39;faf95&#39; and &#39;faf99&#39;, and</span>
    <span class="c1"># take the maximum faf value, &#39;[0]&#39;, and its gen_anc from the sorted faf array</span>
    <span class="k">for</span> <span class="n">threshold</span> <span class="ow">in</span> <span class="n">faf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">faf_struct</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span>
            <span class="n">faf_gen_anc_indices</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">{</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">_max&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                        <span class="n">faf</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">threshold</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">faf</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">threshold</span><span class="p">]</span>
                    <span class="p">),</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">_max_gen_anc&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                        <span class="n">faf</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">threshold</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">gen_anc_label</span><span class="p">]</span>
                    <span class="p">),</span>
                <span class="p">}</span>
            <span class="p">),</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">faf</span><span class="p">:</span> <span class="n">faf</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">threshold</span><span class="si">}</span><span class="s2">_max&quot;</span><span class="p">],</span>
            <span class="n">reverse</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">max_fafs_expr</span> <span class="o">=</span> <span class="n">max_fafs_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">faf_struct</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">max_fafs_expr</span></div>


<div class="viewcode-block" id="qual_hist_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.qual_hist_expr">[docs]</a><span class="k">def</span> <span class="nf">qual_hist_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ab_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">split_adj_and_raw</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a struct expression with genotype quality histograms based on the arguments given (dp, gq, ad, ab).</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `gt_expr` is provided, will return histograms for non-reference samples only as well as all samples.</span>
<span class="sd">        - `gt_expr` is required for the allele-balance histogram, as it is only computed on het samples.</span>
<span class="sd">        - If `ab_expr` is provided, the allele-balance histogram is computed using this expression instead of the ad_expr.</span>
<span class="sd">        - If `adj_expr` is provided, additional histograms are computed using only adj samples.</span>

<span class="sd">    :param gt_expr: Entry expression containing genotype.</span>
<span class="sd">    :param gq_expr: Entry expression containing genotype quality.</span>
<span class="sd">    :param dp_expr: Entry expression containing depth.</span>
<span class="sd">    :param ad_expr: Entry expression containing allelic depth (bi-allelic here).</span>
<span class="sd">    :param adj_expr: Entry expression containing adj (high quality) genotype status.</span>
<span class="sd">    :param ab_expr: Entry expression containing allele balance (bi-allelic here).</span>
<span class="sd">    :param split_adj_and_raw: Whether to split the adj and raw histograms into separate fields in the returned struct expr.</span>
<span class="sd">    :return: Genotype quality histograms expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">gq_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;gq_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">gq_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dp_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;dp_hist&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">dp_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gt_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_alt&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                    <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span> <span class="n">qual_hist_expr</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">},</span>
        <span class="p">}</span>
        <span class="n">ab_hist_msg</span> <span class="o">=</span> <span class="s2">&quot;Using the </span><span class="si">%s</span><span class="s2"> to compute allele balance histogram...&quot;</span>
        <span class="k">if</span> <span class="n">ab_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">ab_hist_msg</span><span class="p">,</span> <span class="s2">&quot;ab_expr&quot;</span><span class="p">)</span>
            <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ab_expr</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="n">ad_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">ab_hist_msg</span><span class="p">,</span> <span class="s2">&quot;ad_expr&quot;</span><span class="p">)</span>
            <span class="n">qual_hists</span><span class="p">[</span><span class="s2">&quot;ab_hist_alt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">)</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="n">qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">qual_hist_name</span><span class="si">}</span><span class="s2">_all&quot;</span><span class="p">:</span> <span class="n">qual_hist_expr</span>
            <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="k">if</span> <span class="n">adj_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">adj_qual_hists</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">qual_hist_name</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">adj_expr</span><span class="p">,</span> <span class="n">qual_hist_expr</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">qual_hist_name</span><span class="p">,</span> <span class="n">qual_hist_expr</span> <span class="ow">in</span> <span class="n">qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">split_adj_and_raw</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="n">raw_qual_hists</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">qual_hists</span><span class="p">),</span>
                <span class="n">qual_hists</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">adj_qual_hists</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">qual_hists</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_adj&quot;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">adj_qual_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">qual_hists</span><span class="p">)</span></div>


<div class="viewcode-block" id="age_hists_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.age_hists_expr">[docs]</a><span class="k">def</span> <span class="nf">age_hists_expr</span><span class="p">(</span>
    <span class="n">adj_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">age_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span>
    <span class="n">lowest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">highest_boundary</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span>
    <span class="n">n_bins</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a StructExpression with the age histograms for hets and homs.</span>

<span class="sd">    :param adj_expr: Entry expression containing whether a genotype is high quality (adj) or not</span>
<span class="sd">    :param gt_expr: Entry expression containing the genotype</span>
<span class="sd">    :param age_expr: Col expression containing the sample&#39;s age</span>
<span class="sd">    :param lowest_boundary: Lowest bin boundary (any younger sample will be binned in n_smaller)</span>
<span class="sd">    :param highest_boundary: Highest bin boundary (any older sample will be binned in n_larger)</span>
<span class="sd">    :param n_bins: Total number of bins</span>
<span class="sd">    :return: A struct with `age_hist_het` and `age_hist_hom`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">age_hist_het</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
        <span class="n">age_hist_hom</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">adj_expr</span> <span class="o">&amp;</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_hom_var</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span><span class="n">age_expr</span><span class="p">,</span> <span class="n">lowest_boundary</span><span class="p">,</span> <span class="n">highest_boundary</span><span class="p">,</span> <span class="n">n_bins</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_lowqual_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_lowqual_expr">[docs]</a><span class="k">def</span> <span class="nf">get_lowqual_expr</span><span class="p">(</span>
    <span class="n">alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">qual_approx_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">],</span>
    <span class="n">snv_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">snv_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>  <span class="c1"># 1/1000</span>
    <span class="n">indel_phred_threshold</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">30</span><span class="p">,</span>
    <span class="n">indel_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">39</span><span class="p">,</span>  <span class="c1"># 1/8,000</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute lowqual threshold expression for either split or unsplit alleles based on QUALapprox or AS_QUALapprox.</span>

<span class="sd">    .. note::</span>

<span class="sd">        When running This lowqual annotation using QUALapprox, it differs from the GATK LowQual filter.</span>
<span class="sd">        This is because GATK computes this annotation at the site level, which uses the least stringent prior for mixed sites.</span>
<span class="sd">        When run using AS_QUALapprox, this implementation can thus be more stringent for certain alleles at mixed sites.</span>

<span class="sd">    :param alleles: Array of alleles</span>
<span class="sd">    :param qual_approx_expr: QUALapprox or AS_QUALapprox</span>
<span class="sd">    :param snv_phred_threshold: Phred-scaled SNV &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param snv_phred_het_prior: Phred-scaled SNV heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :param indel_phred_threshold: Phred-scaled indel &quot;emission&quot; threshold (similar to GATK emission threshold)</span>
<span class="sd">    :param indel_phred_het_prior: Phred-scaled indel heterozygosity prior (30 = 1/1000 bases, GATK default)</span>
<span class="sd">    :return: lowqual expression (BooleanExpression if `qual_approx_expr`is Numeric, Array[BooleanExpression] if `qual_approx_expr` is ArrayNumeric)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">min_snv_qual</span> <span class="o">=</span> <span class="n">snv_phred_threshold</span> <span class="o">+</span> <span class="n">snv_phred_het_prior</span>
    <span class="n">min_indel_qual</span> <span class="o">=</span> <span class="n">indel_phred_threshold</span> <span class="o">+</span> <span class="n">indel_phred_het_prior</span>
    <span class="n">min_mixed_qual</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">min_snv_qual</span><span class="p">,</span> <span class="n">min_indel_qual</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">qual_approx_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">]),</span>
                <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_snv_qual</span><span class="p">,</span>
                <span class="n">qual_approx_expr</span><span class="p">[</span><span class="n">ai</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">min_indel_qual</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_snv_qual</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_indel</span><span class="p">(</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alleles</span><span class="p">[</span><span class="n">ai</span><span class="p">])</span>
                <span class="p">),</span>
                <span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_indel_qual</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">qual_approx_expr</span> <span class="o">&lt;</span> <span class="n">min_mixed_qual</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_annotations_hists"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_annotations_hists">[docs]</a><span class="k">def</span> <span class="nf">get_annotations_hists</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotations_hists</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">],</span>
    <span class="n">log10_annotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create histograms for variant metrics in ht.info.</span>

<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param ht: Table with variant metrics</span>
<span class="sd">    :param annotations_hists: Dictionary of metrics names and their histogram values (start, end, bins)</span>
<span class="sd">    :param log10_annotations: List of metrics to log scale</span>
<span class="sd">    :return: Dictionary of merics and their histograms</span>
<span class="sd">    :rtype: Dict[str, hl.expr.StructExpression]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Check all fields in ht.info and create histograms if they are in</span>
    <span class="c1"># annotations_hists dict</span>
    <span class="k">return</span> <span class="p">{</span>
        <span class="n">field</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">hist</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">log10_annotations</span> <span class="k">else</span> <span class="n">ht</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="n">field</span><span class="p">],</span>
            <span class="n">start</span><span class="p">,</span>
            <span class="n">end</span><span class="p">,</span>
            <span class="n">bins</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">field</span><span class="p">,</span> <span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">bins</span><span class="p">)</span> <span class="ow">in</span> <span class="n">annotations_hists</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">ht</span><span class="o">.</span><span class="n">row</span><span class="o">.</span><span class="n">info</span>
    <span class="p">}</span></div>


<div class="viewcode-block" id="create_frequency_bins_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.create_frequency_bins_expr">[docs]</a><span class="k">def</span> <span class="nf">create_frequency_bins_expr</span><span class="p">(</span>
    <span class="n">AC</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">,</span> <span class="n">AF</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create bins for frequencies in preparation for aggregating QUAL by frequency bin.</span>

<span class="sd">    Bins:</span>
<span class="sd">        - singleton</span>
<span class="sd">        - doubleton</span>
<span class="sd">        - 0.00005</span>
<span class="sd">        - 0.0001</span>
<span class="sd">        - 0.0002</span>
<span class="sd">        - 0.0005</span>
<span class="sd">        - 0.001,</span>
<span class="sd">        - 0.002</span>
<span class="sd">        - 0.005</span>
<span class="sd">        - 0.01</span>
<span class="sd">        - 0.02</span>
<span class="sd">        - 0.05</span>
<span class="sd">        - 0.1</span>
<span class="sd">        - 0.2</span>
<span class="sd">        - 0.5</span>
<span class="sd">        - 1</span>

<span class="sd">    NOTE: Frequencies should be frequencies from raw data.</span>
<span class="sd">    Used when creating site quality distribution json files.</span>

<span class="sd">    :param AC: Field in input that contains the allele count information</span>
<span class="sd">    :param AF: Field in input that contains the allele frequency information</span>
<span class="sd">    :return: Expression containing bin name</span>
<span class="sd">    :rtype: hl.expr.StringExpression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bin_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;binned_singleton&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;binned_doubleton&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.00005</span><span class="p">),</span> <span class="s2">&quot;binned_0.00005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.00005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0001</span><span class="p">),</span> <span class="s2">&quot;binned_0.0001&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0002</span><span class="p">),</span> <span class="s2">&quot;binned_0.0002&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.0005</span><span class="p">),</span> <span class="s2">&quot;binned_0.0005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.0005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.001</span><span class="p">),</span> <span class="s2">&quot;binned_0.001&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.001</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.002</span><span class="p">),</span> <span class="s2">&quot;binned_0.002&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.002</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.005</span><span class="p">),</span> <span class="s2">&quot;binned_0.005&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.005</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="p">),</span> <span class="s2">&quot;binned_0.01&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.01</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.02</span><span class="p">),</span> <span class="s2">&quot;binned_0.02&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.02</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.05</span><span class="p">),</span> <span class="s2">&quot;binned_0.05&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.05</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.1</span><span class="p">),</span> <span class="s2">&quot;binned_0.1&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.2</span><span class="p">),</span> <span class="s2">&quot;binned_0.2&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.2</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;</span> <span class="mf">0.5</span><span class="p">),</span> <span class="s2">&quot;binned_0.5&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">((</span><span class="n">AF</span> <span class="o">&gt;=</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">AF</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">),</span> <span class="s2">&quot;binned_1&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">bin_expr</span></div>


<div class="viewcode-block" id="annotate_and_index_source_mt_for_sex_ploidy"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_and_index_source_mt_for_sex_ploidy">[docs]</a><span class="k">def</span> <span class="nf">annotate_and_index_source_mt_for_sex_ploidy</span><span class="p">(</span>
    <span class="n">locus_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">karyotype_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">xy_karyotype_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span>
    <span class="n">xx_karyotype_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XX&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Prepare relevant ploidy annotations for downstream calculations on a matrix table.</span>

<span class="sd">    This method is used as an optimization for the `get_is_haploid_expr` and</span>
<span class="sd">    `adjusted_sex_ploidy_expr` methods.</span>

<span class="sd">    This method annotates the `locus_expr` source matrix table with the following</span>
<span class="sd">    fields:</span>

<span class="sd">        - `xy`: Boolean indicating if the sample is XY.</span>
<span class="sd">        - `xx`: Boolean indicating if the sample is XX.</span>
<span class="sd">        - `in_non_par`: Boolean indicating if the locus is in a non-PAR region.</span>
<span class="sd">        - `x_nonpar`: Boolean indicating if the locus is in a non-PAR region of the X</span>
<span class="sd">          chromosome.</span>
<span class="sd">        - `y_par`: Boolean indicating if the locus is in a PAR region of the Y</span>
<span class="sd">          chromosome.</span>
<span class="sd">        - `y_nonpar`: Boolean indicating if the locus is in a non-PAR region of the Y</span>
<span class="sd">          chromosome.</span>

<span class="sd">    :param locus_expr: Locus expression.</span>
<span class="sd">    :param karyotype_expr: Karyotype expression.</span>
<span class="sd">    :param xy_karyotype_str: String representing XY karyotype. Default is &quot;XY&quot;.</span>
<span class="sd">    :param xx_karyotype_str: String representing XX karyotype. Default is &quot;XX&quot;.</span>
<span class="sd">    :return: Tuple of index expressions for columns and rows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">source_mt</span> <span class="o">=</span> <span class="n">locus_expr</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">source</span>
    <span class="n">col_ht</span> <span class="o">=</span> <span class="n">source_mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span>
        <span class="n">xy</span><span class="o">=</span><span class="n">karyotype_expr</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">xy_karyotype_str</span><span class="p">,</span>
        <span class="n">xx</span><span class="o">=</span><span class="n">karyotype_expr</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="n">xx_karyotype_str</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
    <span class="n">row_ht</span> <span class="o">=</span> <span class="n">source_mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span>
        <span class="n">in_non_par</span><span class="o">=~</span><span class="n">locus_expr</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">(),</span>
        <span class="n">in_autosome</span><span class="o">=</span><span class="n">locus_expr</span><span class="o">.</span><span class="n">in_autosome</span><span class="p">(),</span>
        <span class="n">x_nonpar</span><span class="o">=</span><span class="n">locus_expr</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">(),</span>
        <span class="n">y_par</span><span class="o">=</span><span class="n">locus_expr</span><span class="o">.</span><span class="n">in_y_par</span><span class="p">(),</span>
        <span class="n">y_nonpar</span><span class="o">=</span><span class="n">locus_expr</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>
    <span class="n">col_idx</span> <span class="o">=</span> <span class="n">col_ht</span><span class="p">[</span><span class="n">source_mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]</span>
    <span class="n">row_idx</span> <span class="o">=</span> <span class="n">row_ht</span><span class="p">[</span><span class="n">source_mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">col_idx</span><span class="p">,</span> <span class="n">row_idx</span></div>


<div class="viewcode-block" id="get_is_haploid_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_is_haploid_expr">[docs]</a><span class="k">def</span> <span class="nf">get_is_haploid_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">locus_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">karyotype_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">xy_karyotype_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span>
    <span class="n">xx_karyotype_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XX&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine if a genotype or locus and karyotype combination is haploid.</span>

<span class="sd">    .. note::</span>

<span class="sd">        One of `gt_expr` or `locus_expr` and `karyotype_expr` is required.</span>

<span class="sd">    :param gt_expr: Optional genotype expression.</span>
<span class="sd">    :param locus_expr: Optional locus expression.</span>
<span class="sd">    :param karyotype_expr: Optional sex karyotype expression.</span>
<span class="sd">    :param xy_karyotype_str: String representing XY karyotype. Default is &quot;XY&quot;.</span>
<span class="sd">    :param xx_karyotype_str: String representing XX karyotype. Default is &quot;XX&quot;.</span>
<span class="sd">    :return: Boolean expression indicating if the genotype is haploid.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gt_expr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">locus_expr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">karyotype_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;One of &#39;gt_expr&#39; or &#39;locus_expr&#39; and &#39;karyotype_expr&#39; is required.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">gt_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">locus_expr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">karyotype_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Both &#39;locus_expr&#39; and &#39;karyotype_expr&#39; are required if no &#39;gt_expr&#39; is &quot;</span>
            <span class="s2">&quot;supplied.&quot;</span>
        <span class="p">)</span>
    <span class="c1"># An optimization that annotates the locus&#39;s matrix table with the</span>
    <span class="c1"># fields in the case statements below as an optimization step</span>
    <span class="n">col_idx</span><span class="p">,</span> <span class="n">row_idx</span> <span class="o">=</span> <span class="n">annotate_and_index_source_mt_for_sex_ploidy</span><span class="p">(</span>
        <span class="n">locus_expr</span><span class="p">,</span> <span class="n">karyotype_expr</span><span class="p">,</span> <span class="n">xy_karyotype_str</span><span class="p">,</span> <span class="n">xx_karyotype_str</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">row_idx</span><span class="o">.</span><span class="n">in_non_par</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="o">~</span><span class="p">(</span><span class="n">col_idx</span><span class="o">.</span><span class="n">xx</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">row_idx</span><span class="o">.</span><span class="n">y_par</span> <span class="o">|</span> <span class="n">row_idx</span><span class="o">.</span><span class="n">y_nonpar</span><span class="p">)),</span>
        <span class="n">col_idx</span><span class="o">.</span><span class="n">xy</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">row_idx</span><span class="o">.</span><span class="n">x_nonpar</span> <span class="o">|</span> <span class="n">row_idx</span><span class="o">.</span><span class="n">y_nonpar</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_gq_dp_adj_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_gq_dp_adj_expr">[docs]</a><span class="k">def</span> <span class="nf">get_gq_dp_adj_expr</span><span class="p">(</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">locus_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">karyotype_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get adj annotation using only GQ and DP.</span>

<span class="sd">    Default thresholds correspond to gnomAD values.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can be used to annotate adj taking into account only GQ and DP.</span>
<span class="sd">        It is useful for cases where the GT field is not available, such as in the</span>
<span class="sd">        reference data of a VariantDataset.</span>

<span class="sd">    .. note::</span>

<span class="sd">        One of `gt_expr` or `locus_expr` and `karyotype_expr` is required.</span>

<span class="sd">    :param gq_expr: GQ expression.</span>
<span class="sd">    :param dp_expr: DP expression.</span>
<span class="sd">    :param gt_expr: Optional genotype expression.</span>
<span class="sd">    :param locus_expr: Optional locus expression.</span>
<span class="sd">    :param karyotype_expr: Optional sex karyotype expression.</span>
<span class="sd">    :param adj_gq: GQ threshold for adj. Default is 20.</span>
<span class="sd">    :param adj_dp: DP threshold for adj. Default is 10.</span>
<span class="sd">    :param haploid_adj_dp: Haploid DP threshold for adj. Default is 5.</span>
<span class="sd">    :return: Boolean expression indicating adj filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">gq_expr</span> <span class="o">&gt;=</span> <span class="n">adj_gq</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
        <span class="n">get_is_haploid_expr</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">locus_expr</span><span class="p">,</span> <span class="n">karyotype_expr</span><span class="p">),</span>
        <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">haploid_adj_dp</span><span class="p">,</span>
        <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_dp</span><span class="p">,</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_het_ab_adj_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_het_ab_adj_expr">[docs]</a><span class="k">def</span> <span class="nf">get_het_ab_adj_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get adj het AB annotation.</span>

<span class="sd">    :param gt_expr: Genotype expression.</span>
<span class="sd">    :param dp_expr: DP expression.</span>
<span class="sd">    :param ad_expr: AD expression.</span>
<span class="sd">    :param adj_ab: AB threshold for adj. Default is 0.2.</span>
<span class="sd">    :return: Boolean expression indicating adj het AB filter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="o">~</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het_ref</span><span class="p">(),</span> <span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span>
            <span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="n">gt_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">/</span> <span class="n">dp_expr</span> <span class="o">&gt;=</span> <span class="n">adj_ab</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="get_adj_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_adj_expr">[docs]</a><span class="k">def</span> <span class="nf">get_adj_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">gq_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">dp_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">],</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get adj genotype annotation.</span>

<span class="sd">    Defaults correspond to gnomAD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">get_gq_dp_adj_expr</span><span class="p">(</span>
        <span class="n">gq_expr</span><span class="p">,</span>
        <span class="n">dp_expr</span><span class="p">,</span>
        <span class="n">gt_expr</span><span class="o">=</span><span class="n">gt_expr</span><span class="p">,</span>
        <span class="n">adj_gq</span><span class="o">=</span><span class="n">adj_gq</span><span class="p">,</span>
        <span class="n">adj_dp</span><span class="o">=</span><span class="n">adj_dp</span><span class="p">,</span>
        <span class="n">haploid_adj_dp</span><span class="o">=</span><span class="n">haploid_adj_dp</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">&amp;</span> <span class="n">get_het_ab_adj_expr</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">dp_expr</span><span class="p">,</span> <span class="n">ad_expr</span><span class="p">,</span> <span class="n">adj_ab</span><span class="p">)</span></div>


<div class="viewcode-block" id="annotate_adj"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_adj">[docs]</a><span class="k">def</span> <span class="nf">annotate_adj</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">adj_gq</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
    <span class="n">adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span>
    <span class="n">adj_ab</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span>
    <span class="n">haploid_adj_dp</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate genotypes with adj criteria (assumes diploid).</span>

<span class="sd">    Defaults correspond to gnomAD values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;GT&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span> <span class="ow">and</span> <span class="s2">&quot;LGT&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No GT field found, using LGT instead.&quot;</span><span class="p">)</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">GT</span>

    <span class="k">if</span> <span class="s2">&quot;AD&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span> <span class="ow">and</span> <span class="s2">&quot;LAD&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;No AD field found, using LAD instead.&quot;</span><span class="p">)</span>
        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">AD</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span>
        <span class="n">adj</span><span class="o">=</span><span class="n">get_adj_expr</span><span class="p">(</span>
            <span class="n">gt_expr</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">ad_expr</span><span class="p">,</span> <span class="n">adj_gq</span><span class="p">,</span> <span class="n">adj_dp</span><span class="p">,</span> <span class="n">adj_ab</span><span class="p">,</span> <span class="n">haploid_adj_dp</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="add_variant_type"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_variant_type">[docs]</a><span class="k">def</span> <span class="nf">add_variant_type</span><span class="p">(</span><span class="n">alt_alleles</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Get Struct of variant_type and n_alt_alleles from ArrayExpression of Strings.&quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">alt_alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alts</span> <span class="o">=</span> <span class="n">alt_alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">non_star_alleles</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">!=</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">alts</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">variant_type</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">non_star_alleles</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;multi-snv&quot;</span><span class="p">,</span> <span class="s2">&quot;snv&quot;</span><span class="p">),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_indel</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="n">non_star_alleles</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;multi-indel&quot;</span><span class="p">,</span> <span class="s2">&quot;indel&quot;</span><span class="p">),</span>
                <span class="s2">&quot;mixed&quot;</span><span class="p">,</span>
            <span class="p">),</span>
        <span class="p">),</span>
        <span class="n">n_alt_alleles</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">non_star_alleles</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="annotate_allele_info"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_allele_info">[docs]</a><span class="k">def</span> <span class="nf">annotate_allele_info</span><span class="p">(</span><span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return bi-allelic sites Table with an &#39;allele_info&#39; annotation.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function requires that the input `ht` is unsplit and returns a split `ht`.</span>

<span class="sd">    &#39;allele_info&#39; is a struct with the following information:</span>
<span class="sd">        - variant_type: Variant type (snv, indel, multi-snv, multi-indel, or mixed).</span>
<span class="sd">        - n_alt_alleles: Total number of alternate alleles observed at variant locus.</span>
<span class="sd">        - has_star: True if the variant contains a star allele.</span>
<span class="sd">        - allele_type: Allele type (snv, insertion, deletion, or mixed).</span>
<span class="sd">        - was_mixed: True if the variant was mixed (i.e. contained both SNVs and indels).</span>
<span class="sd">        - nonsplit_alleles: Array of alleles before splitting.</span>

<span class="sd">    :param Table ht: Unsplit input Table.</span>
<span class="sd">    :return: Split Table with allele data annotation added,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">allele_info</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="n">add_variant_type</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span>
            <span class="n">has_star</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">:</span> <span class="n">a</span> <span class="o">==</span> <span class="s2">&quot;*&quot;</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">split_multi</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="n">ref_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">alt_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">allele_type_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_snp</span><span class="p">(</span><span class="n">ref_expr</span><span class="p">,</span> <span class="n">alt_expr</span><span class="p">),</span> <span class="s2">&quot;snv&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_insertion</span><span class="p">(</span><span class="n">ref_expr</span><span class="p">,</span> <span class="n">alt_expr</span><span class="p">),</span> <span class="s2">&quot;ins&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_deletion</span><span class="p">(</span><span class="n">ref_expr</span><span class="p">,</span> <span class="n">alt_expr</span><span class="p">),</span> <span class="s2">&quot;del&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="s2">&quot;complex&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">transmute</span><span class="p">(</span>
        <span class="n">allele_info</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">allele_info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">allele_type</span><span class="o">=</span><span class="n">allele_type_expr</span><span class="p">,</span>
            <span class="n">was_mixed</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">allele_info</span><span class="o">.</span><span class="n">variant_type</span> <span class="o">==</span> <span class="s2">&quot;mixed&quot;</span><span class="p">,</span>
            <span class="n">nonsplit_alleles</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">old_alleles</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="annotation_type_is_numeric"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotation_type_is_numeric">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, return whether it is a numerical type or not.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type is numeric</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat32</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">)</span></div>


<div class="viewcode-block" id="annotation_type_in_vcf_info"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotation_type_in_vcf_info">[docs]</a><span class="k">def</span> <span class="nf">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given an annotation type, returns whether that type can be natively exported to a VCF INFO field.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Types that aren&#39;t natively exportable to VCF will be converted to String on export.</span>

<span class="sd">    :param t: Type to test</span>
<span class="sd">    :return: If the input type can be exported to VCF</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">annotation_type_is_numeric</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
        <span class="ow">or</span> <span class="n">t</span> <span class="ow">in</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tstr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tbool</span><span class="p">)</span>
        <span class="ow">or</span> <span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tarray</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">tset</span><span class="p">))</span>
            <span class="ow">and</span> <span class="n">annotation_type_in_vcf_info</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="bi_allelic_site_inbreeding_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.bi_allelic_site_inbreeding_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_site_inbreeding_expr</span><span class="p">(</span>
    <span class="n">call</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">callstats_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the site inbreeding coefficient as an expression to be computed on a MatrixTable.</span>

<span class="sd">    This is implemented based on the GATK InbreedingCoeff metric:</span>
<span class="sd">    https://software.broadinstitute.org/gatk/documentation/article.php?id=8032</span>

<span class="sd">    .. note::</span>

<span class="sd">        The computation is run based on the counts of alternate alleles and thus should only be run on bi-allelic sites.</span>

<span class="sd">    :param call: Expression giving the calls in the MT</span>
<span class="sd">    :param callstats_expr: StructExpression containing only alternate allele AC, AN, and homozygote_count as integers. If passed, used to create expression in place of GT calls.</span>
<span class="sd">    :return: Site inbreeding coefficient expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">call</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">callstats_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of `call` or `callstats_expr` must be passed.&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">inbreeding_coeff</span><span class="p">(</span>
        <span class="n">gt_counts</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DictExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float32Expression</span><span class="p">:</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="n">q</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">gt_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="n">n</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">callstats_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Check that AC, AN, and homozygote count are all ints</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span>
                <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)</span>
                <span class="o">|</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">tint64</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;callstats_expr must be a StructExpression containing fields &#39;AC&#39;,&quot;</span>
                <span class="s2">&quot; &#39;AN&#39;, and &#39;homozygote_count&#39; of types int32 or int64.&quot;</span>
            <span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">q</span> <span class="o">=</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span> <span class="o">/</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">AN</span>
        <span class="n">p</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">q</span>
        <span class="k">return</span> <span class="mi">1</span> <span class="o">-</span> <span class="p">(</span><span class="n">callstats_expr</span><span class="o">.</span><span class="n">AC</span> <span class="o">-</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">callstats_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">))</span> <span class="o">/</span> <span class="p">(</span>
            <span class="mi">2</span> <span class="o">*</span> <span class="n">p</span> <span class="o">*</span> <span class="n">q</span> <span class="o">*</span> <span class="n">n</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">inbreeding_coeff</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">call</span><span class="o">.</span><span class="n">n_alt_alleles</span><span class="p">()))</span></div>


<div class="viewcode-block" id="fs_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.fs_from_sb">[docs]</a><span class="k">def</span> <span class="nf">fs_from_sb</span><span class="p">(</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="n">normalize</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">min_cell_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
    <span class="n">min_count</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>
    <span class="n">min_p_value</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-320</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `FS` (Fisher strand balance) annotation from  the `SB` (strand balance table) field.</span>

<span class="sd">    `FS` is the phred-scaled value of the double-sided Fisher exact test on strand balance.</span>

<span class="sd">    Using default values will have the same behavior as the GATK implementation, that is:</span>
<span class="sd">    - If sum(counts) &gt; 2*`min_cell_count` (default to GATK value of 200), they are normalized</span>
<span class="sd">    - If sum(counts) &lt; `min_count` (default to GATK value of 4), returns missing</span>
<span class="sd">    - Any p-value &lt; `min_p_value` (default to GATK value of 1e-320) is truncated to that value</span>

<span class="sd">    In addition to the default GATK behavior, setting `normalize` to `False` will perform a chi-squared test</span>
<span class="sd">    for large counts (&gt; `min_cell_count`) instead of normalizing the cell values.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length four containing the forward and reverse strands&#39; counts of ref and alt alleles: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - a two dimensional array with arrays of length two, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/FisherStrand.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :param normalize: Whether to normalize counts is sum(counts) &gt; min_cell_count (normalize=True), or use a chi sq instead of FET (normalize=False)</span>
<span class="sd">    :param min_cell_count: Maximum count for performing a FET</span>
<span class="sd">    :param min_count: Minimum total count to output FS (otherwise null it output)</span>
<span class="sd">    :return: FS value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="n">sb_sum</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="c1"># Normalize table if counts get too large</span>
    <span class="k">if</span> <span class="n">normalize</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sb_sum</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">sb_sum</span> <span class="o">&lt;=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">min_cell_count</span><span class="p">,</span>
                <span class="n">sb</span><span class="p">,</span>
                <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">x</span> <span class="o">/</span> <span class="p">(</span><span class="n">sb_sum</span> <span class="o">/</span> <span class="n">min_cell_count</span><span class="p">))),</span>
            <span class="p">),</span>
            <span class="n">sb</span><span class="p">,</span>
            <span class="n">sb_sum</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># FET</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">fisher_exact_test</span><span class="p">(</span>
                    <span class="n">fs_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">fs_expr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">fs_expr</span> <span class="o">=</span> <span class="n">to_phred</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">contingency_table_test</span><span class="p">(</span>
                    <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">min_cell_count</span><span class="o">=</span><span class="n">min_cell_count</span>
                <span class="p">)</span><span class="o">.</span><span class="n">p_value</span><span class="p">,</span>
                <span class="n">min_p_value</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Return null if counts &lt;= `min_count`</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">sb_sum</span> <span class="o">&gt;</span> <span class="n">min_count</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fs_expr</span><span class="p">)</span>  <span class="c1"># Needed to avoid -0.0 values</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="sor_from_sb"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.sor_from_sb">[docs]</a><span class="k">def</span> <span class="nf">sor_from_sb</span><span class="p">(</span>
    <span class="n">sb</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute `SOR` (Symmetric Odds Ratio test) annotation from  the `SB` (strand balance table) field.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can either take</span>
<span class="sd">        - an array of length four containing the forward and reverse strands&#39; counts of ref and alt alleles: [ref fwd, ref rev, alt fwd, alt rev]</span>
<span class="sd">        - a two dimensional array with arrays of length two, containing the counts: [[ref fwd, ref rev], [alt fwd, alt rev]]</span>

<span class="sd">    GATK code here: https://github.com/broadinstitute/gatk/blob/master/src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/StrandOddsRatio.java</span>

<span class="sd">    :param sb: Count of ref/alt reads on each strand</span>
<span class="sd">    :return: SOR value</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">):</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">sb</span><span class="p">)</span>

    <span class="n">sb</span> <span class="o">=</span> <span class="n">sb</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">ref_fw</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ref_rv</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">alt_fw</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="n">alt_rv</span> <span class="o">=</span> <span class="n">sb</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
    <span class="n">symmetrical_ratio</span> <span class="o">=</span> <span class="p">((</span><span class="n">ref_fw</span> <span class="o">*</span> <span class="n">alt_rv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">alt_fw</span> <span class="o">*</span> <span class="n">ref_rv</span><span class="p">))</span> <span class="o">+</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">alt_fw</span> <span class="o">*</span> <span class="n">ref_rv</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">ref_fw</span> <span class="o">*</span> <span class="n">alt_rv</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ref_ratio</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">ref_rv</span><span class="p">,</span> <span class="n">ref_fw</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">ref_rv</span><span class="p">,</span> <span class="n">ref_fw</span><span class="p">)</span>
    <span class="n">alt_ratio</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">alt_fw</span><span class="p">,</span> <span class="n">alt_rv</span><span class="p">)</span> <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">alt_fw</span><span class="p">,</span> <span class="n">alt_rv</span><span class="p">)</span>
    <span class="n">sor</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">symmetrical_ratio</span><span class="p">)</span> <span class="o">+</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">ref_ratio</span><span class="p">)</span> <span class="o">-</span> <span class="n">hl</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">alt_ratio</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sor</span></div>


<div class="viewcode-block" id="pab_max_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.pab_max_expr">[docs]</a><span class="k">def</span> <span class="nf">pab_max_expr</span><span class="p">(</span>
    <span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">ad_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">la_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">n_alleles_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the maximum p-value of the binomial test for the alternate allele balance (PAB) for each allele.</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function can take a `gt_expr` and `ad_expr` that use local or global</span>
<span class="sd">        alleles. If they use local alleles, `la_expr` and `n_alleles_expr` should be</span>
<span class="sd">        provided to transform `gt_expr` and `ad_expr` to global alleles.</span>

<span class="sd">    :param gt_expr: Genotype call expression.</span>
<span class="sd">    :param ad_expr: Allele depth expression.</span>
<span class="sd">    :param la_expr: Allele local index expression. When provided `gt_expr` and</span>
<span class="sd">        `ad_expr` are transformed from using local alleles to global alleles using</span>
<span class="sd">        `la_expr`.</span>
<span class="sd">    :param n_alleles_expr: Number of alleles expression. Required when &#39;la_expr&#39; is</span>
<span class="sd">        provided.</span>
<span class="sd">    :return: Array expression of maximum p-values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">la_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">n_alleles_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide `n_alleles_expr` if `la_expr` is provided!&quot;</span><span class="p">)</span>

        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">local_to_global</span><span class="p">(</span>
            <span class="n">ad_expr</span><span class="p">,</span> <span class="n">la_expr</span><span class="p">,</span> <span class="n">n_alleles_expr</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="s2">&quot;R&quot;</span>
        <span class="p">)</span>
        <span class="n">gt_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">lgt_to_gt</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">la_expr</span><span class="p">)</span>

    <span class="n">expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">gt_expr</span><span class="o">.</span><span class="n">is_het</span><span class="p">(),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">binom_test</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">),</span> <span class="mf">0.5</span><span class="p">,</span> <span class="s2">&quot;two-sided&quot;</span><span class="p">)),</span>
        <span class="p">),</span>
        <span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>  <span class="c1"># Skip ref allele</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">expr</span></div>


<div class="viewcode-block" id="bi_allelic_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.bi_allelic_expr">[docs]</a><span class="k">def</span> <span class="nf">bi_allelic_expr</span><span class="p">(</span><span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a boolean expression selecting bi-allelic sites only, accounting for whether the input MT/HT was split.</span>

<span class="sd">    :param t: Input HT/MT</span>
<span class="sd">    :return: Boolean expression selecting only bi-allelic sites</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="o">~</span><span class="n">t</span><span class="o">.</span><span class="n">was_split</span> <span class="k">if</span> <span class="s2">&quot;was_split&quot;</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span> <span class="k">else</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span></div>


<div class="viewcode-block" id="unphase_call_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.unphase_call_expr">[docs]</a><span class="k">def</span> <span class="nf">unphase_call_expr</span><span class="p">(</span><span class="n">call_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate unphased version of a call expression (which can be phased or not).</span>

<span class="sd">    :param call_expr: Input call expression</span>
<span class="sd">    :return: unphased call expression</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">call_expr</span><span class="o">.</span><span class="n">is_diploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">call_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">call_expr</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">call</span><span class="p">(</span><span class="n">call_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">phased</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">null</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tcall</span><span class="p">))</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="region_flag_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.region_flag_expr">[docs]</a><span class="k">def</span> <span class="nf">region_flag_expr</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
    <span class="n">non_par</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">prob_regions</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a `region_flag` struct that contains flags for problematic regions (i.e., LCR, decoy, segdup, and nonpar regions).</span>

<span class="sd">    .. note:: No hg38 resources for decoy or self chain are available yet.</span>

<span class="sd">    :param t: Input Table/MatrixTable</span>
<span class="sd">    :param non_par: If True, flag loci that occur within pseudoautosomal regions on sex chromosomes</span>
<span class="sd">    :param prob_regions: If supplied, flag loci that occur within regions defined in Hail Table(s)</span>
<span class="sd">    :return: `region_flag` struct row annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prob_flags_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">{</span><span class="s2">&quot;non_par&quot;</span><span class="p">:</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()}</span> <span class="k">if</span> <span class="n">non_par</span> <span class="k">else</span> <span class="p">{}</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">prob_regions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">prob_flags_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
            <span class="p">{</span>
                <span class="n">region_name</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">region_table</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">region_name</span><span class="p">,</span> <span class="n">region_table</span> <span class="ow">in</span> <span class="n">prob_regions</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">prob_flags_expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="missing_callstats_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.missing_callstats_expr">[docs]</a><span class="k">def</span> <span class="nf">missing_callstats_expr</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a missing callstats struct for insertion into frequency annotation arrays when data is missing.</span>

<span class="sd">    :return: Hail Struct with missing values for each callstats element</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">AC</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
        <span class="n">AF</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tfloat64</span><span class="p">),</span>
        <span class="n">AN</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
        <span class="n">homozygote_count</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="set_xx_y_metrics_to_na_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.set_xx_y_metrics_to_na_expr">[docs]</a><span class="k">def</span> <span class="nf">set_xx_y_metrics_to_na_expr</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
    <span class="n">freq_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;freq&quot;</span><span class="p">,</span>
    <span class="n">freq_meta_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;freq_meta&quot;</span><span class="p">,</span>
    <span class="n">freq_index_dict_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">DictExpression</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;freq_index_dict&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Set Y-variant frequency callstats for XX-specific metrics to missing structs.</span>

<span class="sd">    :param t: Table or MatrixTable for which to adjust XX metrics.</span>
<span class="sd">    :param freq_expr: Array expression or string annotation name for the frequency</span>
<span class="sd">        array. Default is &quot;freq&quot;.</span>
<span class="sd">    :param freq_meta_expr: Array expression or string annotation name for the frequency</span>
<span class="sd">        metadata. Default is &quot;freq_meta&quot;.</span>
<span class="sd">    :param freq_index_dict_expr: Dict expression or string annotation name for the</span>
<span class="sd">        frequency metadata index dictionary. Default is &quot;freq_index_dict&quot;.</span>
<span class="sd">    :return: Hail array expression to set XX Y-variant metrics to missing values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">freq_expr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_meta_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq_meta_expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">freq_meta_expr</span><span class="p">]</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_index_dict_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">freq_index_dict_expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">freq_index_dict_expr</span><span class="p">]</span>

    <span class="n">xx_idx</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">freq_index_dict_expr</span><span class="p">[</span><span class="n">x</span><span class="p">],</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;XX&quot;</span><span class="p">),</span> <span class="n">freq_index_dict_expr</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
    <span class="p">)</span>
    <span class="n">freq_idx_range</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">freq_meta_expr</span><span class="p">))</span>

    <span class="n">new_freq_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
        <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_par</span><span class="p">()),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">xx_idx</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">missing_callstats_expr</span><span class="p">(),</span> <span class="n">freq_expr</span><span class="p">[</span><span class="n">x</span><span class="p">]</span>
            <span class="p">),</span>
            <span class="n">freq_idx_range</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="n">freq_expr</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">new_freq_expr</span></div>


<div class="viewcode-block" id="hemi_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.hemi_expr">[docs]</a><span class="k">def</span> <span class="nf">hemi_expr</span><span class="p">(</span>
    <span class="n">locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">gt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">,</span>
    <span class="n">male_str</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;XY&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return whether genotypes are hemizygous.</span>

<span class="sd">    Return missing expression if locus is not in chrX/chrY non-PAR regions.</span>

<span class="sd">    :param locus: Input locus.</span>
<span class="sd">    :param sex_expr: Input StringExpression indicating whether sample is XX or XY.</span>
<span class="sd">    :param gt: Input genotype.</span>
<span class="sd">    :param xy_str: String indicating whether sample is XY. Default is &quot;XY&quot;.</span>
<span class="sd">    :return: BooleanExpression indicating whether genotypes are hemizygous.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
        <span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">|</span> <span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">(),</span>
        <span class="c1"># Haploid genotypes have a single integer, so checking if</span>
        <span class="c1"># mt.GT[0] is alternate allele</span>
        <span class="n">gt</span><span class="o">.</span><span class="n">is_haploid</span><span class="p">()</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sex_expr</span> <span class="o">==</span> <span class="n">male_str</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">gt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="merge_array_expressions"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.merge_array_expressions">[docs]</a><span class="k">def</span> <span class="nf">merge_array_expressions</span><span class="p">(</span>
    <span class="n">arrays</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="n">meta</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">set_negatives_to_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">struct_fields</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">count_arrays</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
    <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge a list of array expressions based on the supplied `operation`.</span>

<span class="sd">    This function can handle both:</span>
<span class="sd">    1. Arrays of integers (e.g., allele numbers).</span>
<span class="sd">    2. Arrays of structs containing integer fields (e.g., frequency structs with AC, AN, etc.).</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Arrays must be on the same Table.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Arrays do not have to contain the same groupings or order of groupings but</span>
<span class="sd">        the array indices for an array in `arrays` must be the same as its associated</span>
<span class="sd">        metadata index in `meta` i.e., `arrays = [arr1, arr2]` then `meta`</span>
<span class="sd">        must equal `[meta1, meta2]` where meta1 contains the metadata information</span>
<span class="sd">        for arr1.</span>

<span class="sd">        If `operation` is set to &quot;sum&quot;, groups in the merged array</span>
<span class="sd">        will be the union of groupings found within the arrays&#39; metadata and all arrays</span>
<span class="sd">        will be summed by grouping. If `operation` is set to &quot;diff&quot;, the merged array</span>
<span class="sd">        will contain groups only found in the first array of `meta`. Any array containing</span>
<span class="sd">        any of these groups will have their values subtracted from the values of the first array.</span>

<span class="sd">    :param arrays: List of arrays to merge. First entry in the list is the primary array to which other arrays will be added or subtracted. All arrays must be on the same Table.</span>
<span class="sd">    :param meta: List of metadata for arrays being merged.</span>
<span class="sd">    :param operation: Merge operation to perform. Options are &quot;sum&quot; and &quot;diff&quot;. If &quot;diff&quot; is passed, the first array in the list will have the other arrays subtracted from it.</span>
<span class="sd">    :param set_negatives_to_zero: If True, set negative array values to 0. If False, raise a ValueError. Default is False.</span>
<span class="sd">    :param struct_fields: List of field names to merge if arrays contain structs. If None, arrays are treated as integer arrays. Default is None.</span>
<span class="sd">    :param count_arrays: Dictionary of Lists of arrays containing counts to merge using the passed operation. Must use the same group indexing as meta. Keys are the descriptor names, values are Lists of arrays to merge. Default is None.</span>
<span class="sd">    :return: Tuple of merged array, metadata list and if `count_arrays` is not None, a dictionary of merged count arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide at least two arrays to merge!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Length of arrays and meta must be equal!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">operation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;diff&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Operation must be either &#39;sum&#39; or &#39;diff&#39;!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count_arrays</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">count_array</span> <span class="ow">in</span> <span class="n">count_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">count_array</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">meta</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Length of count_array &#39;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&#39; and meta must be equal!&quot;</span><span class="p">)</span>

    <span class="c1"># Store original metadata for count arrays processing.</span>
    <span class="n">original_meta</span> <span class="o">=</span> <span class="n">meta</span>

    <span class="c1"># Create a list where each entry is a dictionary whose key is an aggregation</span>
    <span class="c1"># group and the value is the corresponding index in the array.</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]])))</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">meta</span><span class="p">]</span>
    <span class="n">all_keys</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="p">(</span><span class="n">i</span> <span class="o">|</span> <span class="n">j</span><span class="o">.</span><span class="n">key_set</span><span class="p">()),</span> <span class="n">meta</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">key_set</span><span class="p">(),</span> <span class="n">meta</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

    <span class="c1"># Merge dictionaries in the list into a single dictionary where key is aggregation</span>
    <span class="c1"># group and the value is a list of the group&#39;s index in each of the arrays, if</span>
    <span class="c1"># it exists. For &quot;sum&quot; operation, use keys, aka groups, found in all dictionaries.</span>
    <span class="c1"># For &quot;diff&quot; operations, only use key_set from the first entry.</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span>
            <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="n">all_keys</span><span class="p">,</span> <span class="n">i</span><span class="o">.</span><span class="n">key_set</span><span class="p">()))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">k</span><span class="p">:</span> <span class="p">(</span>
                    <span class="n">k</span><span class="p">,</span>
                    <span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                        <span class="n">j</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint32</span><span class="p">)])</span>
                    <span class="p">),</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">),</span>
        <span class="n">meta</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
        <span class="n">meta</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
    <span class="p">)</span>

    <span class="c1"># Create a list of tuples from the dictionary, sorted by the list of indices for</span>
    <span class="c1"># each aggregation group.</span>
    <span class="n">meta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">meta</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Create a list of the aggregation groups, maintaining the sorted order.</span>
    <span class="n">new_meta</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create array for each aggregation group of arrays containing the group&#39;s values</span>
    <span class="c1"># from each array.</span>
    <span class="n">meta_idx</span> <span class="o">=</span> <span class="n">meta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">arrays</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>

    <span class="k">if</span> <span class="n">struct_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Handle struct arrays.</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">meta_idx</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="n">field</span><span class="p">:</span> <span class="n">_sum_or_diff_values</span><span class="p">(</span><span class="n">i</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">j</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">operation</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">struct_fields</span>
                    <span class="p">}</span>
                <span class="p">),</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">struct_fields</span><span class="p">),</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Handle integer arrays.</span>
        <span class="n">new_array</span> <span class="o">=</span> <span class="n">meta_idx</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">_sum_or_diff_values</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">operation</span><span class="p">),</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Check and see if any value within the merged array is negative. If so,</span>
    <span class="c1"># raise an error if set_negatives_to_zero is False or set the value to 0 if</span>
    <span class="c1"># set_negatives_to_zero is True.</span>
    <span class="k">if</span> <span class="n">operation</span> <span class="o">==</span> <span class="s2">&quot;diff&quot;</span><span class="p">:</span>
        <span class="n">negative_value_error_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Negative values found in merged array. Review data or set&quot;</span>
            <span class="s2">&quot; `set_negatives_to_zero` to True to set negative values to 0.&quot;</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">struct_fields</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_array</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
                    <span class="o">**</span><span class="p">{</span>
                        <span class="n">field</span><span class="p">:</span> <span class="n">_handle_negative_values</span><span class="p">(</span>
                            <span class="n">x</span><span class="p">[</span><span class="n">field</span><span class="p">],</span> <span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">negative_value_error_msg</span>
                        <span class="p">)</span>
                        <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">struct_fields</span>
                    <span class="p">}</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_array</span> <span class="o">=</span> <span class="n">new_array</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_handle_negative_values</span><span class="p">(</span>
                    <span class="n">x</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">negative_value_error_msg</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="c1"># Create count_array_meta_idx using meta then iterate through each group</span>
    <span class="c1"># in the list of tuples to access each group&#39;s entry per array. Sum or diff the</span>
    <span class="c1"># values for each group across arrays to make a new_counts_array annotation.</span>
    <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
        <span class="n">new_counts_array_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">count_array</span> <span class="ow">in</span> <span class="n">count_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_counts_array</span> <span class="o">=</span> <span class="n">merge_array_expressions</span><span class="p">(</span>
                <span class="n">count_array</span><span class="p">,</span> <span class="n">original_meta</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_counts_array_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_counts_array</span>

    <span class="n">new_meta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">new_meta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_array</span><span class="p">,</span> <span class="n">new_meta</span><span class="p">,</span> <span class="n">new_counts_array_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_array</span><span class="p">,</span> <span class="n">new_meta</span></div>


<div class="viewcode-block" id="merge_freq_arrays"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.merge_freq_arrays">[docs]</a><span class="k">def</span> <span class="nf">merge_freq_arrays</span><span class="p">(</span>
    <span class="n">farrays</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span>
    <span class="n">fmeta</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]],</span>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">set_negatives_to_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">count_arrays</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
    <span class="n">Tuple</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]],</span>
    <span class="n">Tuple</span><span class="p">[</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
        <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span>
        <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]],</span>
    <span class="p">],</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge a list of frequency arrays based on the supplied `operation`.</span>

<span class="sd">    .. warning::</span>
<span class="sd">        Arrays must be on the same Table.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Arrays do not have to contain the same groupings or order of groupings but</span>
<span class="sd">        the array indices for a freq array in `farrays` must be the same as its associated</span>
<span class="sd">        frequency metadata index in `fmeta` i.e., `farrays = [freq1, freq2]` then `fmeta`</span>
<span class="sd">        must equal `[fmeta1, fmeta2]` where fmeta1 contains the metadata information</span>
<span class="sd">        for freq1.</span>

<span class="sd">        If `operation` is set to &quot;sum&quot;, groups in the merged array</span>
<span class="sd">        will be the union of groupings found within the arrays&#39; metadata and all arrays</span>
<span class="sd">        with be summed by grouping. If `operation` is set to &quot;diff&quot;, the merged array</span>
<span class="sd">        will contain groups only found in the first array of `fmeta`. Any array containing</span>
<span class="sd">        any of these groups will have their values subtracted from the values of the first array.</span>

<span class="sd">    :param farrays: List of frequency arrays to merge. First entry in the list is the primary array to which other arrays will be added or subtracted. All arrays must be on the same Table.</span>
<span class="sd">    :param fmeta: List of frequency metadata for arrays being merged.</span>
<span class="sd">    :param operation: Merge operation to perform. Options are &quot;sum&quot; and &quot;diff&quot;. If &quot;diff&quot; is passed, the first freq array in the list will have the other arrays subtracted from it.</span>
<span class="sd">    :param set_negatives_to_zero: If True, set negative array values to 0 for AC, AN, AF, and homozygote_count. If False, raise a ValueError. Default is False.</span>
<span class="sd">    :param count_arrays: Dictionary of Lists of arrays containing counts to merge using the passed operation. Must use the same group indexing as fmeta. Keys are the descriptor names, values are Lists of arrays to merge. Default is None.</span>
<span class="sd">    :return: Tuple of merged frequency array, frequency metadata list and if `count_arrays` is not None, a dictionary of merged count arrays.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Define the callstat annotations to merge.</span>
    <span class="n">callstat_ann</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">,</span> <span class="s2">&quot;AN&quot;</span><span class="p">,</span> <span class="s2">&quot;homozygote_count&quot;</span><span class="p">]</span>
    <span class="n">callstat_ann_af</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">,</span> <span class="s2">&quot;AF&quot;</span><span class="p">,</span> <span class="s2">&quot;AN&quot;</span><span class="p">,</span> <span class="s2">&quot;homozygote_count&quot;</span><span class="p">]</span>

    <span class="c1"># Use the generalized function to merge the frequency arrays.</span>
    <span class="n">new_freq</span><span class="p">,</span> <span class="n">new_freq_meta</span> <span class="o">=</span> <span class="n">merge_array_expressions</span><span class="p">(</span>
        <span class="n">farrays</span><span class="p">,</span> <span class="n">fmeta</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">struct_fields</span><span class="o">=</span><span class="n">callstat_ann</span>
    <span class="p">)[:</span><span class="mi">2</span><span class="p">]</span>

    <span class="c1"># Add AF calculation for the merged frequency arrays.</span>
    <span class="n">new_freq</span> <span class="o">=</span> <span class="n">new_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">AF</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">AN</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">AC</span> <span class="o">/</span> <span class="n">x</span><span class="o">.</span><span class="n">AN</span><span class="p">))</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="o">*</span><span class="n">callstat_ann_af</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
        <span class="n">new_counts_array_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">count_array</span> <span class="ow">in</span> <span class="n">count_arrays</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_counts_array</span> <span class="o">=</span> <span class="n">merge_array_expressions</span><span class="p">(</span>
                <span class="n">count_array</span><span class="p">,</span> <span class="n">fmeta</span><span class="p">,</span> <span class="n">operation</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">new_counts_array_dict</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_counts_array</span>

    <span class="n">new_freq_meta</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">new_freq_meta</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">count_arrays</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_freq</span><span class="p">,</span> <span class="n">new_freq_meta</span><span class="p">,</span> <span class="n">new_counts_array_dict</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">new_freq</span><span class="p">,</span> <span class="n">new_freq_meta</span></div>


<div class="viewcode-block" id="merge_histograms"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.merge_histograms">[docs]</a><span class="k">def</span> <span class="nf">merge_histograms</span><span class="p">(</span>
    <span class="n">hists</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">],</span>
    <span class="n">operation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span>
    <span class="n">set_negatives_to_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Merge a list of histogram annotations.</span>

<span class="sd">    This function merges a list of histogram annotations by summing or subtracting the</span>
<span class="sd">    arrays in an element-wise fashion. It keeps one &#39;bin_edge&#39; annotation but merges the</span>
<span class="sd">    &#39;bin_freq&#39;, &#39;n_smaller&#39;, and &#39;n_larger&#39; annotations by summing or subtracting them.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Bin edges are assumed to be the same for all histograms, and lengths of bin edges and frequencies are assumed to be the same for all histograms.</span>

<span class="sd">    :param hists: List of histogram structs to merge.</span>
<span class="sd">    :param operation: Merge operation to perform. Options are &quot;sum&quot; and &quot;diff&quot;.</span>
<span class="sd">        If &quot;diff&quot; is passed, the first histogram will have the other histograms</span>
<span class="sd">        subtracted from it. Default is &quot;sum&quot;.</span>
<span class="sd">    :param set_negatives_to_zero: If True, set negative values to 0. If False, raise</span>
<span class="sd">        a ValueError. Default is False.</span>
<span class="sd">    :return: Merged histogram struct.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">hists</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must provide at least two histograms to merge!&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">operation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;diff&quot;</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Operation must be either &#39;sum&#39; or &#39;diff&#39;!&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_merge_histogram_values</span><span class="p">(</span>
        <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge two histogram structs together.</span>

<span class="sd">        :param i: First histogram struct (accumulator).</span>
<span class="sd">        :param j: Second histogram struct to merge.</span>
<span class="sd">        :return: Merged histogram struct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">merged_bin_freq</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint</span><span class="p">)])),</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">j</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">([</span><span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">tint</span><span class="p">)])),</span>
            <span class="n">fill_missing</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_sum_or_diff_values</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">operation</span><span class="p">))</span>

        <span class="n">merged_n_smaller</span> <span class="o">=</span> <span class="n">_sum_or_diff_values</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">n_smaller</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">n_smaller</span><span class="p">,</span> <span class="n">operation</span><span class="p">)</span>
        <span class="n">merged_n_larger</span> <span class="o">=</span> <span class="n">_sum_or_diff_values</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">n_larger</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">n_larger</span><span class="p">,</span> <span class="n">operation</span><span class="p">)</span>

        <span class="c1"># If specified, set negative values in histogram to zero after merge operation,</span>
        <span class="c1"># otherwise raise an error.</span>
        <span class="n">negative_value_error_msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;Negative values found in merged histogram. Review data or set&quot;</span>
            <span class="s2">&quot; `set_negatives_to_zero` to True to set negative values to 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">merged_bin_freq</span> <span class="o">=</span> <span class="n">merged_bin_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">_handle_negative_values</span><span class="p">(</span>
                <span class="n">x</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">negative_value_error_msg</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">merged_n_smaller</span> <span class="o">=</span> <span class="n">_handle_negative_values</span><span class="p">(</span>
            <span class="n">merged_n_smaller</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">negative_value_error_msg</span>
        <span class="p">)</span>
        <span class="n">merged_n_larger</span> <span class="o">=</span> <span class="n">_handle_negative_values</span><span class="p">(</span>
            <span class="n">merged_n_larger</span><span class="p">,</span> <span class="n">set_negatives_to_zero</span><span class="p">,</span> <span class="n">negative_value_error_msg</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="n">bin_edges</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span> <span class="n">j</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">),</span>
            <span class="n">bin_freq</span><span class="o">=</span><span class="n">merged_bin_freq</span><span class="p">,</span>
            <span class="n">n_smaller</span><span class="o">=</span><span class="n">merged_n_smaller</span><span class="p">,</span>
            <span class="n">n_larger</span><span class="o">=</span><span class="n">merged_n_larger</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
        <span class="n">_merge_histogram_values</span><span class="p">,</span>
        <span class="n">hists</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;bin_edges&quot;</span><span class="p">,</span> <span class="s2">&quot;bin_freq&quot;</span><span class="p">,</span> <span class="s2">&quot;n_smaller&quot;</span><span class="p">,</span> <span class="s2">&quot;n_larger&quot;</span><span class="p">),</span>
        <span class="n">hists</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
    <span class="p">)</span></div>


<span class="c1"># Functions used for computing allele frequency.</span>
<div class="viewcode-block" id="annotate_freq"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_freq">[docs]</a><span class="k">def</span> <span class="nf">annotate_freq</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gen_anc_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subgrp_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]],</span>
            <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsampling_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ds_gen_anc_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">entry_agg_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">annotate_mt</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate `mt` with stratified allele frequencies.</span>

<span class="sd">    The output Matrix table will include:</span>
<span class="sd">        - row annotation `freq` containing the stratified allele frequencies</span>
<span class="sd">        - global annotation `freq_meta` with metadata</span>
<span class="sd">        - global annotation `freq_meta_sample_count` with sample count information</span>

<span class="sd">    .. note::</span>

<span class="sd">        Currently this only supports bi-allelic sites.</span>

<span class="sd">        The input `mt` needs to have the following entry fields:</span>
<span class="sd">          - GT: a CallExpression containing the genotype</span>
<span class="sd">          - adj: a BooleanExpression containing whether the genotype is of high quality</span>
<span class="sd">            or not.</span>

<span class="sd">        All expressions arguments need to be expression on the input `mt`.</span>

<span class="sd">    .. rubric:: `freq` row annotation</span>

<span class="sd">    The `freq` row annotation is an Array of Structs, with each Struct containing the</span>
<span class="sd">    following fields:</span>

<span class="sd">        - AC: int32</span>
<span class="sd">        - AF: float64</span>
<span class="sd">        - AN: int32</span>
<span class="sd">        - homozygote_count: int32</span>

<span class="sd">    Each element of the array corresponds to a stratification of the data, and the</span>
<span class="sd">    metadata about these annotations is stored in the globals.</span>

<span class="sd">    .. rubric:: Global `freq_meta` metadata annotation</span>

<span class="sd">    The global annotation `freq_meta` is added to the input `mt`. It is a list of dict.</span>
<span class="sd">    Each element of the list contains metadata on a frequency stratification and the</span>
<span class="sd">    index in the list corresponds to the index of that frequency stratification in the</span>
<span class="sd">    `freq` row annotation.</span>

<span class="sd">    .. rubric:: Global `freq_meta_sample_count` annotation</span>

<span class="sd">    The global annotation `freq_meta_sample_count` is added to the input `mt`. This is a</span>
<span class="sd">    sample count per sample grouping defined in the `freq_meta` global annotation.</span>

<span class="sd">    .. rubric:: The `additional_strata_expr` parameter</span>

<span class="sd">    If the `additional_strata_expr` parameter is used, frequencies will be computed for</span>
<span class="sd">    each of the strata dictionaries across all values. For example, if</span>
<span class="sd">    `additional_strata_expr` is set to `[{&#39;platform&#39;: mt.platform},</span>
<span class="sd">    {&#39;platform&#39;:mt.platform, &#39;gen_anc&#39;: mt.gen_anc}, {&#39;age_bin&#39;: mt.age_bin}]`, then</span>
<span class="sd">    frequencies will be computed for each of the values of `mt.platform`, each of the</span>
<span class="sd">    combined values of `mt.platform` and `mt.gen_anc`, and each of the values of</span>
<span class="sd">    `mt.age_bin`.</span>

<span class="sd">    .. rubric:: The `downsamplings` parameter</span>

<span class="sd">    If the `downsamplings` parameter is used without the `downsampling_expr`,</span>
<span class="sd">    frequencies will be computed for all samples and by genetic ancestry group (if `gen_anc_expr` is</span>
<span class="sd">    specified) by downsampling the number of samples without replacement to each of the</span>
<span class="sd">    numbers specified in the `downsamplings` array, provided that there are enough</span>
<span class="sd">    samples in the dataset. In addition, if `gen_anc_expr` is specified, a downsampling to</span>
<span class="sd">    each of the exact number of samples present in each genetic ancestry group is added. Note that</span>
<span class="sd">    samples are randomly sampled only once, meaning that the lower downsamplings are</span>
<span class="sd">    subsets of the higher ones. If the `downsampling_expr` parameter is used with the</span>
<span class="sd">    `downsamplings` parameter, the `downsamplings` parameter informs the function which</span>
<span class="sd">    downsampling groups were already created and are to be used in the frequency</span>
<span class="sd">    calculation.</span>

<span class="sd">    .. rubric:: The `downsampling_expr` and `ds_gen_anc_counts` parameters</span>

<span class="sd">    If the `downsampling_expr` parameter is used, `downsamplings` must also be set</span>
<span class="sd">    and frequencies will be computed for all samples and by genetic ancestry group (if `gen_anc_expr`</span>
<span class="sd">    is specified) using the downsampling indices to each of the numbers specified in</span>
<span class="sd">    the `downsamplings` array. The function expects a &#39;global_idx&#39;, and if `gen_anc_expr`</span>
<span class="sd">    is used, a &#39;gen_anc_idx&#39; within the `downsampling_expr` to be used to determine if a</span>
<span class="sd">    sample belongs within a certain downsampling group, i.e. the index is less than</span>
<span class="sd">    the group size. `The function `annotate_downsamplings` can be used to to create</span>
<span class="sd">    the `downsampling_expr`, `downsamplings`, and `ds_gen_anc_counts` expressions.</span>

<span class="sd">    .. rubric:: The `entry_agg_funcs` parameter</span>

<span class="sd">    If the `entry_agg_funcs` parameter is used, the output MatrixTable will also</span>
<span class="sd">    contain the annotations specified in the `entry_agg_funcs` parameter. The keys of</span>
<span class="sd">    the dict are the names of the annotations and the values are tuples of functions.</span>
<span class="sd">    The first function is used to transform the `mt` entries in some way, and the</span>
<span class="sd">    second function is used to aggregate the output from the first function. For</span>
<span class="sd">    example, if `entry_agg_funcs` is set to {&#39;adj_samples&#39;: (get_adj_expr, hl.agg.sum)}`,</span>
<span class="sd">    then the output MatrixTable will contain an annotation `adj_samples` which is an</span>
<span class="sd">    array of the number of adj samples per strata in each row.</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :param sex_expr: When specified, frequencies are stratified by sex. If `gen_anc_expr`</span>
<span class="sd">        is also specified, then a genetic ancestry group/sex stratification is added.</span>
<span class="sd">    :param gen_anc_expr: When specified, frequencies are stratified by genetic ancestry group. If</span>
<span class="sd">        `sex_expr` is also specified, then a genetic ancestry group/sex stratification is added.</span>
<span class="sd">    :param subgrp_expr: When specified, frequencies are stratified by genetic ancestry subgroup.</span>
<span class="sd">        Note that `gen_anc_expr` is required as well when using this option.</span>
<span class="sd">    :param additional_strata_expr: When specified, frequencies are stratified by the</span>
<span class="sd">        given additional strata. This can e.g. be used to stratify by platform,</span>
<span class="sd">        platform-gen-anc, platform-gen-anc-sex.</span>
<span class="sd">    :param downsamplings: When specified, frequencies are computed by downsampling the</span>
<span class="sd">        data to the number of samples given in the list. Note that if `gen_anc_expr` is</span>
<span class="sd">        specified, downsamplings by genetic ancestry group is also computed.</span>
<span class="sd">    :param downsampling_expr: When specified, frequencies are computed using the</span>
<span class="sd">        downsampling indices in the provided StructExpression. Note that if `gen_anc_idx`</span>
<span class="sd">        is specified within the struct, downsamplings by genetic ancestry group is also computed.</span>
<span class="sd">    :param ds_gen_anc_counts: When specified, frequencies are computed by downsampling the</span>
<span class="sd">        data to the number of samples per genetic ancestry group in the dict. The key is the</span>
<span class="sd">        genetic ancestry group and the value is the number of samples.</span>
<span class="sd">    :param entry_agg_funcs: When specified, additional annotations are added to the</span>
<span class="sd">        output Table/MatrixTable. The keys of the dict are the names of the annotations</span>
<span class="sd">        and the values are tuples of functions. The first function is used to transform</span>
<span class="sd">        the `mt` entries in some way, and the second function is used to aggregate the</span>
<span class="sd">        output from the first function.</span>
<span class="sd">    :param annotate_mt: Whether to return the full MatrixTable with annotations added</span>
<span class="sd">        instead of only a Table with `freq` and other annotations. Default is True.</span>
<span class="sd">    :return: MatrixTable or Table with `freq` annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;annotate_freq requires `downsamplings` when using `downsampling_expr`&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">downsampling_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gen_anc_idx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ds_gen_anc_counts</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;annotate_freq requires `ds_gen_anc_counts` when using &quot;</span>
                    <span class="s2">&quot;`downsampling_expr` with gen_anc_idx&quot;</span>
                <span class="p">)</span>
    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following errors were found: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1"># Generate downsamplings and assign downsampling_expr if it is None when</span>
    <span class="c1"># downsamplings is supplied.</span>
    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ds_ht</span> <span class="o">=</span> <span class="n">annotate_downsamplings</span><span class="p">(</span>
            <span class="n">mt</span><span class="p">,</span> <span class="n">downsamplings</span><span class="p">,</span> <span class="n">gen_anc_expr</span><span class="o">=</span><span class="n">gen_anc_expr</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="n">downsamplings</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ds_ht</span><span class="o">.</span><span class="n">downsamplings</span><span class="p">)</span>
        <span class="n">ds_gen_anc_counts</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">ds_ht</span><span class="o">.</span><span class="n">ds_gen_anc_counts</span><span class="p">)</span>
        <span class="n">downsampling_expr</span> <span class="o">=</span> <span class="n">ds_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]</span><span class="o">.</span><span class="n">downsampling</span>

    <span class="c1"># Build list of all stratification groups to be used in the frequency calculation.</span>
    <span class="n">strata_expr</span> <span class="o">=</span> <span class="n">build_freq_stratification_list</span><span class="p">(</span>
        <span class="n">sex_expr</span><span class="o">=</span><span class="n">sex_expr</span><span class="p">,</span>
        <span class="n">gen_anc_expr</span><span class="o">=</span><span class="n">gen_anc_expr</span><span class="p">,</span>
        <span class="n">subgrp_expr</span><span class="o">=</span><span class="n">subgrp_expr</span><span class="p">,</span>
        <span class="n">additional_strata_expr</span><span class="o">=</span><span class="n">additional_strata_expr</span><span class="p">,</span>
        <span class="n">downsampling_expr</span><span class="o">=</span><span class="n">downsampling_expr</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Annotate the MT cols with each of the expressions in strata_expr and redefine</span>
    <span class="c1"># strata_expr based on the column HT with added annotations.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strata_expr</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
    <span class="n">strata_expr</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">}</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">]</span>

    <span class="c1"># Annotate HT with a freq_meta global and group membership array for each sample</span>
    <span class="c1"># indicating whether the sample belongs to the group defined by freq_meta elements.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">generate_freq_group_membership_array</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span>
        <span class="n">strata_expr</span><span class="p">,</span>
        <span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">,</span>
        <span class="n">ds_gen_anc_counts</span><span class="o">=</span><span class="n">ds_gen_anc_counts</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">freq_ht</span> <span class="o">=</span> <span class="n">compute_freq_by_strata</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">group_membership</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]</span><span class="o">.</span><span class="n">group_membership</span><span class="p">),</span>
        <span class="n">entry_agg_funcs</span><span class="o">=</span><span class="n">entry_agg_funcs</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">freq_ht</span> <span class="o">=</span> <span class="n">freq_ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="o">**</span><span class="n">ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">())</span>

    <span class="k">if</span> <span class="n">annotate_mt</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="n">freq_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">])</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="o">**</span><span class="n">freq_ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">mt</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">freq_ht</span></div>


<div class="viewcode-block" id="annotate_downsamplings"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.annotate_downsamplings">[docs]</a><span class="k">def</span> <span class="nf">annotate_downsamplings</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span>
    <span class="n">gen_anc_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate MatrixTable or Table with downsampling groups.</span>

<span class="sd">    :param t: Input MatrixTable or Table.</span>
<span class="sd">    :param downsamplings: List of downsampling sizes.</span>
<span class="sd">    :param gen_anc_expr: Optional expression for genetic ancestry group. When provided, genetic ancestry group</span>
<span class="sd">        downsamplings will be computed for each genetic ancestry group.</span>
<span class="sd">    :return: MatrixTable or Table with downsampling annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">gen_anc</span><span class="o">=</span><span class="n">gen_anc_expr</span><span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">gen_anc</span><span class="o">=</span><span class="n">gen_anc_expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ht</span> <span class="o">=</span> <span class="n">t</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="n">r</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">rand_unif</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

    <span class="c1"># Add a global index for use in computing frequencies, or other aggregate stats on</span>
    <span class="c1"># the downsamplings.</span>
    <span class="n">scan_expr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;global_idx&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">count</span><span class="p">()}</span>

    <span class="c1"># If gen_anc_expr is provided, add all gen_anc counts to the downsamplings list.</span>
    <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gen_anc_counts</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">gen_anc</span><span class="p">),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">gen_anc</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">downsamplings</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">downsamplings</span> <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">gen_anc_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())]</span>
        <span class="n">downsamplings</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">downsamplings</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">gen_anc_counts</span><span class="o">.</span><span class="n">values</span><span class="p">())))</span>
        <span class="c1"># Add an index by gen_anc for use in computing frequencies, or other aggregate stats</span>
        <span class="c1"># on the downsamplings.</span>
        <span class="n">scan_expr</span><span class="p">[</span><span class="s2">&quot;gen_anc_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">gen_anc</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">gen_anc</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gen_anc_counts</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found </span><span class="si">%i</span><span class="s2"> downsamplings: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">downsamplings</span><span class="p">),</span> <span class="n">downsamplings</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">scan_expr</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">scan_expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">downsampling</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">downsampling</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">s</span><span class="p">])</span>

    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">gen_anc_counts</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">ds_gen_anc_counts</span><span class="o">=</span><span class="n">gen_anc_counts</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span></div>


<div class="viewcode-block" id="build_freq_stratification_list"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.build_freq_stratification_list">[docs]</a><span class="k">def</span> <span class="nf">build_freq_stratification_list</span><span class="p">(</span>
    <span class="n">sex_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gen_anc_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subgrp_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span>
        <span class="n">Union</span><span class="p">[</span>
            <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]],</span>
            <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">],</span>
        <span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsampling_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build a list of stratification groupings to be used in frequency calculations based on supplied parameters.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is primarily used through `annotate_freq` but can be used</span>
<span class="sd">        independently if desired. The returned list of stratifications can be passed to</span>
<span class="sd">        `generate_freq_group_membership_array`.</span>

<span class="sd">    :param sex_expr: When specified, the returned list contains a stratification for</span>
<span class="sd">        sex. If `gen_anc_expr` is also specified, then the returned list also contains a</span>
<span class="sd">        stratification for sex/genetic ancestry group.</span>
<span class="sd">    :param gen_anc_expr: When specified, the returned list contains a stratification for</span>
<span class="sd">        genetic ancestry group.</span>
<span class="sd">    :param subgrp_expr: When specified, the returned list contains a stratification for</span>
<span class="sd">        genetic ancestry subgroup. Note that `gen_anc_expr` is required as well when using</span>
<span class="sd">        this option.</span>
<span class="sd">    :param additional_strata_expr: When specified, the returned list contains a</span>
<span class="sd">        stratification for each of the additional strata. This can e.g. be used to</span>
<span class="sd">        stratify by platform, platform-gen-anc, platform-gen-anc-sex.</span>
<span class="sd">    :param downsampling_expr: When specified, the returned list contains a</span>
<span class="sd">        stratification for downsampling. If `gen_anc_expr` is also specified, then the</span>
<span class="sd">        returned list also contains a downsampling/gen-anc stratification.</span>
<span class="sd">    :return: List of dictionaries specifying stratification groups where the keys of</span>
<span class="sd">        each dictionary are strings and the values are corresponding expressions that</span>
<span class="sd">        define the values to stratify frequency calculations by.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">subgrp_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;annotate_freq requires gen_anc_expr when using subgrp_expr&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">downsampling_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;global_idx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="s2">&quot;annotate_freq requires `downsampling_expr` with key &#39;global_idx&#39;&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">downsampling_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gen_anc_idx&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;annotate_freq requires `downsampling_expr` with key &#39;gen_anc_idx&#39; when&quot;</span>
                    <span class="s2">&quot; using `gen_anc_expr`&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;annotate_freq requires `gen_anc_expr` when using `downsampling_expr` &quot;</span>
                    <span class="s2">&quot;with gen_anc_idx&quot;</span>
                <span class="p">)</span>

    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following errors were found: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1"># Build list of strata expressions based on supplied parameters.</span>
    <span class="n">strata_expr</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">:</span> <span class="n">gen_anc_expr</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">sex_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex_expr</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">:</span> <span class="n">gen_anc_expr</span><span class="p">,</span> <span class="s2">&quot;sex&quot;</span><span class="p">:</span> <span class="n">sex_expr</span><span class="p">})</span>
    <span class="k">if</span> <span class="n">subgrp_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">:</span> <span class="n">gen_anc_expr</span><span class="p">,</span> <span class="s2">&quot;subgrp&quot;</span><span class="p">:</span> <span class="n">subgrp_expr</span><span class="p">})</span>

    <span class="c1"># Add downsampling to strata expressions, include gen_anc in the strata if supplied.</span>
    <span class="k">if</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">downsampling_strata</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;downsampling&quot;</span><span class="p">:</span> <span class="n">downsampling_expr</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">gen_anc_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">downsampling_strata</span><span class="p">[</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">gen_anc_expr</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsampling_strata</span><span class="p">)</span>

    <span class="c1"># Add additional strata expressions.</span>
    <span class="k">if</span> <span class="n">additional_strata_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">additional_strata_expr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">additional_strata_expr</span> <span class="o">=</span> <span class="p">[</span><span class="n">additional_strata_expr</span><span class="p">]</span>
        <span class="n">strata_expr</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">additional_strata_expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">strata_expr</span></div>


<div class="viewcode-block" id="generate_freq_group_membership_array"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.generate_freq_group_membership_array">[docs]</a><span class="k">def</span> <span class="nf">generate_freq_group_membership_array</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">strata_expr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]],</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">ds_gen_anc_counts</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">remove_zero_sample_groups</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">no_raw_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a Table with a &#39;group_membership&#39; array for each sample indicating whether the sample belongs to specific stratification groups.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is primarily used through `annotate_freq` but can be used</span>
<span class="sd">        independently if desired. Please see the `annotate_freq` function for more</span>
<span class="sd">        complete documentation.</span>

<span class="sd">    The following global annotations are added to the returned Table:</span>
<span class="sd">        - freq_meta: Each element of the list contains metadata on a stratification</span>
<span class="sd">          group.</span>
<span class="sd">        - freq_meta_sample_count: sample count per grouping defined in `freq_meta`.</span>
<span class="sd">        - If downsamplings or ds_gen_anc_counts are specified, they are also added as</span>
<span class="sd">          global annotations on the returned Table.</span>

<span class="sd">    Each sample is annotated with a &#39;group_membership&#39; array indicating whether the</span>
<span class="sd">    sample belongs to specific stratification groups. All possible value combinations</span>
<span class="sd">    are determined for each stratification grouping in the `strata_expr` list.</span>

<span class="sd">    :param ht: Input Table that contains Expressions specified by `strata_expr`.</span>
<span class="sd">    :param strata_expr: List of dictionaries specifying stratification groups where</span>
<span class="sd">        the keys of each dictionary are strings and the values are corresponding</span>
<span class="sd">        expressions that define the values to stratify frequency calculations by.</span>
<span class="sd">    :param downsamplings: List of downsampling values to include in the stratifications.</span>
<span class="sd">    :param ds_gen_anc_counts: Dictionary of genetic ancestry group counts for each downsampling value.</span>
<span class="sd">    :param remove_zero_sample_groups: Whether to remove groups with a sample count of 0.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    :param no_raw_group: Whether to remove the raw group from the &#39;group_membership&#39;</span>
<span class="sd">        annotation and the &#39;freq_meta&#39; and &#39;freq_meta_sample_count&#39; global annotations.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    :return: Table with the &#39;group_membership&#39; array annotation.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">ds_in_strata</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">)</span>
    <span class="n">global_idx_in_ds_expr</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
        <span class="s2">&quot;global_idx&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;downsampling&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span> <span class="k">if</span> <span class="s2">&quot;downsampling&quot;</span> <span class="ow">in</span> <span class="n">s</span>
    <span class="p">)</span>
    <span class="n">gen_anc_in_strata</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="s2">&quot;gen_anc&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">)</span>
    <span class="n">gen_anc_idx_in_ds_expr</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span>
        <span class="s2">&quot;gen_anc_idx&quot;</span> <span class="ow">in</span> <span class="n">s</span><span class="p">[</span><span class="s2">&quot;downsampling&quot;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata_expr</span>
        <span class="k">if</span> <span class="s2">&quot;downsampling&quot;</span> <span class="ow">in</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">ds_gen_anc_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">ds_in_strata</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a downsampling expression when downsamplings&quot;</span>
            <span class="s2">&quot;are provided.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">global_idx_in_ds_expr</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a downsampling expression with &#39;global_idx&#39; when &quot;</span>
            <span class="s2">&quot;downsamplings are provided.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">ds_gen_anc_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gen_anc_in_strata</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a genetic ancestry group expression &#39;gen_anc&#39; when ds_gen_anc_counts &quot;</span>
            <span class="s2">&quot; are provided.&quot;</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="n">ds_gen_anc_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gen_anc_idx_in_ds_expr</span><span class="p">:</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="s2">&quot;Strata must contain a downsampling expression with &#39;gen_anc_idx&#39; when &quot;</span>
            <span class="s2">&quot;ds_gen_anc_counts are provided.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">errors</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The following errors were found: </span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">errors</span><span class="p">))</span>

    <span class="c1"># Get counters for all strata.</span>
    <span class="n">strata_counts</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span><span class="p">}))</span>
                <span class="k">for</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">strata_expr</span>
                <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">strata</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Add all desired strata to sample group filters.</span>
    <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">[({},</span> <span class="kc">True</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">:</span>
        <span class="n">downsampling_expr</span> <span class="o">=</span> <span class="n">strata</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">)</span>
        <span class="n">strata_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Add to all downsampling groups, both global and genetic ancestry group-specific, to</span>
        <span class="c1"># strata.</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;downsampling&quot;</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">downsamplings</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="p">[(</span><span class="n">s</span><span class="p">,</span> <span class="n">k</span><span class="p">[</span><span class="n">s</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">strata_counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">{})]</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;gen_anc&quot;</span> <span class="ow">and</span> <span class="n">downsampling_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">v</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">,</span> <span class="s2">&quot;global&quot;</span><span class="p">))</span>
            <span class="n">strata_values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># Get all combinations of strata values.</span>
        <span class="n">strata_combinations</span> <span class="o">=</span> <span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">strata_values</span><span class="p">)</span>
        <span class="c1"># Create sample group filters that are evaluated on each sample for each strata</span>
        <span class="c1"># combination. Strata combinations are evaluated as a logical AND, e.g.</span>
        <span class="c1"># {&quot;gen_anc&quot;:nfe, &quot;downsampling&quot;:1000} or &quot;nfe-10000&quot; creates the filter expression</span>
        <span class="c1"># gen_anc == nfe AND downsampling gen_anc_idx &lt; 10000.</span>
        <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">strata_combinations</span><span class="p">:</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">combo</span><span class="p">)</span>
            <span class="n">ds</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">)</span>
            <span class="n">gen_anc</span> <span class="o">=</span> <span class="n">combo</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">)</span>
            <span class="c1"># If combo contains downsampling, determine the downsampling index</span>
            <span class="c1"># annotation to use.</span>
            <span class="n">downsampling_idx</span> <span class="o">=</span> <span class="s2">&quot;global_idx&quot;</span>
            <span class="k">if</span> <span class="n">ds</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">gen_anc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">gen_anc</span> <span class="o">!=</span> <span class="s2">&quot;global&quot;</span><span class="p">:</span>
                    <span class="c1"># Don&#39;t include genetic ancestry group downsamplings where the downsampling is</span>
                    <span class="c1"># larger than the number of samples in the genetic ancestry group.</span>
                    <span class="k">if</span> <span class="n">ds</span> <span class="o">&gt;</span> <span class="n">ds_gen_anc_counts</span><span class="p">[</span><span class="n">gen_anc</span><span class="p">]:</span>
                        <span class="k">continue</span>
                    <span class="n">downsampling_idx</span> <span class="o">=</span> <span class="s2">&quot;gen_anc_idx&quot;</span>

            <span class="c1"># If combo contains downsampling, add downsampling filter expression.</span>
            <span class="n">combo_filter_exprs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">combo</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="s2">&quot;downsampling&quot;</span><span class="p">:</span>
                    <span class="n">combo_filter_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">downsampling_expr</span><span class="p">[</span><span class="n">downsampling_idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot;gen_anc&quot;</span> <span class="ow">or</span> <span class="n">v</span> <span class="o">!=</span> <span class="s2">&quot;global&quot;</span><span class="p">:</span>
                        <span class="n">combo_filter_exprs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">strata</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">==</span> <span class="n">v</span><span class="p">)</span>
            <span class="n">combo</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">combo</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">sample_group_filters</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">combo</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">combo_filter_exprs</span><span class="p">)))</span>

    <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sample_group_filters</span><span class="p">)</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;number of filters: </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">n_groups</span><span class="p">)</span>

    <span class="c1"># Get sample count per strata group.</span>
    <span class="n">freq_meta_sample_count</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_zero_sample_groups</span><span class="p">:</span>
        <span class="n">filter_freq</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">freq_meta_sample_count</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">freq_meta_sample_count</span> <span class="o">=</span> <span class="n">filter_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">idx_keep</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">filter_freq</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="n">sample_group_filters</span> <span class="o">=</span> <span class="p">[</span><span class="n">sample_group_filters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx_keep</span><span class="p">]</span>

    <span class="c1"># Annotate columns with group_membership.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">group_membership</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">sample_group_filters</span><span class="p">])</span>

    <span class="c1"># Create and annotate global expression with meta and sample count information.</span>
    <span class="n">freq_meta</span> <span class="o">=</span> <span class="p">[</span>
        <span class="nb">dict</span><span class="p">(</span><span class="o">**</span><span class="n">sample_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">group</span><span class="o">=</span><span class="s2">&quot;adj&quot;</span><span class="p">)</span> <span class="k">for</span> <span class="n">sample_group</span> <span class="ow">in</span> <span class="n">sample_group_filters</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">no_raw_group</span><span class="p">:</span>
        <span class="c1"># Sample group membership for the &quot;raw&quot; group, representing all samples, is</span>
        <span class="c1"># the same as the first group in the group_membership array.</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">group_membership</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ht</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">ht</span><span class="o">.</span><span class="n">group_membership</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Add the &quot;raw&quot; group, representing all samples, to the freq_meta_expr list.</span>
        <span class="n">freq_meta</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;raw&quot;</span><span class="p">})</span>
        <span class="n">freq_meta_sample_count</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">freq_meta_sample_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">freq_meta_sample_count</span>
        <span class="p">)</span>

    <span class="n">global_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;freq_meta&quot;</span><span class="p">:</span> <span class="n">freq_meta</span><span class="p">,</span>
        <span class="s2">&quot;freq_meta_sample_count&quot;</span><span class="p">:</span> <span class="n">freq_meta_sample_count</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;downsamplings&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downsamplings</span>
    <span class="k">if</span> <span class="n">ds_gen_anc_counts</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;ds_gen_anc_counts&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ds_gen_anc_counts</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span><span class="o">**</span><span class="n">global_expr</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;group_membership&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="compute_freq_by_strata"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.compute_freq_by_strata">[docs]</a><span class="k">def</span> <span class="nf">compute_freq_by_strata</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">entry_agg_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">select_fields</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_membership_includes_raw_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute call statistics and, when passed, entry aggregation function(s) by strata.</span>

<span class="sd">    The computed call statistics are AC, AF, AN, and homozygote_count. The entry</span>
<span class="sd">    aggregation functions are applied to the MatrixTable entries and aggregated. The</span>
<span class="sd">    MatrixTable must contain a &#39;group_membership&#39; annotation (like the one added by</span>
<span class="sd">    `generate_freq_group_membership_array`) that is a list of bools to aggregate the</span>
<span class="sd">    columns by.</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function is primarily used through `annotate_freq` but can be used</span>
<span class="sd">        independently if desired. Please see the `annotate_freq` function for more</span>
<span class="sd">        complete documentation.</span>

<span class="sd">    :param mt: Input MatrixTable.</span>
<span class="sd">    :param entry_agg_funcs: Optional dict of entry aggregation functions. When</span>
<span class="sd">        specified, additional annotations are added to the output Table/MatrixTable.</span>
<span class="sd">        The keys of the dict are the names of the annotations and the values are tuples</span>
<span class="sd">        of functions. The first function is used to transform the `mt` entries in some</span>
<span class="sd">        way, and the second function is used to aggregate the output from the first</span>
<span class="sd">        function.</span>
<span class="sd">    :param select_fields: Optional list of row fields from `mt` to keep on the output</span>
<span class="sd">        Table.</span>
<span class="sd">    :param group_membership_includes_raw_group: Whether the &#39;group_membership&#39;</span>
<span class="sd">        annotation includes an entry for the &#39;raw&#39; group, representing all samples. If</span>
<span class="sd">        False, the &#39;raw&#39; group is inserted as the second element in all added</span>
<span class="sd">        annotations using the same &#39;group_membership&#39;, resulting</span>
<span class="sd">        in array lengths of &#39;group_membership&#39;+1. If True, the second element of each</span>
<span class="sd">        added annotation is still the &#39;raw&#39; group, but the group membership is</span>
<span class="sd">        determined by the values in the second element of &#39;group_membership&#39;, and the</span>
<span class="sd">        output annotations will be the same length as &#39;group_membership&#39;. Default is</span>
<span class="sd">        True.</span>
<span class="sd">    :return: Table or MatrixTable with allele frequencies by strata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">group_membership_includes_raw_group</span><span class="p">:</span>
        <span class="c1"># Add the &#39;raw&#39; group to the &#39;group_membership&#39; annotation.</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span>
            <span class="n">group_membership</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="c1"># Add adj_groups global annotation indicating that the second element in</span>
    <span class="c1"># group_membership is &#39;raw&#39; and all others are &#39;adj&#39;.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
        <span class="n">adj_groups</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">1</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">entry_agg_funcs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">entry_agg_funcs</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">def</span> <span class="nf">_get_freq_expr</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">CallExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get struct expression with call statistics.</span>

<span class="sd">        :param gt_expr: CallExpression to compute call statistics on.</span>
<span class="sd">        :return: StructExpression with call statistics.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the source Table for the CallExpression to grab alleles.</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">gt_expr</span><span class="o">.</span><span class="n">_indices</span><span class="o">.</span><span class="n">source</span>
        <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">call_stats</span><span class="p">(</span><span class="n">gt_expr</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span>
        <span class="c1"># Select non-ref allele (assumes bi-allelic).</span>
        <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">freq_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AC</span><span class="o">=</span><span class="n">freq_expr</span><span class="o">.</span><span class="n">AC</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">AF</span><span class="o">=</span><span class="n">freq_expr</span><span class="o">.</span><span class="n">AF</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">homozygote_count</span><span class="o">=</span><span class="n">freq_expr</span><span class="o">.</span><span class="n">homozygote_count</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">freq_expr</span>

    <span class="n">entry_agg_funcs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">GT</span><span class="p">,</span> <span class="n">_get_freq_expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">agg_by_strata</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">entry_agg_funcs</span><span class="p">,</span> <span class="n">select_fields</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="agg_by_strata"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.agg_by_strata">[docs]</a><span class="k">def</span> <span class="nf">agg_by_strata</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">entry_agg_funcs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]],</span>
    <span class="n">select_fields</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_membership_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">entry_agg_group_membership</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get row expression for annotations of each entry aggregation function(s) by strata.</span>

<span class="sd">    The entry aggregation functions are applied to the MatrixTable entries and</span>
<span class="sd">    aggregated. If no `group_membership_ht` (like the one returned by</span>
<span class="sd">    `generate_freq_group_membership_array`) is supplied, `mt` must contain a</span>
<span class="sd">    &#39;group_membership&#39; annotation that is a list of bools to aggregate the columns by.</span>

<span class="sd">    :param mt: Input MatrixTable.</span>
<span class="sd">    :param entry_agg_funcs: Dict of entry aggregation functions where the</span>
<span class="sd">        keys of the dict are the names of the annotations and the values are tuples</span>
<span class="sd">        of functions. The first function is used to transform the `mt` entries in some</span>
<span class="sd">        way, and the second function is used to aggregate the output from the first</span>
<span class="sd">        function.</span>
<span class="sd">    :param select_fields: Optional list of row fields from `mt` to keep on the output</span>
<span class="sd">        Table.</span>
<span class="sd">    :param group_membership_ht: Optional Table containing group membership annotations</span>
<span class="sd">        to stratify the aggregations by. If not provided, the &#39;group_membership&#39;</span>
<span class="sd">        annotation is expected to be present on `mt`.</span>
<span class="sd">    :param entry_agg_group_membership: Optional dict indicating the subset of group</span>
<span class="sd">        strata in &#39;freq_meta&#39; to run the entry aggregation functions on. The keys of</span>
<span class="sd">        the dict can be any of the keys in `entry_agg_funcs` and the values are lists</span>
<span class="sd">        of dicts. Each dict in the list contains the strata in &#39;freq_meta&#39; to use for</span>
<span class="sd">        the corresponding entry aggregation function. If provided, &#39;freq_meta&#39; must be</span>
<span class="sd">        present in `group_membership_ht` or `mt` and represent the same strata as those</span>
<span class="sd">        in &#39;group_membership&#39;. If not provided, all entries of the &#39;group_membership&#39;</span>
<span class="sd">        annotation will have the entry aggregation functions applied to them.</span>
<span class="sd">    :return: Table with annotations of stratified aggregations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">group_membership_ht</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;group_membership&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;group_membership&#39; annotation is not found in the input MatrixTable &quot;</span>
            <span class="s2">&quot;and &#39;group_membership_ht&#39; is not specified.&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">select_fields</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">select_fields</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">group_membership_ht</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;&#39;group_membership_ht&#39; is not specified, using sample stratification &quot;</span>
            <span class="s2">&quot;indicated by the &#39;group_membership&#39; annotation on the input MatrixTable.&quot;</span>
        <span class="p">)</span>
        <span class="n">group_globals</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">index_globals</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;&#39;group_membership_ht&#39; is specified, using sample stratification indicated &quot;</span>
            <span class="s2">&quot;by its &#39;group_membership&#39; annotation.&quot;</span>
        <span class="p">)</span>
        <span class="n">group_globals</span> <span class="o">=</span> <span class="n">group_membership_ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">()</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span>
            <span class="n">group_membership</span><span class="o">=</span><span class="n">group_membership_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">]</span><span class="o">.</span><span class="n">group_membership</span>
        <span class="p">)</span>

    <span class="n">global_expr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">n_groups</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">group_membership</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">if</span> <span class="s2">&quot;adj_groups&quot;</span> <span class="ow">in</span> <span class="n">group_globals</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Using the &#39;adj_groups&#39; global annotation to determine adj filtered &quot;</span>
            <span class="s2">&quot;stratification groups.&quot;</span>
        <span class="p">)</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_globals</span><span class="o">.</span><span class="n">adj_groups</span>
    <span class="k">elif</span> <span class="s2">&quot;freq_meta&quot;</span> <span class="ow">in</span> <span class="n">group_globals</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;No &#39;adj_groups&#39; global annotation found, using the &#39;freq_meta&#39; global &quot;</span>
            <span class="s2">&quot;annotation to determine adj filtered stratification groups.&quot;</span>
        <span class="p">)</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_globals</span><span class="o">.</span><span class="n">freq_meta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;No &#39;adj_groups&#39; or &#39;freq_meta&#39; global annotations found. All groups will &quot;</span>
            <span class="s2">&quot;be considered non-adj.&quot;</span>
        <span class="p">)</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_groups</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="kc">False</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">entry_agg_group_membership</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;freq_meta&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_globals</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;freq_meta&#39; global annotation must be supplied when the&quot;</span>
            <span class="s2">&quot; &#39;entry_agg_group_membership&#39; is specified.&quot;</span>
        <span class="p">)</span>

    <span class="n">entry_agg_group_membership</span> <span class="o">=</span> <span class="n">entry_agg_group_membership</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">entry_agg_group_membership</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">ann</span><span class="p">:</span> <span class="p">[</span><span class="n">group_globals</span><span class="p">[</span><span class="s2">&quot;freq_meta&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">strata</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">strata</span> <span class="ow">in</span> <span class="n">entry_agg_group_membership</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="n">n_adj_groups</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">n_adj_groups</span> <span class="o">!=</span> <span class="n">n_groups</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The number of elements in the &#39;adj_groups&#39; (</span><span class="si">{</span><span class="n">n_adj_groups</span><span class="si">}</span><span class="s2">) global &quot;</span>
            <span class="s2">&quot;annotation does not match the number of elements in the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;group_membership&#39; annotation (</span><span class="si">{</span><span class="n">n_groups</span><span class="si">}</span><span class="s2">)!&quot;</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Keep only the entries needed for the aggregation functions.</span>
    <span class="n">select_expr</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="p">{</span><span class="n">ann</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="mi">0</span><span class="p">](</span><span class="n">mt</span><span class="p">)</span> <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">entry_agg_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()}}</span>
    <span class="n">has_adj</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">]))</span>
    <span class="k">if</span> <span class="n">has_adj</span><span class="p">:</span>
        <span class="n">select_expr</span><span class="p">[</span><span class="s2">&quot;adj&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">adj</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="o">**</span><span class="n">select_expr</span><span class="p">)</span>

    <span class="c1"># Convert MT to HT with a row annotation that is an array of all samples entries</span>
    <span class="c1"># for that variant.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">localize_entries</span><span class="p">(</span><span class="s2">&quot;entries&quot;</span><span class="p">,</span> <span class="s2">&quot;cols&quot;</span><span class="p">)</span>

    <span class="c1"># For each stratification group in group_membership, determine the indices of the</span>
    <span class="c1"># samples that belong to that group.</span>
    <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;indices_by_group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_groups</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">g_i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">count_cols</span><span class="p">())</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">s_i</span><span class="p">:</span> <span class="n">ht</span><span class="o">.</span><span class="n">cols</span><span class="p">[</span><span class="n">s_i</span><span class="p">]</span><span class="o">.</span><span class="n">group_membership</span><span class="p">[</span><span class="n">g_i</span><span class="p">]</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="o">**</span><span class="n">global_expr</span><span class="p">)</span>

    <span class="c1"># Pull out each annotation that will be used in the array aggregation below as its</span>
    <span class="c1"># own ArrayExpression. This is important to prevent memory issues when performing</span>
    <span class="c1"># the below array aggregations.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="o">*</span><span class="n">select_fields</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span><span class="n">ann</span><span class="p">:</span> <span class="n">ht</span><span class="o">.</span><span class="n">entries</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">e</span><span class="p">:</span> <span class="n">e</span><span class="p">[</span><span class="n">ann</span><span class="p">])</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">select_expr</span><span class="o">.</span><span class="n">keys</span><span class="p">()},</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_agg_by_group</span><span class="p">(</span>
        <span class="n">indices_by_group_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
        <span class="n">adj_groups_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
        <span class="n">agg_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span>
        <span class="n">ann_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregate `agg_expr` by group using the `agg_func` function.</span>

<span class="sd">        :param indices_by_group_expr: ArrayExpression of indices of samples in each group.</span>
<span class="sd">        :param adj_groups_expr: ArrayExpression indicating whether each group is adj.</span>
<span class="sd">        :param agg_func: Aggregation function to apply to `ann_expr`.</span>
<span class="sd">        :param ann_expr: Expression to aggregate by group.</span>
<span class="sd">        :return: Aggregated array expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f_no_adj</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">ann_expr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">has_adj</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">adj</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">adj</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">f_no_adj</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span> <span class="n">f_no_adj</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">f_no_adj</span>

        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">s_indices</span><span class="p">,</span> <span class="n">adj</span><span class="p">:</span> <span class="n">s_indices</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">adj</span><span class="p">)),</span>
            <span class="n">indices_by_group_expr</span><span class="p">,</span>
            <span class="n">adj_groups_expr</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># Add annotations for any supplied entry transform and aggregation functions.</span>
    <span class="c1"># Filter groups to only those in entry_agg_group_membership if specified.</span>
    <span class="c1"># If there are no specific entry group indices for an annotation, use ht[g]</span>
    <span class="c1"># to consider all groups without filtering.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="o">*</span><span class="n">select_fields</span><span class="p">,</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">ann</span><span class="p">:</span> <span class="n">_agg_by_group</span><span class="p">(</span>
                <span class="o">*</span><span class="p">[</span>
                    <span class="p">[</span><span class="n">ht</span><span class="p">[</span><span class="n">g</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">entry_agg_group_membership</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">ann</span><span class="p">,</span> <span class="p">[])]</span> <span class="ow">or</span> <span class="n">ht</span><span class="p">[</span><span class="n">g</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;indices_by_group&quot;</span><span class="p">,</span> <span class="s2">&quot;adj_groups&quot;</span><span class="p">]</span>
                <span class="p">],</span>
                <span class="n">agg_func</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">ann_expr</span><span class="o">=</span><span class="n">ht</span><span class="p">[</span><span class="n">ann</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">entry_agg_funcs</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">},</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;cols&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="update_structured_annotations"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.update_structured_annotations">[docs]</a><span class="k">def</span> <span class="nf">update_structured_annotations</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotation_update_exprs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">annotation_update_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Update highly structured annotations on a Table.</span>

<span class="sd">    This function recursively updates annotations defined by `annotation_update_exprs`</span>
<span class="sd">    and if `annotation_update_label` is supplied, it checks if the sample annotations</span>
<span class="sd">    are different from the input and adds a flag to the Table, indicating which</span>
<span class="sd">    annotations have been updated for each sample.</span>

<span class="sd">    :param ht: Input Table with structured annotations to update.</span>
<span class="sd">    :param annotation_update_exprs: Dictionary of annotations to update, structured as</span>
<span class="sd">        they are structured on the input `ht`.</span>
<span class="sd">    :param annotation_update_label: Optional string of the label to use for an</span>
<span class="sd">        annotation indicating which annotations have been updated. Default is None, so</span>
<span class="sd">        no annotation is added.</span>
<span class="sd">    :return: Table with updated annotations and optionally a flag indicating which</span>
<span class="sd">        annotations were changed.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_update_struct</span><span class="p">(</span>
        <span class="n">struct_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
        <span class="n">update_exprs</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">],</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update a StructExpression.</span>

<span class="sd">        :param struct_expr: StructExpression to update.</span>
<span class="sd">        :param update_exprs: Dictionary of annotations to update.</span>
<span class="sd">        :return: Tuple of the updated annotations and the updated flag.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">update_exprs</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">updated_struct_expr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">updated_flag_expr</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">update_exprs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">struct_expr</span><span class="p">:</span>
                    <span class="n">updated_flag</span><span class="p">,</span> <span class="n">updated_ann</span> <span class="o">=</span> <span class="n">_update_struct</span><span class="p">(</span><span class="n">struct_expr</span><span class="p">[</span><span class="n">ann</span><span class="p">],</span> <span class="n">expr</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">updated_flag</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">}</span>
                    <span class="n">updated_ann</span> <span class="o">=</span> <span class="n">expr</span>
                <span class="n">updated_flag_expr</span><span class="o">.</span><span class="n">update</span><span class="p">(</span>
                    <span class="p">{</span><span class="n">ann</span> <span class="o">+</span> <span class="p">(</span><span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">k</span> <span class="k">if</span> <span class="n">k</span> <span class="k">else</span> <span class="s2">&quot;&quot;</span><span class="p">):</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">updated_flag</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
                <span class="p">)</span>
                <span class="n">updated_struct_expr</span><span class="p">[</span><span class="n">ann</span><span class="p">]</span> <span class="o">=</span> <span class="n">updated_ann</span>
            <span class="k">return</span> <span class="n">updated_flag_expr</span><span class="p">,</span> <span class="n">struct_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">updated_struct_expr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="n">update_exprs</span> <span class="o">!=</span> <span class="n">struct_expr</span><span class="p">},</span> <span class="n">update_exprs</span>

    <span class="n">annotation_update_flag</span><span class="p">,</span> <span class="n">updated_rows</span> <span class="o">=</span> <span class="n">_update_struct</span><span class="p">(</span>
        <span class="n">ht</span><span class="o">.</span><span class="n">row_value</span><span class="p">,</span> <span class="n">annotation_update_exprs</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">annotation_update_label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">updated_rows</span> <span class="o">=</span> <span class="n">updated_rows</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">annotation_update_label</span><span class="p">:</span> <span class="n">filter_utils</span><span class="o">.</span><span class="n">add_filters_expr</span><span class="p">(</span>
                    <span class="n">filters</span><span class="o">=</span><span class="n">annotation_update_flag</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">updated_rows</span><span class="p">)</span></div>


<div class="viewcode-block" id="fill_missing_key_combinations"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.fill_missing_key_combinations">[docs]</a><span class="k">def</span> <span class="nf">fill_missing_key_combinations</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">fill_values</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">],</span>
    <span class="n">key_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Fill missing key combinations with requested fill values.</span>

<span class="sd">    This function fills missing key combinations in the input Table with requested fill</span>
<span class="sd">    values. The fill values are specified in the `fill_values` dictionary. The unique</span>
<span class="sd">    values for each key field are collected from the input Table unless specified in</span>
<span class="sd">    the `key_values` dictionary.</span>

<span class="sd">    This is useful when you want to ensure that all possible key combinations are</span>
<span class="sd">    present in a Table, even if they are missing from the input Table. This can</span>
<span class="sd">    happen when you are aggregating data and want to ensure that all possible key</span>
<span class="sd">    combinations are present in the output Table, not only the ones that are present.</span>

<span class="sd">    Example::</span>

<span class="sd">        .. code-block:: python</span>

<span class="sd">            ht = hl.Table.parallelize(</span>
<span class="sd">                [</span>
<span class="sd">                    {&#39;key1&#39;: &#39;A&#39;, &#39;key2&#39;: 1, &#39;value&#39;: 10},</span>
<span class="sd">                    {&#39;key1&#39;: &#39;A&#39;, &#39;key2&#39;: 2, &#39;value&#39;: 20},</span>
<span class="sd">                    {&#39;key1&#39;: &#39;B&#39;, &#39;key2&#39;: 1, &#39;value&#39;: 30},</span>
<span class="sd">                ],</span>
<span class="sd">                hl.tstruct(key1=hl.tstr, key2=hl.tint32, value=hl.tint32),</span>
<span class="sd">                key=[&#39;key1&#39;, &#39;key2&#39;],</span>
<span class="sd">            )</span>
<span class="sd">            fill_values = {&#39;value&#39;: hl.missing(hl.tint32)}</span>
<span class="sd">            filled_ht = fill_missing_key_combinations(ht, fill_values)</span>
<span class="sd">            filled_ht.show()</span>

<span class="sd">        +------+------+</span>
<span class="sd">        | key1 | key2 | value |</span>
<span class="sd">        +------+------+</span>
<span class="sd">        |  A   |  1   |  10   |</span>
<span class="sd">        |  A   |  2   |  20   |</span>
<span class="sd">        |  B   |  1   |  30   |</span>
<span class="sd">        |  B   |  2   | null  |</span>
<span class="sd">        +------+------+</span>

<span class="sd">    In this example, the input table is missing the combination (B, 2).</span>
<span class="sd">    After applying `fill_missing_key_combinations`, the missing key combination</span>
<span class="sd">    (B, 2) is filled with the specified fill value for &#39;value&#39; (null in this case).</span>

<span class="sd">    :param ht: Input Table containing key fields.</span>
<span class="sd">    :param fill_values: Dictionary of fill values to use for missing key combinations.</span>
<span class="sd">    :param key_values: Optional dictionary of unique values to use for each key field.</span>
<span class="sd">        Default is None. If None, the unique values for each key field are collected</span>
<span class="sd">        from the input Table.</span>
<span class="sd">    :return: Table with missing key combinations filled with requested fill values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">key_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="c1"># Extract unique values for each annotation.</span>
    <span class="n">key_values</span> <span class="o">=</span> <span class="n">key_values</span> <span class="ow">or</span> <span class="p">{}</span>
    <span class="n">key_values</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">key_values</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect_as_set</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="n">f</span><span class="p">])))</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">key_fields</span>
    <span class="p">]</span>

    <span class="c1"># Create all combinations of the unique values for each key.</span>
    <span class="n">all_combinations</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="n">key_values</span><span class="p">))</span>

    <span class="c1"># Convert the list of combinations to a Hail Table.</span>
    <span class="n">all_combinations_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="o">.</span><span class="n">parallelize</span><span class="p">(</span>
        <span class="p">[{</span><span class="n">f</span><span class="p">:</span> <span class="n">c</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">key_fields</span><span class="p">,</span> <span class="n">combo</span><span class="p">)}</span> <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">all_combinations</span><span class="p">],</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">tstruct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">key_fields</span><span class="p">}),</span>
    <span class="p">)</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="o">*</span><span class="n">key_fields</span><span class="p">)</span>

    <span class="c1"># Left join original table with all_combinations to include all possible</span>
    <span class="c1"># combinations.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">all_combinations_ht</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>

    <span class="c1"># Fill missing row annotations with requested fill values.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="n">f</span><span class="p">],</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">fill_values</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="missing_struct_expr"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.missing_struct_expr">[docs]</a><span class="k">def</span> <span class="nf">missing_struct_expr</span><span class="p">(</span>
    <span class="n">dtypes</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">types</span><span class="o">.</span><span class="n">tstruct</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a struct of missing values corresponding to each field and type in the input struct.</span>

<span class="sd">    :param dtypes: StructExpression containing the field names and missing values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">dtypes</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span></div>


<div class="viewcode-block" id="add_gks_vrs"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_gks_vrs">[docs]</a><span class="k">def</span> <span class="nf">add_gks_vrs</span><span class="p">(</span>
    <span class="n">input_locus</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
    <span class="n">input_vrs</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a dictionary containing VRS information from a given locus and struct of VRS information.</span>

<span class="sd">    Dict will have GA4GH GKS VRS structure.</span>

<span class="sd">    :param input_locus: Locus field from a struct (locus of result of running .collect() on a Hail table).</span>
<span class="sd">    :param input_vrs: VRS struct (such as from a ht.info.vrs field).</span>
<span class="sd">    :return: Python dictionary conforming to GA4GH GKS VRS structure.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># NOTE: The pinned ga4gh.vrs module breaks logging when this annotations module is</span>
    <span class="c1"># imported. Importing ga4gh here to avoid this issue.</span>
    <span class="kn">import</span> <span class="nn">ga4gh.core</span> <span class="k">as</span> <span class="nn">ga4gh_core</span>
    <span class="kn">import</span> <span class="nn">ga4gh.vrs</span> <span class="k">as</span> <span class="nn">ga4gh_vrs</span>

    <span class="n">build_in</span> <span class="o">=</span> <span class="n">input_locus</span><span class="o">.</span><span class="n">reference_genome</span><span class="o">.</span><span class="n">name</span>
    <span class="n">chr_in</span> <span class="o">=</span> <span class="n">input_locus</span><span class="o">.</span><span class="n">contig</span>

    <span class="n">chrom_dict</span> <span class="o">=</span> <span class="n">VRS_CHROM_IDS</span><span class="p">[</span><span class="n">build_in</span><span class="p">]</span>
    <span class="n">vrs_id</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_Allele_IDs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vrs_chrom_id</span> <span class="o">=</span> <span class="n">chrom_dict</span><span class="p">[</span><span class="n">chr_in</span><span class="p">]</span>
    <span class="n">vrs_start_value</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_Starts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vrs_end_value</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_Ends</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">vrs_state_sequence</span> <span class="o">=</span> <span class="n">input_vrs</span><span class="o">.</span><span class="n">VRS_States</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="n">vrs_dict_out</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;_id&quot;</span><span class="p">:</span> <span class="n">vrs_id</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Allele&quot;</span><span class="p">,</span>
        <span class="s2">&quot;location&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;SequenceLocation&quot;</span><span class="p">,</span>
            <span class="s2">&quot;sequence_id&quot;</span><span class="p">:</span> <span class="n">vrs_chrom_id</span><span class="p">,</span>
            <span class="s2">&quot;interval&quot;</span><span class="p">:</span> <span class="p">{</span>
                <span class="s2">&quot;start&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Number&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">vrs_start_value</span><span class="p">},</span>
                <span class="s2">&quot;end&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;Number&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">vrs_end_value</span><span class="p">},</span>
                <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;SequenceInterval&quot;</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">},</span>
        <span class="s2">&quot;state&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;LiteralSequenceExpression&quot;</span><span class="p">,</span> <span class="s2">&quot;sequence&quot;</span><span class="p">:</span> <span class="n">vrs_state_sequence</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="n">location_id</span> <span class="o">=</span> <span class="n">ga4gh_core</span><span class="o">.</span><span class="n">_internal</span><span class="o">.</span><span class="n">identifiers</span><span class="o">.</span><span class="n">ga4gh_identify</span><span class="p">(</span>
        <span class="n">ga4gh_vrs</span><span class="o">.</span><span class="n">models</span><span class="o">.</span><span class="n">SequenceLocation</span><span class="p">(</span><span class="o">**</span><span class="n">vrs_dict_out</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">])</span>
    <span class="p">)</span>

    <span class="n">vrs_dict_out</span><span class="p">[</span><span class="s2">&quot;location&quot;</span><span class="p">][</span><span class="s2">&quot;_id&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">location_id</span>

    <span class="k">return</span> <span class="n">vrs_dict_out</span></div>


<div class="viewcode-block" id="add_gks_va"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.add_gks_va">[docs]</a><span class="k">def</span> <span class="nf">add_gks_va</span><span class="p">(</span>
    <span class="n">input_struct</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">,</span>
    <span class="n">label_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;gnomAD&quot;</span><span class="p">,</span>
    <span class="n">label_version</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;3.1.2&quot;</span><span class="p">,</span>
    <span class="n">gen_anc_groups</span><span class="p">:</span> <span class="nb">list</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gen_anc_groups_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">by_sex</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">freq_index_dict</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate Python dictionary containing GKS VA annotations.</span>

<span class="sd">    Populate the dictionary with frequency information conforming to the GKS VA frequency schema.</span>
<span class="sd">    If gen_anc_groups or by_sex is provided, also include subcohort schemas for each cohort.</span>
<span class="sd">    If input_struct has mean_depth, it is added to ancillaryResults.</span>
<span class="sd">    This annotation is added under the gks_va_freq_dict field of the table.</span>
<span class="sd">    The focusAllele field is not populated, and must be filled in by the caller.</span>

<span class="sd">    :param input_struct: Hail struct for a desired variant (such as result of running .collect()[0] on a Table).</span>
<span class="sd">    :param label_name: Label name to use within the returned dictionary. Example: &quot;gnomAD&quot;.</span>
<span class="sd">    :param label_version: String listing the version of the table being used. Example: &quot;3.1.2&quot;.</span>
<span class="sd">    :param gen_anc_groups: List of strings of shortened names of cohorts to return results for.</span>
<span class="sd">        Example: [&#39;afr&#39;,&#39;fin&#39;,&#39;nfe&#39;]. Default is None.</span>
<span class="sd">    :param gen_anc_groups_dict: Dict mapping shortened genetic ancestry group names to full names.</span>
<span class="sd">        Example: {&#39;afr&#39;:&#39;African/African American&#39;}. Default is None.</span>
<span class="sd">    :param by_sex: Boolean to include breakdown of cohorts by inferred sex (XX and XY) as well.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    :freq_index_dict: Dict mapping groups to their index for freq info in ht.freq_index_dict[0].</span>
<span class="sd">        Default is None.</span>
<span class="sd">    :return: Tuple containing a dictionary containing GKS VA frequency information,</span>
<span class="sd">        (split by genetic ancestry groups and sex if desired) for the specified variant.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Throw warnings if contradictory arguments passed.</span>
    <span class="k">if</span> <span class="n">by_sex</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">gen_anc_groups</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Splitting whole database by sex is not yet supported. If using &#39;by_sex&#39;,&quot;</span>
            <span class="s2">&quot; please also specify &#39;gen_anc_groups&#39; to stratify by.&quot;</span>
        <span class="p">)</span>

    <span class="n">contig</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span>
    <span class="n">pos</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">var</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">gnomad_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">contig</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">pos</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">ref</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">var</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="c1"># Define function to return a frequency report dictionary for a given group</span>
    <span class="k">def</span> <span class="nf">_create_group_dicts</span><span class="p">(</span>
        <span class="n">group_id</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">group_label</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">group_sex</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a dictionary containing the frequency information of a given variant for a given group.</span>

<span class="sd">        :param group_index: Index of frequency within the &#39;freq&#39; annotation for the desired group.</span>
<span class="sd">        :param group_id: String containing variant, genetic ancestry group, and sex (if requested).</span>
<span class="sd">            - Example: &quot;chr19-41094895-C-T.afr.XX&quot;.</span>
<span class="sd">        :param group_label: String containing the full name of genetic ancestry group requested.</span>
<span class="sd">            - Example: &quot;African/African American&quot;.</span>
<span class="sd">        :param group_sex: String indicating the sex of the group.</span>
<span class="sd">            - Example: &quot;XX&quot; or &quot;XY&quot;.</span>
<span class="sd">        :return: Dictionary containing variant frequency information,</span>
<span class="sd">            - (by genetic ancestry group and sex if desired) for specified variant.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">group_sex</span><span class="p">:</span>
            <span class="n">cohort_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_id</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">group_sex</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">freq_index_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="n">group_sex</span><span class="si">}</span><span class="s2">_adj&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cohort_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_id</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">freq_index_key</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">_adj&quot;</span>
        <span class="n">record_id</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">cohort_id</span><span class="si">}</span><span class="s2">&quot;</span>

        <span class="c1"># Obtain frequency information for the specified variant.</span>
        <span class="n">group_freq</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">freq_index_dict</span><span class="p">[</span><span class="n">freq_index_key</span><span class="p">]]</span>

        <span class="c1"># Cohort characteristics.</span>
        <span class="n">characteristics</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">characteristics</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;genetic ancestry&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">group_label</span><span class="p">})</span>
        <span class="k">if</span> <span class="n">group_sex</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">characteristics</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;biological sex&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">group_sex</span><span class="p">})</span>

        <span class="c1"># Dictionary to be returned containing information for a specified group.</span>
        <span class="n">freq_record</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">record_id</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;CohortAlleleFrequency&quot;</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_label</span><span class="si">}</span><span class="s2"> Cohort Allele Frequency for </span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;focusAllele&quot;</span><span class="p">:</span> <span class="s2">&quot;#/focusAllele&quot;</span><span class="p">,</span>
            <span class="s2">&quot;focusAlleleCount&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">],</span>
            <span class="s2">&quot;locusAlleleCount&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AN&quot;</span><span class="p">],</span>
            <span class="s2">&quot;alleleFrequency&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>
            <span class="p">),</span>
            <span class="s2">&quot;cohort&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="n">cohort_id</span><span class="p">,</span> <span class="s2">&quot;characteristics&quot;</span><span class="p">:</span> <span class="n">characteristics</span><span class="p">},</span>
            <span class="s2">&quot;ancillaryResults&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;homozygotes&quot;</span><span class="p">:</span> <span class="n">group_freq</span><span class="p">[</span><span class="s2">&quot;homozygote_count&quot;</span><span class="p">]},</span>
        <span class="p">}</span>

        <span class="c1"># Add hemizygote allele count if variant is non-autosomal/non-PAR.</span>
        <span class="c1"># Only XY groups can be hemizygous. Other group AC is mixed homo/hetero.</span>
        <span class="c1"># If not a by_sex group, include the XY hemizygote count for XY subgroup.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">group_sex</span> <span class="o">==</span> <span class="s2">&quot;XY&quot;</span><span class="p">:</span>
                <span class="n">freq_record</span><span class="p">[</span><span class="s2">&quot;ancillaryResults&quot;</span><span class="p">][</span><span class="s2">&quot;hemizygotes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_freq</span><span class="o">.</span><span class="n">AC</span>
            <span class="k">elif</span> <span class="n">group_sex</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Group is not by_sex, but still need to report hemizygotes.</span>
                <span class="n">hemi_group_freq</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span>
                    <span class="n">freq_index_dict</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">group_id</span><span class="si">}</span><span class="s2">_XY_adj&quot;</span><span class="p">]</span>
                <span class="p">]</span>
                <span class="n">freq_record</span><span class="p">[</span><span class="s2">&quot;ancillaryResults&quot;</span><span class="p">][</span><span class="s2">&quot;hemizygotes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hemi_group_freq</span><span class="o">.</span><span class="n">AC</span>

        <span class="k">return</span> <span class="n">freq_record</span>

    <span class="c1"># Create a list to then add the dictionaries for frequency reports for</span>
    <span class="c1"># different genetic ancestry groups to.</span>
    <span class="n">list_of_group_info_dicts</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># Iterate through provided groups and generate dictionaries.</span>
    <span class="k">if</span> <span class="n">gen_anc_groups</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">gen_anc_groups</span><span class="p">:</span>
            <span class="n">group_result</span> <span class="o">=</span> <span class="n">_create_group_dicts</span><span class="p">(</span>
                <span class="n">group_id</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                <span class="n">group_label</span><span class="o">=</span><span class="n">gen_anc_groups_dict</span><span class="p">[</span><span class="n">group</span><span class="p">],</span>
            <span class="p">)</span>

            <span class="c1"># If specified, stratify group information by sex.</span>
            <span class="k">if</span> <span class="n">by_sex</span><span class="p">:</span>
                <span class="n">sex_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">sex</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;XX&quot;</span><span class="p">,</span> <span class="s2">&quot;XY&quot;</span><span class="p">]:</span>
                    <span class="n">sex_result</span> <span class="o">=</span> <span class="n">_create_group_dicts</span><span class="p">(</span>
                        <span class="n">group_id</span><span class="o">=</span><span class="n">group</span><span class="p">,</span>
                        <span class="n">group_label</span><span class="o">=</span><span class="n">gen_anc_groups_dict</span><span class="p">[</span><span class="n">group</span><span class="p">],</span>
                        <span class="n">group_sex</span><span class="o">=</span><span class="n">sex</span><span class="p">,</span>
                    <span class="p">)</span>
                    <span class="n">sex_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sex_result</span><span class="p">)</span>

                <span class="n">group_result</span><span class="p">[</span><span class="s2">&quot;subcohortFrequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sex_list</span>

            <span class="n">list_of_group_info_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_result</span><span class="p">)</span>

    <span class="c1"># Add overall frequency, via label &#39;adj&#39; which is currently stored at</span>
    <span class="c1"># position #1 (index 0).</span>
    <span class="n">overall_freq</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Create final dictionary to be returned.</span>
    <span class="n">final_freq_dict</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_name</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;CohortAlleleFrequency&quot;</span><span class="p">,</span>
        <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;Overall Cohort Allele Frequency for </span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="s2">&quot;derivedFrom&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_name</span><span class="si">}{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;DataSet&quot;</span><span class="p">,</span>
            <span class="s2">&quot;label&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_name</span><span class="si">}</span><span class="s2"> v</span><span class="si">{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="s2">&quot;version&quot;</span><span class="p">:</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">label_version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="s2">&quot;focusAllele&quot;</span><span class="p">:</span> <span class="p">(</span>
            <span class="s2">&quot;&quot;</span>
        <span class="p">),</span>  <span class="c1"># Information can be populated with the result of add_gks_vrs()</span>
        <span class="s2">&quot;focusAlleleCount&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AC&quot;</span><span class="p">],</span>
        <span class="s2">&quot;locusAlleleCount&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AN&quot;</span><span class="p">],</span>
        <span class="s2">&quot;alleleFrequency&quot;</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="k">if</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;AF&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="p">),</span>
        <span class="s2">&quot;cohort&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;id&quot;</span><span class="p">:</span> <span class="s2">&quot;ALL&quot;</span><span class="p">},</span>
    <span class="p">}</span>

    <span class="c1"># Create ancillaryResults for additional frequency and grpMaxFAF95 information.</span>
    <span class="n">ancillaryResults</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;homozygotes&quot;</span><span class="p">:</span> <span class="n">overall_freq</span><span class="p">[</span><span class="s2">&quot;homozygote_count&quot;</span><span class="p">],</span>
    <span class="p">}</span>

    <span class="c1"># Add hemizygote count if not autosomal or PAR.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">:</span>
        <span class="n">hemizygote_count</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">freq</span><span class="p">[</span><span class="n">freq_index_dict</span><span class="p">[</span><span class="s2">&quot;XY_adj&quot;</span><span class="p">]]</span><span class="o">.</span><span class="n">AC</span>
        <span class="n">ancillaryResults</span><span class="p">[</span><span class="s2">&quot;hemizygotes&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hemizygote_count</span>

    <span class="c1"># Add group max FAF if it exists</span>
    <span class="k">if</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">grpMaxFAF95</span><span class="o">.</span><span class="n">grpmax_gen_anc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ancillaryResults</span><span class="p">[</span><span class="s2">&quot;grpMaxFAF95&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">grpMaxFAF95</span><span class="o">.</span><span class="n">grpmax_gen_anc</span><span class="p">,</span>
            <span class="s2">&quot;confidenceInterval&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>
            <span class="s2">&quot;groupId&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">input_struct</span><span class="o">.</span><span class="n">grpMaxFAF95</span><span class="o">.</span><span class="n">grpmax_gen_anc</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>

    <span class="c1"># Add joint group max FAF if it exists.</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="s2">&quot;jointGrpMaxFAF95&quot;</span> <span class="ow">in</span> <span class="n">input_struct</span>
        <span class="ow">and</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">jointGrpMaxFAF95</span><span class="o">.</span><span class="n">grpmax_gen_anc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
    <span class="p">):</span>
        <span class="n">ancillaryResults</span><span class="p">[</span><span class="s2">&quot;jointGrpMaxFAF95&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;frequency&quot;</span><span class="p">:</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">jointGrpMaxFAF95</span><span class="o">.</span><span class="n">grpmax_gen_anc</span><span class="p">,</span>
            <span class="s2">&quot;confidenceInterval&quot;</span><span class="p">:</span> <span class="mf">0.95</span><span class="p">,</span>
            <span class="s2">&quot;groupId&quot;</span><span class="p">:</span> <span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">input_struct</span><span class="o">.</span><span class="n">jointGrpMaxFAF95</span><span class="o">.</span><span class="n">grpmax_gen_anc</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">),</span>
        <span class="p">}</span>

    <span class="n">final_freq_dict</span><span class="p">[</span><span class="s2">&quot;ancillaryResults&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ancillaryResults</span>

    <span class="c1"># Check allele balance for heterozygotes values.</span>
    <span class="c1"># Flagged allele balance values are those in bins &gt; 0.90.</span>
    <span class="c1"># Each bin is 0.05, so flagged values are in the last 2 bins.</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">input_struct</span><span class="o">.</span><span class="n">ab_hist_alt</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">20</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">gnomad_id</span><span class="si">}</span><span class="s2"> ab_hist_alt.bin_freq had &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">input_struct</span><span class="o">.</span><span class="n">ab_hist_alt</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">)</span><span class="si">}</span><span class="s2"> items, expected 20&quot;</span>
        <span class="p">)</span>
    <span class="c1"># The bin_freq should be in order but we can verify the order from bin_edges.</span>
    <span class="n">ab_bin_freq</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
        <span class="nb">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="nb">sorted</span><span class="p">(</span>
                <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">input_struct</span><span class="o">.</span><span class="n">ab_hist_alt</span><span class="o">.</span><span class="n">bin_edges</span><span class="p">,</span>
                    <span class="n">input_struct</span><span class="o">.</span><span class="n">ab_hist_alt</span><span class="o">.</span><span class="n">bin_freq</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="n">qualityMeasures</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;qcFilters&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="n">input_struct</span><span class="o">.</span><span class="n">filters</span><span class="p">),</span>
        <span class="s2">&quot;lowComplexityRegion&quot;</span><span class="p">:</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">lcr</span><span class="p">,</span>
        <span class="s2">&quot;heterozygousSkewedAlleleCount&quot;</span><span class="p">:</span> <span class="nb">sum</span><span class="p">(</span><span class="n">ab_bin_freq</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">:]),</span>
    <span class="p">}</span>

    <span class="c1"># Add coverage depth statistics if the input was annotated</span>
    <span class="c1"># with coverage information.</span>
    <span class="k">if</span> <span class="s2">&quot;mean_depth&quot;</span> <span class="ow">in</span> <span class="n">input_struct</span><span class="p">:</span>
        <span class="n">qualityMeasures</span><span class="p">[</span><span class="s2">&quot;meanDepth&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">mean_depth</span>

    <span class="k">if</span> <span class="s2">&quot;fraction_cov_over_20&quot;</span> <span class="ow">in</span> <span class="n">input_struct</span><span class="p">:</span>
        <span class="n">qualityMeasures</span><span class="p">[</span><span class="s2">&quot;fractionCoverage20x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">fraction_cov_over_20</span>

    <span class="c1"># Add monoallelic flag (all samples homozygous for alternate allele)</span>
    <span class="n">qualityMeasures</span><span class="p">[</span><span class="s2">&quot;monoallelic&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">input_struct</span><span class="o">.</span><span class="n">monoallelic</span>

    <span class="n">final_freq_dict</span><span class="p">[</span><span class="s2">&quot;qualityMeasures&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">qualityMeasures</span>

    <span class="c1"># If gen_anc_groups were passed, add the gen_anc group dictionary to the</span>
    <span class="c1"># final frequency dictionary to be returned.</span>
    <span class="k">if</span> <span class="n">gen_anc_groups</span><span class="p">:</span>
        <span class="n">final_freq_dict</span><span class="p">[</span><span class="s2">&quot;subcohortFrequency&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">list_of_group_info_dicts</span>

    <span class="k">return</span> <span class="n">final_freq_dict</span></div>


<div class="viewcode-block" id="get_copy_state_by_sex"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.get_copy_state_by_sex">[docs]</a><span class="k">def</span> <span class="nf">get_copy_state_by_sex</span><span class="p">(</span>
    <span class="n">locus_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">LocusExpression</span><span class="p">,</span>
    <span class="n">is_xx_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span>
    <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span>
<span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the copy state of a variant by its locus and the sex karotype of a sample.</span>

<span class="sd">    This function assumes that the sample contains only XX and XY karyotypes. It does</span>
<span class="sd">    not account for ambiguous sex or aneuploidies (e.g., XXY, XYY).</span>

<span class="sd">    :param locus_expr: LocusExpression of the variant.</span>
<span class="sd">    :param is_xx_expr: BooleanExpression indicating whether the sample has an XX sex</span>
<span class="sd">       karyotype.</span>
<span class="sd">    :return: Tuple of BooleanExpressions:</span>
<span class="sd">        - diploid_expr: True if the variant is in autosomes or PAR regions, or in the X non-PAR region for XX individuals.</span>
<span class="sd">        - hemi_x_expr: True if the variant is in the X non-PAR region for XY individuals.</span>
<span class="sd">        - hemi_y_expr: True if the variant is in the Y non-PAR region for XY individuals.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">diploid_expr</span> <span class="o">=</span> <span class="n">locus_expr</span><span class="o">.</span><span class="n">in_autosome_or_par</span><span class="p">()</span> <span class="o">|</span> <span class="p">(</span>
        <span class="n">locus_expr</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">is_xx_expr</span>
    <span class="p">)</span>
    <span class="n">hemi_x_expr</span> <span class="o">=</span> <span class="n">locus_expr</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">is_xx_expr</span>
    <span class="n">hemi_y_expr</span> <span class="o">=</span> <span class="n">locus_expr</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">()</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">is_xx_expr</span>
    <span class="k">return</span> <span class="n">diploid_expr</span><span class="p">,</span> <span class="n">hemi_x_expr</span><span class="p">,</span> <span class="n">hemi_y_expr</span></div>


<span class="k">def</span> <span class="nf">_get_missingness_expr</span><span class="p">(</span>
    <span class="n">expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recursively build missingness aggregation expressions for an annotation.</span>

<span class="sd">    This helper function traverses nested struct types and returns a dictionary</span>
<span class="sd">    mapping field paths to their missingness fraction expressions.</span>

<span class="sd">    :param expr: Hail expression to check for missingness.</span>
<span class="sd">    :param prefix: Prefix to prepend to field names (used for nested structs).</span>
<span class="sd">    :return: Dictionary mapping field paths to missingness fraction expressions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">nested_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="n">key</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">_get_missingness_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">nested_prefix</span><span class="p">))</span>
    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">SetExpression</span><span class="p">)):</span>
        <span class="c1"># Count array/set as missing if it is NA, empty, or only has missing elements.</span>
        <span class="n">result</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">fraction</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">expr</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="kc">True</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">result</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">fraction</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">expr</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">result</span>


<div class="viewcode-block" id="check_annotation_missingness"><a class="viewcode-back" href="../../../api_reference/utils/annotations.html#gnomad.utils.annotations.check_annotation_missingness">[docs]</a><span class="k">def</span> <span class="nf">check_annotation_missingness</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
    <span class="n">annotation</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">high_missingness_threshold</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
    <span class="n">remove_missing_fields</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">include_col_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Check missingness of annotations in a Table or MatrixTable, recursively handling structs.</span>

<span class="sd">    This function computes the fraction of missing values for each field within the</span>
<span class="sd">    specified annotation (or all annotations if none specified). For nested structs</span>
<span class="sd">    (e.g., VEP annotations), it recursively checks all nested fields. Arrays and sets</span>
<span class="sd">    are considered missing if they are NA, empty, or contain only missing elements. If option is set, completely missing fields will be removed.</span>

<span class="sd">    The function returns a dictionary containing:</span>
<span class="sd">        - &#39;missingness&#39;: A dictionary mapping field paths to their missingness fractions.</span>
<span class="sd">        - &#39;high_missingness_fields&#39;: A list of fields exceeding the high_missingness_threshold.</span>
<span class="sd">        - &#39;completely_missing_fields&#39;: A list of fields that are 100% missing.</span>

<span class="sd">    Example usage::</span>

<span class="sd">        # Check all row annotations</span>
<span class="sd">        ht, results = check_annotation_missingness(ht)</span>

<span class="sd">        # Check VEP annotation missingness</span>
<span class="sd">        ht, results = check_annotation_missingness(ht, &quot;vep&quot;, high_missingness_threshold=0.08)</span>

<span class="sd">        # Check info struct missingness and remove completely missing fields</span>
<span class="sd">        ht, results = check_annotation_missingness(</span>
<span class="sd">            ht, &quot;info&quot;, remove_missing_fields=True</span>
<span class="sd">        )</span>

<span class="sd">        # Check all annotations in a MatrixTable including column annotations</span>
<span class="sd">        mt, results = check_annotation_missingness(mt, include_col_annotations=True)</span>

<span class="sd">    :param t: Input Table or MatrixTable.</span>
<span class="sd">    :param annotation: Name of the annotation to check for missingness. If None, checks</span>
<span class="sd">        all row annotations (and column annotations if include_col_annotations is True</span>
<span class="sd">        for MatrixTables).</span>
<span class="sd">    :param high_missingness_threshold: Threshold above which a field is flagged as having</span>
<span class="sd">        high missingness. Default is 0.05 (5% missing).</span>
<span class="sd">    :param remove_missing_fields: If True, remove fields that are 100% missing from</span>
<span class="sd">        the annotation. Default is False.</span>
<span class="sd">    :param include_col_annotations: If True and input is a MatrixTable, also check</span>
<span class="sd">        column annotations when annotation is None. Default is False.</span>
<span class="sd">    :return: Tuple of:</span>
<span class="sd">        - The (potentially modified) Table or MatrixTable.</span>
<span class="sd">        - Dictionary containing missingness statistics and flagged fields.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_mt</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_filter_missing_fields</span><span class="p">(</span>
        <span class="n">expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">missing_fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Recursively remove fields whose fully-qualified paths are listed in missing_fields.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">missing_fields</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">expr</span>

        <span class="n">fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">expr</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">path</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="n">key</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">_filter_missing_fields</span><span class="p">(</span><span class="n">expr</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">path</span><span class="p">,</span> <span class="n">missing_fields</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">fields</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

        <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">fields</span><span class="p">)</span> <span class="k">if</span> <span class="n">fields</span> <span class="k">else</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_check_single_annotation</span><span class="p">(</span>
        <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
        <span class="n">annotation</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">annotation_type</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check missingness for a single annotation.&quot;&quot;&quot;</span>
        <span class="n">expr</span> <span class="o">=</span> <span class="n">t</span><span class="p">[</span><span class="n">annotation</span><span class="p">]</span>

        <span class="c1"># Build missingness expressions recursively.</span>
        <span class="n">missingness_exprs</span> <span class="o">=</span> <span class="n">_get_missingness_expr</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">annotation</span><span class="p">)</span>

        <span class="c1"># Aggregate missingness fractions.</span>
        <span class="k">if</span> <span class="n">is_mt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">annotation_type</span> <span class="o">==</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span>
                <span class="n">missingness_results</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">aggregate_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">missingness_exprs</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">missingness_results</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">aggregate_cols</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">missingness_exprs</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">missingness_results</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">missingness_exprs</span><span class="p">))</span>

        <span class="c1"># Convert results to a regular dictionary.</span>
        <span class="n">missingness_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">missingness_results</span><span class="p">)</span>

        <span class="c1"># Identify low coverage and completely missing fields.</span>
        <span class="n">high_missingness_fields</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">completely_missing_fields</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">field_path</span><span class="p">,</span> <span class="n">fraction_missing</span> <span class="ow">in</span> <span class="n">missingness_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">fraction_missing</span> <span class="o">==</span> <span class="mf">1.0</span><span class="p">:</span>
                <span class="n">completely_missing_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_path</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Field &#39;</span><span class="si">%s</span><span class="s2">&#39; is 100</span><span class="si">%%</span><span class="s2"> missing.&quot;</span><span class="p">,</span>
                    <span class="n">field_path</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="n">fraction_missing</span> <span class="o">&gt;=</span> <span class="n">high_missingness_threshold</span><span class="p">:</span>
                <span class="n">high_missingness_fields</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">field_path</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Field &#39;</span><span class="si">%s</span><span class="s2">&#39; has high missingness: </span><span class="si">%.2f%%</span><span class="s2"> missing (threshold:&quot;</span>
                    <span class="s2">&quot; </span><span class="si">%.2f%%</span><span class="s2">).&quot;</span><span class="p">,</span>
                    <span class="n">field_path</span><span class="p">,</span>
                    <span class="n">fraction_missing</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                    <span class="n">high_missingness_threshold</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                    <span class="s2">&quot;Field &#39;</span><span class="si">%s</span><span class="s2">&#39;: </span><span class="si">%.2f%%</span><span class="s2"> missing.&quot;</span><span class="p">,</span>
                    <span class="n">field_path</span><span class="p">,</span>
                    <span class="n">fraction_missing</span> <span class="o">*</span> <span class="mi">100</span><span class="p">,</span>
                <span class="p">)</span>

        <span class="c1"># Remove completely missing fields if requested.</span>
        <span class="k">if</span> <span class="n">remove_missing_fields</span> <span class="ow">and</span> <span class="n">completely_missing_fields</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Removing </span><span class="si">%d</span><span class="s2"> completely missing field(s): &#39;</span><span class="si">%s</span><span class="s2">&#39;.&quot;</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">completely_missing_fields</span><span class="p">),</span>
                <span class="n">completely_missing_fields</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="n">filtered_annotation</span> <span class="o">=</span> <span class="n">_filter_missing_fields</span><span class="p">(</span>
                <span class="n">expr</span><span class="p">,</span> <span class="n">annotation</span><span class="p">,</span> <span class="n">completely_missing_fields</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">filtered_annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">is_mt</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">annotation_type</span> <span class="o">==</span> <span class="s2">&quot;row&quot;</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">annotation</span><span class="p">:</span> <span class="n">filtered_annotation</span><span class="p">})</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">annotation</span><span class="p">:</span> <span class="n">filtered_annotation</span><span class="p">})</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">annotation</span><span class="p">:</span> <span class="n">filtered_annotation</span><span class="p">})</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># The entire annotation is missing; drop it.</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Entire annotation &#39;</span><span class="si">%s</span><span class="s2">&#39; is 100</span><span class="si">%%</span><span class="s2"> missing. Dropping annotation.&quot;</span><span class="p">,</span>
                    <span class="n">annotation</span><span class="p">,</span>
                <span class="p">)</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="p">{</span>
            <span class="s2">&quot;missingness&quot;</span><span class="p">:</span> <span class="n">missingness_dict</span><span class="p">,</span>
            <span class="s2">&quot;high_missingness_fields&quot;</span><span class="p">:</span> <span class="n">high_missingness_fields</span><span class="p">,</span>
            <span class="s2">&quot;completely_missing_fields&quot;</span><span class="p">:</span> <span class="n">completely_missing_fields</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># If a specific annotation is provided, check only that annotation.</span>
    <span class="k">if</span> <span class="n">annotation</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Validate annotation exists.</span>
        <span class="k">if</span> <span class="n">is_mt</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span><span class="p">:</span>
                <span class="n">annotation_type</span> <span class="o">=</span> <span class="s2">&quot;row&quot;</span>
            <span class="k">elif</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
                <span class="n">annotation_type</span> <span class="o">=</span> <span class="s2">&quot;col&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Annotation &#39;</span><span class="si">{</span><span class="n">annotation</span><span class="si">}</span><span class="s2">&#39; not found in MatrixTable row or column &quot;</span>
                    <span class="s2">&quot;fields.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">annotation</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Annotation &#39;</span><span class="si">{</span><span class="n">annotation</span><span class="si">}</span><span class="s2">&#39; not found in Table.&quot;</span><span class="p">)</span>
            <span class="n">annotation_type</span> <span class="o">=</span> <span class="s2">&quot;row&quot;</span>

        <span class="k">return</span> <span class="n">_check_single_annotation</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">annotation</span><span class="p">,</span> <span class="n">annotation_type</span><span class="p">)</span>

    <span class="c1"># Check all annotations.</span>
    <span class="n">combined_results</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;missingness&quot;</span><span class="p">:</span> <span class="p">{},</span>
        <span class="s2">&quot;high_missingness_fields&quot;</span><span class="p">:</span> <span class="p">[],</span>
        <span class="s2">&quot;completely_missing_fields&quot;</span><span class="p">:</span> <span class="p">[],</span>
    <span class="p">}</span>

    <span class="c1"># Get row annotations (excluding key fields).</span>
    <span class="k">if</span> <span class="n">is_mt</span><span class="p">:</span>
        <span class="n">row_key_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">row_key</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">row_annotations</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">row_key_fields</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">key_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">key</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">row_annotations</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">row</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">key_fields</span><span class="p">]</span>

    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Checking </span><span class="si">%d</span><span class="s2"> row annotation(s) for missingness.&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_annotations</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">annot</span> <span class="ow">in</span> <span class="n">row_annotations</span><span class="p">:</span>
        <span class="n">t</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">_check_single_annotation</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">annot</span><span class="p">,</span> <span class="s2">&quot;row&quot;</span><span class="p">)</span>
        <span class="n">combined_results</span><span class="p">[</span><span class="s2">&quot;missingness&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">results</span><span class="p">[</span><span class="s2">&quot;missingness&quot;</span><span class="p">])</span>
        <span class="n">combined_results</span><span class="p">[</span><span class="s2">&quot;high_missingness_fields&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;high_missingness_fields&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">combined_results</span><span class="p">[</span><span class="s2">&quot;completely_missing_fields&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="n">results</span><span class="p">[</span><span class="s2">&quot;completely_missing_fields&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Check column annotations for MatrixTables if requested.</span>
    <span class="k">if</span> <span class="n">is_mt</span> <span class="ow">and</span> <span class="n">include_col_annotations</span><span class="p">:</span>
        <span class="n">col_key_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">col_key</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="n">col_annotations</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">t</span><span class="o">.</span><span class="n">col</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">col_key_fields</span><span class="p">]</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Checking </span><span class="si">%d</span><span class="s2"> column annotation(s) for missingness.&quot;</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_annotations</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">annot</span> <span class="ow">in</span> <span class="n">col_annotations</span><span class="p">:</span>
            <span class="n">t</span><span class="p">,</span> <span class="n">results</span> <span class="o">=</span> <span class="n">_check_single_annotation</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">annot</span><span class="p">,</span> <span class="s2">&quot;col&quot;</span><span class="p">)</span>
            <span class="c1"># Prefix col annotations to distinguish from row annotations.</span>
            <span class="n">col_missingness</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;col.</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;missingness&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">combined_results</span><span class="p">[</span><span class="s2">&quot;missingness&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">col_missingness</span><span class="p">)</span>
            <span class="n">combined_results</span><span class="p">[</span><span class="s2">&quot;high_missingness_fields&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;col.</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;high_missingness_fields&quot;</span><span class="p">]]</span>
            <span class="p">)</span>
            <span class="n">combined_results</span><span class="p">[</span><span class="s2">&quot;completely_missing_fields&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;col.</span><span class="si">{</span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">results</span><span class="p">[</span><span class="s2">&quot;completely_missing_fields&quot;</span><span class="p">]]</span>
            <span class="p">)</span>

    <span class="k">return</span> <span class="n">t</span><span class="p">,</span> <span class="n">combined_results</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>