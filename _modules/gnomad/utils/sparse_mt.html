<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.sparse_mt &mdash; gnomad master documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/broadinstitute/gnomad_methods/releases">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gnomad.utils.sparse_mt</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.sparse_mt</h1><div class="highlight"><pre>
<span></span><span class="c1"># noqa: D100</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Set</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>

<span class="kn">from</span> <span class="nn">gnomad.sample_qc.sex</span> <span class="kn">import</span> <span class="n">adjusted_sex_ploidy_expr</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.annotations</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">agg_by_strata</span><span class="p">,</span>
    <span class="n">annotate_adj</span><span class="p">,</span>
    <span class="n">fs_from_sb</span><span class="p">,</span>
    <span class="n">generate_freq_group_membership_array</span><span class="p">,</span>
    <span class="n">get_adj_expr</span><span class="p">,</span>
    <span class="n">get_lowqual_expr</span><span class="p">,</span>
    <span class="n">pab_max_expr</span><span class="p">,</span>
    <span class="n">sor_from_sb</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.intervals</span> <span class="kn">import</span> <span class="n">interval_length</span><span class="p">,</span> <span class="n">union_intervals</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.reference_genome</span> <span class="kn">import</span> <span class="n">get_reference_genome</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">INFO_AGG_FIELDS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;sum_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;QUALapprox&quot;</span><span class="p">],</span>
    <span class="s2">&quot;int32_sum_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;VarDP&quot;</span><span class="p">],</span>
    <span class="s2">&quot;median_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;ReadPosRankSum&quot;</span><span class="p">,</span> <span class="s2">&quot;MQRankSum&quot;</span><span class="p">],</span>
    <span class="s2">&quot;array_sum_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">,</span> <span class="s2">&quot;RAW_MQandDP&quot;</span><span class="p">],</span>
<span class="p">}</span>

<span class="n">AS_INFO_AGG_FIELDS</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s2">&quot;sum_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;AS_QUALapprox&quot;</span><span class="p">,</span> <span class="s2">&quot;AS_RAW_MQ&quot;</span><span class="p">],</span>
    <span class="s2">&quot;int32_sum_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;AS_VarDP&quot;</span><span class="p">],</span>
    <span class="s2">&quot;median_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;AS_RAW_ReadPosRankSum&quot;</span><span class="p">,</span> <span class="s2">&quot;AS_RAW_MQRankSum&quot;</span><span class="p">],</span>
    <span class="s2">&quot;array_sum_agg_fields&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">],</span>
<span class="p">}</span>


<div class="viewcode-block" id="compute_last_ref_block_end"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_last_ref_block_end">[docs]</a><span class="k">def</span> <span class="nf">compute_last_ref_block_end</span><span class="p">(</span><span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the genomic position of the most upstream reference block overlapping each row on a sparse MT.</span>

<span class="sd">    Note that since reference blocks do not extend beyond contig boundaries, only the position is kept.</span>

<span class="sd">    This function returns a Table with that annotation.  (`last_END_position`).</span>

<span class="sd">    :param mt: Input MatrixTable</span>
<span class="sd">    :return: Output Table with `last_END_position` annotation</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">)</span>

    <span class="c1"># Localize entries, so that they can be viewed as an array and scanned</span>
    <span class="c1"># over using hl.scan.array_agg</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">_localize_entries</span><span class="p">(</span><span class="s2">&quot;__entries&quot;</span><span class="p">,</span> <span class="s2">&quot;__cols&quot;</span><span class="p">)</span>

    <span class="c1"># Compute the position by using hl.scan._prev_nonnull.</span>
    <span class="c1"># This was inspired by hl.experimental.densify</span>
    <span class="c1"># _prev_non_null is an aggregator that keeps the previous record in memory</span>
    <span class="c1"># and updates it with the given value at the row if it&#39;s not null (missing)</span>
    <span class="c1"># The following code computes the following annotation for each row:</span>
    <span class="c1"># 1. Keep a scan of the entries using _prev_nonnull, keeping the start (ht.locus) and end (entry.END) of each ref block  (1.1)</span>
    <span class="c1"># 2. For the current row locus, record the start of the block that starts the furthest away,</span>
    <span class="c1"># that is the minimum position in the current scan for any block that</span>
    <span class="c1"># overlaps the current locus (2.1)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="n">last_END_position</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span>  <span class="c1"># 2. For the current row locus, record the start of the block that starts the furthest away</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">entry</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">scan</span><span class="o">.</span><span class="n">_prev_nonnull</span><span class="p">(</span>  <span class="c1"># 1. Keep a scan of the entries using _prev_nonnull</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span>
                                <span class="n">entry</span><span class="o">.</span><span class="n">END</span>
                            <span class="p">),</span>  <span class="c1"># Update the scan whenever a new ref block is encountered</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">tuple</span><span class="p">(</span>
                                <span class="p">[</span>  <span class="c1"># 1.1 keep the start (ht.locus) and end (entry.END) of each ref block</span>
                                    <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span>
                                    <span class="n">entry</span><span class="o">.</span><span class="n">END</span><span class="p">,</span>
                                <span class="p">]</span>
                            <span class="p">),</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                    <span class="n">ht</span><span class="o">.</span><span class="n">__entries</span><span class="p">,</span>
                <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>  <span class="c1"># 2.1 get the start position of blocks that overlap the current locus</span>
                        <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">contig</span> <span class="o">==</span> <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span><span class="p">),</span>
                        <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">),</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">()</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">)</span></div>


<div class="viewcode-block" id="densify_sites"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.densify_sites">[docs]</a><span class="k">def</span> <span class="nf">densify_sites</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sites_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">last_END_positions_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">semi_join_rows</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a dense version of the input sparse MT at the sites in `sites_ht` reading the minimal amount of data required.</span>

<span class="sd">    Note that only rows that appear both in `mt` and `sites_ht` are returned.</span>

<span class="sd">    :param mt: Input sparse MT</span>
<span class="sd">    :param sites_ht: Desired sites to densify</span>
<span class="sd">    :param last_END_positions_ht: Table storing positions of the furthest ref block (END tag)</span>
<span class="sd">    :param semi_join_rows: Whether to filter the MT rows based on semi-join (default, better if sites_ht is large) or based on filter_intervals (better if sites_ht only contains a few sites)</span>
<span class="sd">    :return: Dense MT filtered to the sites in `sites_ht`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing intervals to densify from sites Table.&quot;</span><span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">interval</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus_interval</span><span class="p">(</span>
            <span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span>
            <span class="n">last_END_positions_ht</span><span class="p">[</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">last_END_position</span><span class="p">,</span>
            <span class="n">end</span><span class="o">=</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
            <span class="n">includes_end</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">reference_genome</span><span class="o">=</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">reference_genome</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="n">sites_ht</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">interval</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">semi_join_rows</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">)[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Collecting intervals to densify.&quot;</span><span class="p">)</span>
        <span class="n">intervals</span> <span class="o">=</span> <span class="n">sites_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>

        <span class="nb">print</span><span class="p">(</span>
            <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> intervals, totalling </span><span class="si">{1}</span><span class="s2"> bp in the dense Matrix.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">intervals</span><span class="p">),</span>
                <span class="nb">sum</span><span class="p">(</span>
                    <span class="p">[</span>
                        <span class="n">interval_length</span><span class="p">(</span><span class="n">interval</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">interval</span> <span class="ow">in</span> <span class="n">union_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">)</span>
                    <span class="p">]</span>
                <span class="p">),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">intervals</span><span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">densify</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">sites_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">]))</span></div>


<span class="k">def</span> <span class="nf">_get_info_agg_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;int32_sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;median_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;array_sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
    <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">retain_cdfs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">cdf_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Aggregation</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create Aggregators for both site or AS info expression aggregations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `SB` is specified in array_sum_agg_fields, it will be aggregated as</span>
<span class="sd">          `AS_SB_TABLE`, according to GATK standard nomenclature.</span>
<span class="sd">        - If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for</span>
<span class="sd">          the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation</span>
<span class="sd">          and then dropped according to GATK recommendation.</span>
<span class="sd">        - If the fields to be aggregated (`sum_agg_fields`, `int32_sum_agg_fields`,</span>
<span class="sd">          `median_agg_fields`) are passed as list of str, then they should correspond</span>
<span class="sd">          to entry fields in `mt` or in mt.gvcf_info`.</span>
<span class="sd">        - Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in</span>
<span class="sd">          case of a name clash.</span>

<span class="sd">    :param mt: Input MT</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :param array_sum_agg_fields: Fields to aggregate using element-wise summing over an</span>
<span class="sd">        array.</span>
<span class="sd">    :param prefix: Optional prefix for the fields. Used for adding &#39;AS_&#39; in the AS case.</span>
<span class="sd">    :param treat_fields_as_allele_specific: Treat info fields as allele-specific.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    :param retain_cdfs: If True, retains the cumulative distribution functions (CDFs)</span>
<span class="sd">        as an annotation for `median_agg_fields`. Keeping the CDFs is useful for</span>
<span class="sd">        annotations that require calculating the median across combined datasets at a</span>
<span class="sd">        later stage. Default is False.</span>
<span class="sd">    :param cdf_k: Parameter controlling the accuracy vs. memory usage tradeoff when</span>
<span class="sd">        retaining CDFs. A higher value of `cdf_k` results in a more accurate CDF</span>
<span class="sd">        approximation but increases memory usage and computation time. Default is 200.</span>
<span class="sd">    :return: Dictionary of expression names and their corresponding aggregation</span>
<span class="sd">        Expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_agg_list_to_dict</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]:</span>
        <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="s2">&quot;gvcf_info&quot;</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
            <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="p">:</span> <span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">}</span>

        <span class="n">out_fields</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">f</span><span class="p">:</span> <span class="n">mt</span><span class="p">[</span><span class="n">f</span><span class="p">]</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">})</span>

        <span class="c1"># Check that all fields were found.</span>
        <span class="n">missing_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span> <span class="k">if</span> <span class="n">f</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">out_fields</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">missing_fields</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Could not find the following field(s)in the MT entry schema (or nested&quot;</span>
                <span class="s2">&quot; under mt.gvcf_info: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">missing_fields</span><span class="p">))</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
            <span class="c1"># TODO: Change to use hl.vds.local_to_global when fill_value can accept</span>
            <span class="c1">#  missing (error in v0.2.119).</span>
            <span class="n">out_fields</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">f</span> <span class="o">==</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">:]),</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
                            <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">out_fields</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span>
                        <span class="p">)</span>
                    <span class="p">),</span>
                <span class="p">)</span>
                <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">fields</span>
            <span class="p">}</span>

        <span class="k">return</span> <span class="n">out_fields</span>

    <span class="c1"># Map str to expressions where needed.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">sum_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">int32_sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">int32_sum_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">median_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">median_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">median_agg_fields</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">array_sum_agg_fields</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
        <span class="n">array_sum_agg_fields</span> <span class="o">=</span> <span class="n">_agg_list_to_dict</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">array_sum_agg_fields</span><span class="p">)</span>

    <span class="n">aggs</span> <span class="o">=</span> <span class="p">[</span>
        <span class="p">(</span><span class="n">median_agg_fields</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_quantiles</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)),</span>
        <span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">),</span>
        <span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span>
        <span class="p">(</span><span class="n">array_sum_agg_fields</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">),</span>
    <span class="p">]</span>

    <span class="k">if</span> <span class="n">retain_cdfs</span><span class="p">:</span>
        <span class="c1"># Note: hl.agg.approx_cdf is a non-deterministic method and cannot be seeded.</span>
        <span class="c1"># Results may vary with each rerun.</span>
        <span class="n">cdf_median_agg_fields</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Store values for each median agg fields in a new dictionary with &quot;_cdf&quot;</span>
        <span class="c1"># appended to the annotation name.</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">median_agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">cdf_median_agg_fields</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">_cdf&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
        <span class="c1"># Append the cdf annotations to the aggs list. Set &#39;_raw&#39; to True to return</span>
        <span class="c1"># a representation of the internal state of the CDF, which allows for mergining</span>
        <span class="c1"># with other CDFs downstream.</span>
        <span class="n">aggs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="p">(</span><span class="n">cdf_median_agg_fields</span><span class="p">,</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_cdf</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">,</span> <span class="n">_raw</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="c1"># Create aggregators.</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">agg_fields</span><span class="p">,</span> <span class="n">agg_func</span> <span class="ow">in</span> <span class="n">aggs</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">agg_fields</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
                <span class="c1"># If annotation is of the form &#39;AS_RAW_*_RankSum&#39; it has a histogram</span>
                <span class="c1"># representation where keys give the per-variant rank sum value to one</span>
                <span class="c1"># decimal place followed by a comma and the corresponding count for</span>
                <span class="c1"># that value, so we want to sum the rank sum value (first element).</span>
                <span class="c1"># Rename annotation in the form &#39;AS_RAW_*_RankSum&#39; to &#39;AS_*_RankSum&#39;.</span>
                <span class="k">if</span> <span class="n">k</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AS_RAW_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
                    <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;RankSum&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">k</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;RankSum_cdf&quot;</span><span class="p">)</span>
                <span class="p">):</span>
                    <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_RAW&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])),</span> <span class="n">expr</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">expr</span>
                    <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
        <span class="n">prefix</span> <span class="o">=</span> <span class="s2">&quot;AS_&quot;</span>

    <span class="c1"># Handle annotations combinations and casting for specific annotations</span>
    <span class="c1"># If RAW_MQandDP is in agg_expr or if both MQ_DP and RAW_MQ are, compute MQ instead</span>
    <span class="n">mq_tuple</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQandDP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing </span><span class="si">%s</span><span class="s2">MQ as sqrt(</span><span class="si">%s</span><span class="s2">RAW_MQandDP[0]/</span><span class="si">%s</span><span class="s2">RAW_MQandDP[1]). &quot;</span>
            <span class="s2">&quot;Note that </span><span class="si">%s</span><span class="s2">MQ will be set to 0 if </span><span class="si">%s</span><span class="s2">RAW_MQandDP[1] == 0.&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQandDP&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="s2">&quot;AS_RAW_MQ&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing AS_MQ as sqrt(AS_RAW_MQ[i]/AD[i+1]). &quot;</span>
            <span class="s2">&quot;Note that AS_MQ will be set to 0 if AS_RAW_MQ == 0.&quot;</span>
        <span class="p">)</span>
        <span class="n">ad_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">local_to_global</span><span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">),</span> <span class="n">fill_value</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">number</span><span class="o">=</span><span class="s2">&quot;R&quot;</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;AS_RAW_MQ&quot;</span><span class="p">),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">(</span><span class="n">ad_expr</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
    <span class="k">elif</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQ&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ_DP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing </span><span class="si">%s</span><span class="s2">MQ as sqrt(</span><span class="si">%s</span><span class="s2">RAW_MQ/</span><span class="si">%s</span><span class="s2">MQ_DP). &quot;</span>
            <span class="s2">&quot;Note that MQ will be set to 0 if </span><span class="si">%s</span><span class="s2">RAW_MQ == 0.&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">mq_tuple</span> <span class="o">=</span> <span class="p">(</span><span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">RAW_MQ&quot;</span><span class="p">),</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ_DP&quot;</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">mq_tuple</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
            <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">mq_tuple</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">MQ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                <span class="n">mq_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mq_tuple</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">mq_tuple</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="mi">0</span>
            <span class="p">)</span>

    <span class="c1"># If both VarDP and QUALapprox are present, also compute QD.</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">VarDP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span> <span class="ow">and</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QUALapprox&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Computing </span><span class="si">%s</span><span class="s2">QD as </span><span class="si">%s</span><span class="s2">QUALapprox/</span><span class="si">%s</span><span class="s2">VarDP. &quot;</span>
            <span class="s2">&quot;Note that </span><span class="si">%s</span><span class="s2">QD will be set to 0 if </span><span class="si">%s</span><span class="s2">VarDP == 0.&quot;</span><span class="p">,</span>
            <span class="o">*</span><span class="p">[</span><span class="n">prefix</span><span class="p">]</span> <span class="o">*</span> <span class="mi">5</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">var_dp</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">VarDP&quot;</span><span class="p">]</span>
        <span class="n">qual_approx</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QUALapprox&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
            <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">zip</span><span class="p">(</span><span class="n">qual_approx</span><span class="p">,</span> <span class="n">var_dp</span><span class="p">),</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">QD&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">var_dp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">qual_approx</span> <span class="o">/</span> <span class="n">var_dp</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># SB needs to be cast to int32 for FS down the line.</span>
    <span class="k">if</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">SB&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">SB&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">SB&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

    <span class="c1"># SB needs to be cast to int32 for FS down the line.</span>
    <span class="k">if</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">y</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">y</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">agg_expr</span>


<div class="viewcode-block" id="get_as_info_expr"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_as_info_expr">[docs]</a><span class="k">def</span> <span class="nf">get_as_info_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;int32_sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;median_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;array_sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">alt_alleles_range_array_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;alt_alleles_range_array&quot;</span><span class="p">,</span>
    <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">retain_cdfs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">cdf_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an allele-specific annotation Struct containing typical VCF INFO fields from GVCF INFO fields stored in the MT entries.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `SB` is specified in array_sum_agg_fields, it will be aggregated as</span>
<span class="sd">          `AS_SB_TABLE`, according to GATK standard nomenclature.</span>
<span class="sd">        - If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for</span>
<span class="sd">          the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation</span>
<span class="sd">          and then dropped according to GATK recommendation.</span>
<span class="sd">        - If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`,</span>
<span class="sd">          `median_agg_fields`) are passed as list of str, then they should correspond</span>
<span class="sd">          to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">        - Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in</span>
<span class="sd">          case of a name clash.</span>
<span class="sd">        - If `treat_fields_as_allele_specific` is False, it&#39;s expected that there is a</span>
<span class="sd">          single value for each entry field to be aggregated. Then when performing the</span>
<span class="sd">          aggregation per global alternate allele, that value is included in the</span>
<span class="sd">          aggregation if the global allele is present in the entry&#39;s list of local</span>
<span class="sd">          alleles. If `treat_fields_as_allele_specific` is True, it&#39;s expected that</span>
<span class="sd">          each entry field to be aggregated has one value per local allele, and each</span>
<span class="sd">          of those is mapped to a global allele for aggregation.</span>

<span class="sd">    :param mt: Input Matrix Table</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :param array_sum_agg_fields: Fields to aggregate using array sum.</span>
<span class="sd">    :param alt_alleles_range_array_field: Annotation containing an array of the range</span>
<span class="sd">        of alternate alleles e.g., `hl.range(1, hl.len(mt.alleles))`</span>
<span class="sd">    :param treat_fields_as_allele_specific: Treat info fields as allele-specific.</span>
<span class="sd">        Defaults to False.</span>
<span class="sd">    :param retain_cdfs: If True, retains the cumulative distribution functions (CDFs)</span>
<span class="sd">        as an annotation for `median_agg_fields`. Keeping the CDFs is useful for</span>
<span class="sd">        annotations that require calculating the median across combined datasets at a</span>
<span class="sd">        later stage. Default is False.</span>
<span class="sd">    :param cdf_k: Parameter controlling the accuracy vs. memory usage tradeoff when</span>
<span class="sd">        retaining CDFs. A higher value of `cdf_k` results in a more accurate CDF</span>
<span class="sd">        approximation but increases memory usage and computation time. Default is 200.</span>
<span class="sd">    :return: Expression containing the AS info fields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;`DP` was included in allele-specific aggregation, however `DP` is&quot;</span>
            <span class="s2">&quot; typically not aggregated by allele; `VarDP` is.Note that the resulting&quot;</span>
            <span class="s2">&quot; `AS_DP` field will NOT include reference genotypes.&quot;</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">=</span><span class="n">mt</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="o">=</span><span class="n">sum_agg_fields</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="o">=</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="o">=</span><span class="n">median_agg_fields</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="o">=</span><span class="n">array_sum_agg_fields</span><span class="p">,</span>
        <span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;&quot;</span> <span class="k">if</span> <span class="n">treat_fields_as_allele_specific</span> <span class="k">else</span> <span class="s2">&quot;AS_&quot;</span><span class="p">,</span>
        <span class="n">treat_fields_as_allele_specific</span><span class="o">=</span><span class="n">treat_fields_as_allele_specific</span><span class="p">,</span>
        <span class="n">retain_cdfs</span><span class="o">=</span><span class="n">retain_cdfs</span><span class="p">,</span>
        <span class="n">cdf_k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">alt_alleles_range_array_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">row</span> <span class="ow">or</span> <span class="n">mt</span><span class="p">[</span>
        <span class="n">alt_alleles_range_array_field</span>
    <span class="p">]</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">hl</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="s2">&quot;array&lt;int32&gt;&quot;</span><span class="p">):</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&#39;get_as_info_expr&#39; expected a row field &#39;</span><span class="si">{</span><span class="n">alt_alleles_range_array_field</span><span class="si">}</span><span class="s2">&#39;&quot;</span>
            <span class="s2">&quot; of type array&lt;int32&gt;&quot;</span>
        <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">treat_fields_as_allele_specific</span><span class="p">:</span>
        <span class="c1"># Modify aggregations to aggregate per allele</span>
        <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ai</span><span class="p">),</span> <span class="n">expr</span><span class="p">),</span>
                <span class="n">mt</span><span class="p">[</span><span class="n">alt_alleles_range_array_field</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">expr</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>

    <span class="c1"># Run aggregations</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">agg_expr</span><span class="p">)</span>

    <span class="c1"># Add FS and SOR if SB is present.</span>
    <span class="k">if</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span> <span class="ow">in</span> <span class="n">info</span> <span class="ow">or</span> <span class="s2">&quot;AS_SB&quot;</span> <span class="ow">in</span> <span class="n">info</span><span class="p">:</span>
        <span class="n">drop</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># Rename AS_SB to AS_SB_TABLE if present and add SB Ax2 aggregation logic.</span>
        <span class="k">if</span> <span class="s2">&quot;AS_SB&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
            <span class="k">if</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                    <span class="s2">&quot;Both `AS_SB` and `AS_SB_TABLE` were specified for aggregation.&quot;</span>
                    <span class="s2">&quot; `AS_SB` will be used for aggregation.&quot;</span>
                <span class="p">)</span>
            <span class="n">as_sb_table</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span>
                    <span class="n">info</span><span class="o">.</span><span class="n">AS_SB</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">.</span><span class="n">fold</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="n">i</span><span class="p">[:</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span><span class="p">[:</span><span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                    <span class="p">)</span>  <span class="c1"># ref</span>
                <span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
                <span class="n">info</span><span class="o">.</span><span class="n">AS_SB</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">2</span><span class="p">:])</span>  <span class="c1"># each alt</span>
            <span class="p">)</span>
            <span class="n">drop</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;AS_SB&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">as_sb_table</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">AS_SB_TABLE</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AS_SB_TABLE</span><span class="o">=</span><span class="n">as_sb_table</span><span class="p">,</span>
            <span class="n">AS_FS</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">fs_from_sb</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">),</span>
            <span class="n">AS_SOR</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">sor_from_sb</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">as_sb_table</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="p">),</span>
        <span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="o">*</span><span class="n">drop</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="get_site_info_expr"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_site_info_expr">[docs]</a><span class="k">def</span> <span class="nf">get_site_info_expr</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">int32_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;int32_sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">median_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;median_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">array_sum_agg_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayNumericExpression</span><span class="p">]</span>
    <span class="p">]</span> <span class="o">=</span> <span class="n">INFO_AGG_FIELDS</span><span class="p">[</span><span class="s2">&quot;array_sum_agg_fields&quot;</span><span class="p">],</span>
    <span class="n">retain_cdfs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">cdf_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a site-level annotation Struct aggregating typical VCF INFO fields from GVCF INFO fields stored in the MT entries.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - If `RAW_MQandDP` is specified in array_sum_agg_fields, it will be used for</span>
<span class="sd">          the `MQ` calculation and then dropped according to GATK recommendation.</span>
<span class="sd">        - If `RAW_MQ` and `MQ_DP` are given, they will be used for the `MQ` calculation</span>
<span class="sd">          and then dropped according to GATK recommendation.</span>
<span class="sd">        - If the fields to be aggregate (`sum_agg_fields`, `int32_sum_agg_fields`,</span>
<span class="sd">          `median_agg_fields`) are passed as list of str, then they should correspond</span>
<span class="sd">          to entry fields in `mt` or in `mt.gvcf_info`.</span>
<span class="sd">        - Priority is given to entry fields in `mt` over those in `mt.gvcf_info` in</span>
<span class="sd">          case of a name clash.</span>

<span class="sd">    :param mt: Input Matrix Table</span>
<span class="sd">    :param sum_agg_fields: Fields to aggregate using sum.</span>
<span class="sd">    :param int32_sum_agg_fields: Fields to aggregate using sum using int32.</span>
<span class="sd">    :param median_agg_fields: Fields to aggregate using (approximate) median.</span>
<span class="sd">    :param retain_cdfs: If True, retains the cumulative distribution functions (CDFs)</span>
<span class="sd">        as an annotation for `median_agg_fields`. Keeping the CDFs is useful for</span>
<span class="sd">        annotations that require calculating the median across combined datasets at a</span>
<span class="sd">        later stage. Default is False.</span>
<span class="sd">    :param cdf_k: Parameter controlling the accuracy vs. memory usage tradeoff when</span>
<span class="sd">        retaining CDFs. A higher value of `cdf_k` results in a more accurate CDF</span>
<span class="sd">        approximation but increases memory usage and computation time. Default is 200.</span>
<span class="sd">    :return: Expression containing the site-level info fields</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">sum_agg_fields</span><span class="p">)</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="n">int32_sum_agg_fields</span><span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;`DP` was included in site-level aggregation. This requires a densifying&quot;</span>
            <span class="s2">&quot; prior to running get_site_info_expr&quot;</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">_get_info_agg_expr</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">=</span><span class="n">mt</span><span class="p">,</span>
        <span class="n">sum_agg_fields</span><span class="o">=</span><span class="n">sum_agg_fields</span><span class="p">,</span>
        <span class="n">int32_sum_agg_fields</span><span class="o">=</span><span class="n">int32_sum_agg_fields</span><span class="p">,</span>
        <span class="n">median_agg_fields</span><span class="o">=</span><span class="n">median_agg_fields</span><span class="p">,</span>
        <span class="n">array_sum_agg_fields</span><span class="o">=</span><span class="n">array_sum_agg_fields</span><span class="p">,</span>
        <span class="n">retain_cdfs</span><span class="o">=</span><span class="n">retain_cdfs</span><span class="p">,</span>
        <span class="n">cdf_k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add FS and SOR if SB is present</span>
    <span class="c1"># This is done outside _get_info_agg_expr as the behavior is different</span>
    <span class="c1"># in site vs allele-specific versions</span>
    <span class="k">if</span> <span class="s2">&quot;SB&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;FS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fs_from_sb</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">])</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;SOR&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">sor_from_sb</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;SB&quot;</span><span class="p">])</span>

    <span class="c1"># Run aggregator on non-ref genotypes</span>
    <span class="n">info</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">k</span> <span class="o">!=</span> <span class="s2">&quot;DP&quot;</span><span class="p">}),</span>
    <span class="p">)</span>

    <span class="c1"># Add DP, computed over both ref and non-ref genotypes, if present</span>
    <span class="k">if</span> <span class="s2">&quot;DP&quot;</span> <span class="ow">in</span> <span class="n">agg_expr</span><span class="p">:</span>
        <span class="n">info</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">DP</span><span class="o">=</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;DP&quot;</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">info</span></div>


<div class="viewcode-block" id="default_compute_info"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.default_compute_info">[docs]</a><span class="k">def</span> <span class="nf">default_compute_info</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">site_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">as_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="c1"># Set to True by default to prevent a breaking change.</span>
    <span class="n">quasi_as_annotations</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">n_partitions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">5000</span><span class="p">,</span>
    <span class="n">lowqual_indel_phred_het_prior</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">40</span><span class="p">,</span>
    <span class="n">ac_filter_groups</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Expression</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">retain_cdfs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">cdf_k</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute a HT with the typical GATK allele-specific (AS) info fields as well as ACs and lowqual fields.</span>

<span class="sd">    .. note::</span>

<span class="sd">        - This table doesn&#39;t split multi-allelic sites.</span>
<span class="sd">        - At least one of `site_annotations`, `as_annotations` or `quasi_as_annotations`</span>
<span class="sd">          must be True.</span>

<span class="sd">    :param mt: Input MatrixTable. Note that this table should be filtered to nonref sites.</span>
<span class="sd">    :param site_annotations: Whether to generate site level info fields. Default is False.</span>
<span class="sd">    :param as_annotations: Whether to generate allele-specific info fields using</span>
<span class="sd">        allele-specific annotations in gvcf_info. Default is False.</span>
<span class="sd">    :param quasi_as_annotations: Whether to generate allele-specific info fields using</span>
<span class="sd">        non-allele-specific annotations in gvcf_info, but performing per allele</span>
<span class="sd">        aggregations. This method can be used in cases where genotype data doesn&#39;t</span>
<span class="sd">        contain allele-specific annotations to approximate allele-specific annotations.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    :param n_partitions: Optional number of desired partitions for output Table. If</span>
<span class="sd">        specified, naive_coalesce is performed. Default is 5000.</span>
<span class="sd">    :param lowqual_indel_phred_het_prior: Phred-scaled prior for a het genotype at a</span>
<span class="sd">        site with a low quality indel. Default is 40. We use 1/10k bases (phred=40) to</span>
<span class="sd">        be more consistent with the filtering used by Broad&#39;s Data Sciences Platform</span>
<span class="sd">        for VQSR.</span>
<span class="sd">    :param ac_filter_groups: Optional dictionary of sample filter expressions to compute</span>
<span class="sd">        additional groupings of ACs. Default is None.</span>
<span class="sd">    :param retain_cdfs: If True, retains the cumulative distribution functions (CDFs)</span>
<span class="sd">        as an annotation for `median_agg_fields`. Keeping the CDFs is useful for</span>
<span class="sd">        annotations that require calculating the median across combined datasets at a</span>
<span class="sd">        later stage. Default is False.</span>
<span class="sd">    :param cdf_k: Parameter controlling the accuracy vs. memory usage tradeoff when</span>
<span class="sd">        retaining CDFs. A higher value of `cdf_k` results in a more accurate CDF</span>
<span class="sd">        approximation but increases memory usage and computation time. Default is 200.</span>
<span class="sd">    :return: Table with info fields</span>
<span class="sd">    :rtype: Table</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">site_annotations</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">as_annotations</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">quasi_as_annotations</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;At least one of `site_annotations`, `as_annotations`, or &quot;</span>
            <span class="s2">&quot;`quasi_as_annotations` must be True!&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Add a temporary annotation for allele count groupings.</span>
    <span class="n">ac_filter_groups</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="p">(</span><span class="n">ac_filter_groups</span> <span class="ow">or</span> <span class="p">{})}</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span><span class="n">_ac_filter_groups</span><span class="o">=</span><span class="n">ac_filter_groups</span><span class="p">)</span>

    <span class="c1"># Move gvcf info entries out from nested struct.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">transmute_entries</span><span class="p">(</span><span class="o">**</span><span class="n">mt</span><span class="o">.</span><span class="n">gvcf_info</span><span class="p">)</span>

    <span class="c1"># Adding alt_alleles_range_array as a required annotation for</span>
    <span class="c1"># get_as_info_expr to reduce memory usage.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">alt_alleles_range_array</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">)))</span>

    <span class="n">info_expr</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">quasi_info_expr</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Compute quasi-AS info expr.</span>
    <span class="k">if</span> <span class="n">quasi_as_annotations</span><span class="p">:</span>
        <span class="n">info_expr</span> <span class="o">=</span> <span class="n">get_as_info_expr</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">retain_cdfs</span><span class="o">=</span><span class="n">retain_cdfs</span><span class="p">,</span> <span class="n">cdf_k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">)</span>

    <span class="c1"># Compute AS info expr using gvcf_info allele specific annotations.</span>
    <span class="k">if</span> <span class="n">as_annotations</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">info_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">quasi_info_expr</span> <span class="o">=</span> <span class="n">info_expr</span>
        <span class="n">info_expr</span> <span class="o">=</span> <span class="n">get_as_info_expr</span><span class="p">(</span>
            <span class="n">mt</span><span class="p">,</span>
            <span class="o">**</span><span class="n">AS_INFO_AGG_FIELDS</span><span class="p">,</span>
            <span class="n">treat_fields_as_allele_specific</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="n">retain_cdfs</span><span class="o">=</span><span class="n">retain_cdfs</span><span class="p">,</span>
            <span class="n">cdf_k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">info_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Add allele specific pab_max</span>
        <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AS_pab_max</span><span class="o">=</span><span class="n">pab_max_expr</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">alleles</span><span class="p">))</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">site_annotations</span><span class="p">:</span>
        <span class="n">site_expr</span> <span class="o">=</span> <span class="n">get_site_info_expr</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="n">retain_cdfs</span><span class="o">=</span><span class="n">retain_cdfs</span><span class="p">,</span> <span class="n">cdf_k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">info_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">info_expr</span> <span class="o">=</span> <span class="n">site_expr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">site_expr</span><span class="p">)</span>

    <span class="c1"># Add &#39;AC&#39; and &#39;AC_raw&#39; for each allele count filter group requested.</span>
    <span class="c1"># First compute ACs for each non-ref allele, grouped by adj.</span>
    <span class="n">grp_ac_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">ai</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">mt</span><span class="o">.</span><span class="n">_ac_filter_groups</span><span class="p">[</span><span class="n">f</span><span class="p">],</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
                    <span class="n">get_adj_expr</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">GQ</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span> <span class="n">mt</span><span class="o">.</span><span class="n">LAD</span><span class="p">),</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">one_hot_alleles</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">str</span><span class="p">(</span><span class="n">x</span><span class="p">)))[</span>
                            <span class="n">mt</span><span class="o">.</span><span class="n">LA</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ai</span><span class="p">)</span>
                        <span class="p">]</span>
                    <span class="p">),</span>
                <span class="p">),</span>
            <span class="p">),</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">alt_alleles_range_array</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">ac_filter_groups</span>
    <span class="p">}</span>

    <span class="c1"># Then, for each non-ref allele, compute</span>
    <span class="c1"># &#39;AC&#39; as the adj group</span>
    <span class="c1"># &#39;AC_raw&#39; as the sum of adj and non-adj groups</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;AC</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">f</span><span class="si">}</span><span class="s2">_raw&quot;</span><span class="p">:</span> <span class="n">grp</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">grp_ac_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">},</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;AC</span><span class="si">{</span><span class="s1">&#39;_&#39;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="n">f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">grp</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">i</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
            <span class="k">for</span> <span class="n">f</span><span class="p">,</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">grp_ac_expr</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">},</span>
    <span class="p">)</span>

    <span class="n">ann_expr</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;info&quot;</span><span class="p">:</span> <span class="n">info_expr</span><span class="p">}</span>
    <span class="k">if</span> <span class="n">quasi_info_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">ann_expr</span><span class="p">[</span><span class="s2">&quot;quasi_info&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">quasi_info_expr</span>

    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(</span><span class="o">**</span><span class="n">ann_expr</span><span class="p">)</span><span class="o">.</span><span class="n">rows</span><span class="p">()</span>

    <span class="c1"># Add AS lowqual flag</span>
    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">AS_lowqual</span><span class="o">=</span><span class="n">get_lowqual_expr</span><span class="p">(</span>
            <span class="n">info_ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
            <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">AS_QUALapprox</span><span class="p">,</span>
            <span class="n">indel_phred_het_prior</span><span class="o">=</span><span class="n">lowqual_indel_phred_het_prior</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">site_annotations</span><span class="p">:</span>
        <span class="c1"># Add lowqual flag</span>
        <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">lowqual</span><span class="o">=</span><span class="n">get_lowqual_expr</span><span class="p">(</span>
                <span class="n">info_ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">,</span>
                <span class="n">info_ht</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">QUALapprox</span><span class="p">,</span>
                <span class="n">indel_phred_het_prior</span><span class="o">=</span><span class="n">lowqual_indel_phred_het_prior</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">n_partitions</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">naive_coalesce</span><span class="p">(</span><span class="n">n_partitions</span><span class="p">)</span>

    <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">retain_cdfs</span><span class="o">=</span><span class="n">retain_cdfs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">retain_cdfs</span><span class="p">:</span>
        <span class="n">info_ht</span> <span class="o">=</span> <span class="n">info_ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="n">cdf_k</span><span class="o">=</span><span class="n">cdf_k</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">info_ht</span></div>


<div class="viewcode-block" id="split_info_annotation"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.split_info_annotation">[docs]</a><span class="k">def</span> <span class="nf">split_info_annotation</span><span class="p">(</span>
    <span class="n">info_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">a_index</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split multi-allelic allele-specific info fields.</span>

<span class="sd">    :param info_expr: Field containing info struct.</span>
<span class="sd">    :param a_index: Allele index. Output by hl.split_multi or hl.split_multi_hts.</span>
<span class="sd">    :return: Info struct with split annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Index AS annotations</span>
    <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">f</span><span class="p">:</span> <span class="n">info_expr</span><span class="p">[</span><span class="n">f</span><span class="p">][</span><span class="n">a_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">info_expr</span>
            <span class="k">if</span> <span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AC&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;AS_&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">f</span> <span class="o">==</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="s2">&quot;AS_SB_TABLE&quot;</span> <span class="ow">in</span> <span class="n">info_expr</span><span class="p">:</span>
        <span class="n">info_expr</span> <span class="o">=</span> <span class="n">info_expr</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">AS_SB_TABLE</span><span class="o">=</span><span class="n">info_expr</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">info_expr</span><span class="o">.</span><span class="n">AS_SB_TABLE</span><span class="p">[</span><span class="n">a_index</span><span class="p">])</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">info_expr</span></div>


<div class="viewcode-block" id="split_lowqual_annotation"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.split_lowqual_annotation">[docs]</a><span class="k">def</span> <span class="nf">split_lowqual_annotation</span><span class="p">(</span>
    <span class="n">lowqual_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span> <span class="n">a_index</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split multi-allelic low QUAL annotation.</span>

<span class="sd">    :param lowqual_expr: Field containing low QUAL annotation.</span>
<span class="sd">    :param a_index: Allele index. Output by hl.split_multi or hl.split_multi_hts.</span>
<span class="sd">    :return: Low QUAL expression for particular allele.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">lowqual_expr</span><span class="p">[</span><span class="n">a_index</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span></div>


<div class="viewcode-block" id="impute_sex_ploidy"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.impute_sex_ploidy">[docs]</a><span class="k">def</span> <span class="nf">impute_sex_ploidy</span><span class="p">(</span>
    <span class="n">mt</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span>
    <span class="n">excluded_calling_intervals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">included_calling_intervals</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">normalization_contig</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;chr20&quot;</span><span class="p">,</span>
    <span class="n">chr_x</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">chr_y</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">use_only_variants</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Impute sex ploidy from a sparse MatrixTable.</span>

<span class="sd">    Sex ploidy is imputed by normalizing the coverage of chromosomes X and Y using the coverage of an autosomal</span>
<span class="sd">    chromosome (by default chr20).</span>

<span class="sd">    Coverage is computed using the median block coverage (summed over the block size) and the non-ref coverage at</span>
<span class="sd">    non-ref genotypes unless the `use_only_variants` argument is set to True and then it will use the mean coverage</span>
<span class="sd">    defined by only the variants.</span>

<span class="sd">    :param mt: Input sparse Matrix Table</span>
<span class="sd">    :param excluded_calling_intervals: Optional table of intervals to exclude from the computation. Used only when</span>
<span class="sd">        determining contig size (not used when computing chromosome depth) when `use_only_variants` is False.</span>
<span class="sd">    :param included_calling_intervals: Optional table of intervals to use in the computation. Used only when</span>
<span class="sd">        determining contig size (not used when computing chromosome depth) when `use_only_variants` is False.</span>
<span class="sd">    :param normalization_contig: Which chromosome to normalize by</span>
<span class="sd">    :param chr_x: Optional X Chromosome contig name (by default uses the X contig in the reference)</span>
<span class="sd">    :param chr_y: Optional Y Chromosome contig name (by default uses the Y contig in the reference)</span>
<span class="sd">    :param use_only_variants: Whether to use depth of variant data within calling intervals instead of reference data.</span>
<span class="sd">        Default will only use reference data.</span>

<span class="sd">    :return: Table with mean coverage over chromosomes 20, X and Y and sex chromosomes ploidy based on normalized coverage.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">get_reference_genome</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span> <span class="n">add_sequence</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chr_x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> X chromosome contigs (</span><span class="si">{1}</span><span class="s2">) in Genome reference.&quot;</span>
                <span class="s2">&quot; sparse_impute_sex_ploidy currently only supports a single X&quot;</span>
                <span class="s2">&quot; chromosome contig. Please use the `chr_x` argument to  specify which&quot;</span>
                <span class="s2">&quot; X chromosome contig to use &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">),</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">chr_x</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">chr_y</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Found </span><span class="si">{0}</span><span class="s2"> Y chromosome contigs (</span><span class="si">{1}</span><span class="s2">) in Genome reference.&quot;</span>
                <span class="s2">&quot; sparse_impute_sex_ploidy currently only supports a single Y&quot;</span>
                <span class="s2">&quot; chromosome contig. Please use the `chr_y` argument to  specify which&quot;</span>
                <span class="s2">&quot; Y chromosome contig to use &quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="nb">len</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">),</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="n">chr_y</span> <span class="o">=</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">get_contig_size</span><span class="p">(</span><span class="n">contig</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the size of the specified `contig` using the median block coverage (summed over the block size).</span>

<span class="sd">        The size of the contig will be determined using only non par regions if the contig is an X or Y reference contig</span>
<span class="sd">        and using the intervals specified by `included_calling_intervals` and excluding intervals specified by</span>
<span class="sd">        `excluded_calling_intervals` if either is defined in the outer function.</span>

<span class="sd">        :param contig: Contig to compute the size of</span>
<span class="sd">        :return: Integer of the contig size</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Working on </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">contig</span><span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">range_table</span><span class="p">(</span>
            <span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">),</span>
            <span class="n">n_partitions</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">ref</span><span class="o">.</span><span class="n">contig_length</span><span class="p">(</span><span class="n">contig</span><span class="p">)</span> <span class="o">/</span> <span class="mi">500_000</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">locus</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">locus</span><span class="p">(</span><span class="n">contig</span><span class="o">=</span><span class="n">contig</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">reference_genome</span><span class="o">=</span><span class="n">ref</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">sequence_context</span><span class="p">()</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">!=</span> <span class="s2">&quot;n&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">contig</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())</span>

        <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">included_calling_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">included_calling_intervals</span><span class="p">[</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">excluded_calling_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">contig_ht</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">excluded_calling_intervals</span><span class="p">[</span><span class="n">contig_ht</span><span class="o">.</span><span class="n">key</span><span class="p">])</span>
            <span class="p">)</span>
        <span class="n">contig_size</span> <span class="o">=</span> <span class="n">contig_ht</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Contig </span><span class="si">%s</span><span class="s2"> has </span><span class="si">%d</span><span class="s2"> bases for coverage.&quot;</span><span class="p">,</span> <span class="n">contig</span><span class="p">,</span> <span class="n">contig_size</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">contig_size</span>

    <span class="k">def</span> <span class="nf">get_chr_dp_ann</span><span class="p">(</span><span class="n">chrom</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the mean depth of the specified chromosome.</span>

<span class="sd">        The total depth will be determined using the sum DP of either reference and variant data or only variant data</span>
<span class="sd">        depending on the value of `use_only_variants` in the outer function.</span>

<span class="sd">        If `use_only_variants` is set to False then this value is computed using the median block coverage (summed over</span>
<span class="sd">        the block size). If `use_only_variants` is set to True, this value is computed using the sum of DP for  all</span>
<span class="sd">        variants divided by the total number of variants.</span>

<span class="sd">        The depth calculations will be determined using only non par regions if the contig is an X or Y reference contig</span>
<span class="sd">        and using the intervals specified by `included_calling_intervals` and excluding intervals specified by</span>
<span class="sd">        `excluded_calling_intervals` if either is defined in the outer function (when `use_only_variants` is not</span>
<span class="sd">        set this only applies to the contig size estimate and is not used when computing chromosome depth).</span>

<span class="sd">        :param chrom: Chromosome to compute the mean depth of</span>
<span class="sd">        :return: Table of a per sample mean depth of `chrom`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">contig_size</span> <span class="o">=</span> <span class="n">get_contig_size</span><span class="p">(</span><span class="n">chrom</span><span class="p">)</span>
        <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span><span class="n">mt</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">parse_locus_interval</span><span class="p">(</span><span class="n">chrom</span><span class="p">)])</span>

        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">x_contigs</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_x_nonpar</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">chrom</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">y_contigs</span><span class="p">:</span>
            <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">in_y_nonpar</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">use_only_variants</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">included_calling_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">included_calling_intervals</span><span class="p">[</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">if</span> <span class="n">excluded_calling_intervals</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">chr_mt</span> <span class="o">=</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">excluded_calling_intervals</span><span class="p">[</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
                        <span class="n">chr_mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span><span class="p">),</span>
                    <span class="p">)</span>
                    <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">chr_mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_non_ref</span><span class="p">(),</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count</span><span class="p">())</span>
                <span class="p">}</span>
            <span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">select_cols</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chrom</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">:</span> <span class="p">(</span>
                        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                            <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
                                <span class="n">chr_mt</span><span class="o">.</span><span class="n">LGT</span><span class="o">.</span><span class="n">is_hom_ref</span><span class="p">(),</span>
                                <span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">END</span> <span class="o">-</span> <span class="n">chr_mt</span><span class="o">.</span><span class="n">locus</span><span class="o">.</span><span class="n">position</span><span class="p">),</span>
                                <span class="n">chr_mt</span><span class="o">.</span><span class="n">DP</span><span class="p">,</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="o">/</span> <span class="n">contig_size</span>
                    <span class="p">)</span>
                <span class="p">}</span>
            <span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>

    <span class="n">normalization_chrom_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">normalization_contig</span><span class="p">)</span>
    <span class="n">chrX_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">chr_x</span><span class="p">)</span>
    <span class="n">chrY_dp</span> <span class="o">=</span> <span class="n">get_chr_dp_ann</span><span class="p">(</span><span class="n">chr_y</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="n">chrX_dp</span><span class="p">[</span><span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">key</span><span class="p">],</span>
        <span class="o">**</span><span class="n">chrY_dp</span><span class="p">[</span><span class="n">normalization_chrom_dp</span><span class="o">.</span><span class="n">key</span><span class="p">],</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_x</span><span class="si">}</span><span class="s2">_ploidy&quot;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_x</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">normalization_contig</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_y</span><span class="si">}</span><span class="s2">_ploidy&quot;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">chr_y</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span>
            <span class="o">/</span> <span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">normalization_contig</span><span class="si">}</span><span class="s2">_mean_dp&quot;</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="densify_all_reference_sites"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.densify_all_reference_sites">[docs]</a><span class="k">def</span> <span class="nf">densify_all_reference_sites</span><span class="p">(</span>
    <span class="n">mtds</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">],</span>
    <span class="n">reference_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">interval_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">row_key_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">,),</span>
    <span class="n">entry_keep_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;GT&quot;</span><span class="p">,),</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Densify a VariantDataset or Sparse MatrixTable at all sites in a reference Table.</span>

<span class="sd">    :param mtds: Input sparse MatrixTable or VariantDataset.</span>
<span class="sd">    :param reference_ht: Table of reference sites.</span>
<span class="sd">    :param interval_ht: Optional Table of intervals to filter to.</span>
<span class="sd">    :param row_key_fields: Fields to use as row key. Defaults to locus.</span>
<span class="sd">    :param entry_keep_fields: Fields to keep in entries before performing the</span>
<span class="sd">        densification. Defaults to GT.</span>
<span class="sd">    :return: Densified MatrixTable.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_vds</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mtds</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">interval_ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">is_vds</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="s2">&quot;Filtering to an interval list for a sparse Matrix Table is currently&quot;</span>
            <span class="s2">&quot; not supported.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Filter datasets to interval list.</span>
    <span class="k">if</span> <span class="n">interval_ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">reference_ht</span> <span class="o">=</span> <span class="n">reference_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">interval_ht</span><span class="p">[</span><span class="n">reference_ht</span><span class="o">.</span><span class="n">locus</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="n">mtds</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span>
            <span class="n">vds</span><span class="o">=</span><span class="n">mtds</span><span class="p">,</span> <span class="n">intervals</span><span class="o">=</span><span class="n">interval_ht</span><span class="p">,</span> <span class="n">split_reference_blocks</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

    <span class="n">entry_keep_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">entry_keep_fields</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_vds</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span><span class="o">.</span><span class="n">variant_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span>
        <span class="n">entry_keep_fields</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;END&quot;</span><span class="p">)</span>

    <span class="c1"># Get the total number of samples.</span>
    <span class="n">n_samples</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">count_cols</span><span class="p">()</span>
    <span class="n">mt_col_key_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">)</span>
    <span class="n">mt_row_key_fields</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">row_key</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span><span class="o">*</span><span class="n">entry_keep_fields</span><span class="p">)</span><span class="o">.</span><span class="n">select_cols</span><span class="p">()</span>

    <span class="c1"># Localize entries and perform an outer join with the reference HT.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">_localize_entries</span><span class="p">(</span><span class="s2">&quot;__entries&quot;</span><span class="p">,</span> <span class="s2">&quot;__cols&quot;</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="o">*</span><span class="n">row_key_fields</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">reference_ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="o">*</span><span class="n">row_key_fields</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">_in_ref</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="o">*</span><span class="n">mt_row_key_fields</span><span class="p">)</span>

    <span class="c1"># Fill in missing entries with missing values for each entry field.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">__entries</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">__entries</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">n_samples</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">__entries</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">element_type</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Unlocalize entries to turn the HT back to a MT.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">_unlocalize_entries</span><span class="p">(</span><span class="s2">&quot;__entries&quot;</span><span class="p">,</span> <span class="s2">&quot;__cols&quot;</span><span class="p">,</span> <span class="n">mt_col_key_fields</span><span class="p">)</span>

    <span class="c1"># Densify VDS/sparse MT at all sites.</span>
    <span class="k">if</span> <span class="n">is_vds</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">to_dense_mt</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">(</span><span class="n">mtds</span><span class="o">.</span><span class="n">reference_data</span><span class="o">.</span><span class="n">select_cols</span><span class="p">()</span><span class="o">.</span><span class="n">select_rows</span><span class="p">(),</span> <span class="n">mt</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">densify</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="c1"># Remove rows where the reference is missing.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">_in_ref</span><span class="p">)</span>

    <span class="c1"># Unfilter entries so that entries with no ref block overlap aren&#39;t null.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">unfilter_entries</span><span class="p">()</span>

    <span class="c1"># Rekey by requested row key field and drop unused keys.</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">key_rows_by</span><span class="p">(</span><span class="o">*</span><span class="n">row_key_fields</span><span class="p">)</span>
    <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mt_row_key_fields</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">row_key_fields</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">mt</span></div>


<div class="viewcode-block" id="compute_stats_per_ref_site"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_stats_per_ref_site">[docs]</a><span class="k">def</span> <span class="nf">compute_stats_per_ref_site</span><span class="p">(</span>
    <span class="n">mtds</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">],</span>
    <span class="n">reference_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">entry_agg_funcs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]],</span>
    <span class="n">row_key_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;locus&quot;</span><span class="p">,),</span>
    <span class="n">interval_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">entry_keep_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">row_keep_fields</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Set</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">entry_agg_group_membership</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_membership_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">sex_karyotype_field</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute stats per site in a reference Table.</span>

<span class="sd">    :param mtds: Input sparse Matrix Table or VariantDataset.</span>
<span class="sd">    :param reference_ht: Table of reference sites.</span>
<span class="sd">    :param entry_agg_funcs: Dict of entry aggregation functions to perform on the</span>
<span class="sd">        VariantDataset/MatrixTable. The keys of the dict are the names of the</span>
<span class="sd">        annotations and the values are tuples of functions. The first function is used</span>
<span class="sd">        to transform the `mt` entries in some way, and the second function is used to</span>
<span class="sd">        aggregate the output from the first function.</span>
<span class="sd">    :param row_key_fields: Fields to use as row key. Defaults to locus.</span>
<span class="sd">    :param interval_ht: Optional table of intervals to filter to.</span>
<span class="sd">    :param entry_keep_fields: Fields to keep in entries before performing the</span>
<span class="sd">        densification in `densify_all_reference_sites`. Should include any fields</span>
<span class="sd">        needed for the functions in `entry_agg_funcs`. By default, only GT or LGT is</span>
<span class="sd">        kept.</span>
<span class="sd">    :param row_keep_fields: Fields to keep in rows after performing the stats</span>
<span class="sd">        aggregation. By default, only the row key fields are kept.</span>
<span class="sd">    :param entry_agg_group_membership: Optional dict indicating the subset of group</span>
<span class="sd">        strata in &#39;freq_meta&#39; to use the entry aggregation functions on. The keys of</span>
<span class="sd">        the dict can be any of the keys in `entry_agg_funcs` and the values are lists</span>
<span class="sd">        of dicts. Each dict in the list contains the strata in &#39;freq_meta&#39; to use for</span>
<span class="sd">        the corresponding entry aggregation function. If provided, &#39;freq_meta&#39; must be</span>
<span class="sd">        present in `group_membership_ht` and represent the same strata as those in</span>
<span class="sd">        &#39;group_membership&#39;. If not provided, all entries of the &#39;group_membership&#39;</span>
<span class="sd">        annotation will have the entry aggregation functions applied to them.</span>
<span class="sd">    :param strata_expr: Optional list of dicts of expressions to stratify by.</span>
<span class="sd">    :param group_membership_ht: Optional Table of group membership annotations.</span>
<span class="sd">    :param sex_karyotype_field: Optional field to use to adjust genotypes for sex</span>
<span class="sd">        karyotype before stats aggregation. If provided, the field must be present in</span>
<span class="sd">        the columns of `mtds` (variant_data MT if `mtds` is a VDS) and use &quot;XX&quot; and</span>
<span class="sd">        &quot;XY&quot; as values. If not provided, no sex karyotype adjustment is performed.</span>
<span class="sd">        Default is None.</span>
<span class="sd">    :return: Table of stats per site.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_vds</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mtds</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_vds</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span><span class="o">.</span><span class="n">variant_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span>

    <span class="k">if</span> <span class="n">sex_karyotype_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sex_karyotype_field</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">col</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The supplied &#39;sex_karyotype_field&#39;, </span><span class="si">{</span><span class="n">sex_karyotype_field</span><span class="si">}</span><span class="s2">, is not present&quot;</span>
            <span class="s2">&quot; in the columns of the input!&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">group_membership_ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">strata_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;Only one of &#39;group_membership_ht&#39; or &#39;strata_expr&#39; can be specified.&quot;</span>
        <span class="p">)</span>

    <span class="n">g</span> <span class="o">=</span> <span class="p">{}</span> <span class="k">if</span> <span class="n">group_membership_ht</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">group_membership_ht</span><span class="o">.</span><span class="n">globals</span>
    <span class="k">if</span> <span class="n">entry_agg_group_membership</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="s2">&quot;freq_meta&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The &#39;freq_meta&#39; annotation must be present in &#39;group_membership_ht&#39; if &quot;</span>
            <span class="s2">&quot;&#39;entry_agg_group_membership&#39; is specified.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Determine if the adj annotation is needed. It is only needed if &quot;adj_groups&quot; is</span>
    <span class="c1"># in the globals of the group_membership_ht and any entry is True, or &quot;freq_meta&quot;</span>
    <span class="c1"># is in the globals of the group_membership_ht and any entry has &quot;group&quot; == &quot;adj&quot;.</span>
    <span class="n">adj</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">eval</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;adj_groups&quot;</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_array</span><span class="p">(</span><span class="s2">&quot;bool&quot;</span><span class="p">)))</span>
        <span class="o">|</span> <span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">(</span>
            <span class="n">g</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;freq_meta&quot;</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">empty_array</span><span class="p">(</span><span class="s2">&quot;dict&lt;str, str&gt;&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;NA&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;adj&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Determine the entry fields on mt that should be densified.</span>
    <span class="c1"># &quot;GT&quot; or &quot;LGT&quot; is required for the genotype.</span>
    <span class="c1"># If the adj annotation is needed then &quot;adj&quot; must be present on mt, or AD/LAD, DP,</span>
    <span class="c1"># and GQ must be present.</span>
    <span class="n">en</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
    <span class="n">gt_field</span> <span class="o">=</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;GT&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;LGT&quot;</span><span class="p">}</span>
    <span class="n">ad_field</span> <span class="o">=</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;AD&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;LAD&quot;</span><span class="p">}</span>
    <span class="n">adj_fields</span> <span class="o">=</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;adj&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="p">({</span><span class="s2">&quot;DP&quot;</span><span class="p">,</span> <span class="s2">&quot;GQ&quot;</span><span class="p">}</span> <span class="o">|</span> <span class="n">ad_field</span><span class="p">)</span> <span class="k">if</span> <span class="n">adj</span> <span class="k">else</span> <span class="nb">set</span><span class="p">([])</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">gt_field</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No genotype field found in entry fields!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">adj</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">adj_fields</span><span class="o">.</span><span class="n">issubset</span><span class="p">(</span><span class="n">en</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;No &#39;adj&#39; found in entry fields, and one of AD/LAD, DP, and GQ is missing &quot;</span>
            <span class="s2">&quot;so adj can&#39;t be computed!&quot;</span>
        <span class="p">)</span>

    <span class="n">entry_keep_fields</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">entry_keep_fields</span> <span class="ow">or</span> <span class="nb">set</span><span class="p">([]))</span> <span class="o">|</span> <span class="n">gt_field</span> <span class="o">|</span> <span class="n">adj_fields</span>

    <span class="c1"># Write the sex karyotype field out to a temp HT so we can annotate the field back</span>
    <span class="c1"># onto the MT after &#39;densify_all_reference_sites&#39; removes all column annotations.</span>
    <span class="k">if</span> <span class="n">sex_karyotype_field</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sex_karyotype_ht</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">mt</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
            <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">sex_karyotype_field</span><span class="p">)</span>
            <span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;sex_karyotype_ht&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sex_karyotype_ht</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="c1"># Initialize no_strata and default strata_expr if neither group_membership_ht nor</span>
    <span class="c1"># strata_expr is provided.</span>
    <span class="n">no_strata</span> <span class="o">=</span> <span class="n">group_membership_ht</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">strata_expr</span> <span class="ow">is</span> <span class="kc">None</span>
    <span class="k">if</span> <span class="n">no_strata</span><span class="p">:</span>
        <span class="n">strata_expr</span> <span class="o">=</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="n">group_membership_ht</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;&#39;group_membership_ht&#39; is not specified, no stats are adj filtered.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Annotate the MT cols with each of the expressions in strata_expr and redefine</span>
        <span class="c1"># strata_expr based on the column HT with added annotations.</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strata_expr</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="p">)</span><span class="o">.</span><span class="n">cols</span><span class="p">()</span>
        <span class="n">strata_expr</span> <span class="o">=</span> <span class="p">[{</span><span class="n">k</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">d</span><span class="p">}</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">strata_expr</span><span class="p">]</span>

        <span class="c1"># Use &#39;generate_freq_group_membership_array&#39; to create a group_membership Table</span>
        <span class="c1"># that gives stratification group membership info based on &#39;strata_expr&#39;. The</span>
        <span class="c1"># returned Table has the following annotations: &#39;freq_meta&#39;,</span>
        <span class="c1"># &#39;freq_meta_sample_count&#39;, and &#39;group_membership&#39;. By default, this</span>
        <span class="c1"># function returns annotations where the second element is a placeholder for the</span>
        <span class="c1"># &quot;raw&quot; frequency of all samples, where the first 2 elements are the same sample</span>
        <span class="c1"># set, but &#39;freq_meta&#39; starts with [{&quot;group&quot;: &quot;adj&quot;, &quot;group&quot;: &quot;raw&quot;, ...]. Use</span>
        <span class="c1"># `no_raw_group` to exclude the &quot;raw&quot; group so there is a single annotation</span>
        <span class="c1"># representing the full samples set. Update all &#39;freq_meta&#39; entries&#39; &quot;group&quot;</span>
        <span class="c1"># to &quot;raw&quot; because `generate_freq_group_membership_array` will return them all</span>
        <span class="c1"># as &quot;adj&quot; since it was built for frequency computation, but for the coverage</span>
        <span class="c1"># computation we don&#39;t want to do any filtering.</span>
        <span class="n">group_membership_ht</span> <span class="o">=</span> <span class="n">generate_freq_group_membership_array</span><span class="p">(</span>
            <span class="n">ht</span><span class="p">,</span> <span class="n">strata_expr</span><span class="p">,</span> <span class="n">no_raw_group</span><span class="o">=</span><span class="kc">True</span>
        <span class="p">)</span>
        <span class="n">group_membership_ht</span> <span class="o">=</span> <span class="n">group_membership_ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
            <span class="n">freq_meta</span><span class="o">=</span><span class="n">group_membership_ht</span><span class="o">.</span><span class="n">freq_meta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span>
                    <span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">,</span> <span class="s2">&quot;raw&quot;</span><span class="p">),</span> <span class="n">m</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">is_vds</span><span class="p">:</span>
        <span class="n">rmt</span> <span class="o">=</span> <span class="n">mtds</span><span class="o">.</span><span class="n">reference_data</span>
        <span class="n">mtds</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">(</span>
            <span class="n">rmt</span><span class="o">.</span><span class="n">select_entries</span><span class="p">(</span>
                <span class="o">*</span><span class="p">((</span><span class="nb">set</span><span class="p">(</span><span class="n">entry_keep_fields</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">rmt</span><span class="o">.</span><span class="n">entry</span><span class="p">))</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;END&quot;</span><span class="p">,</span> <span class="s2">&quot;LEN&quot;</span><span class="p">})</span>
            <span class="p">),</span>
            <span class="n">mtds</span><span class="o">.</span><span class="n">variant_data</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="n">mt</span> <span class="o">=</span> <span class="n">densify_all_reference_sites</span><span class="p">(</span>
        <span class="n">mtds</span><span class="p">,</span>
        <span class="n">reference_ht</span><span class="p">,</span>
        <span class="n">interval_ht</span><span class="p">,</span>
        <span class="n">row_key_fields</span><span class="p">,</span>
        <span class="n">entry_keep_fields</span><span class="o">=</span><span class="n">entry_keep_fields</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">sex_karyotype_ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Adjusting genotype ploidy based on sex karyotype.&quot;</span><span class="p">)</span>
        <span class="n">gt_field</span> <span class="o">=</span> <span class="n">gt_field</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_cols</span><span class="p">(</span>
            <span class="n">sex_karyotype</span><span class="o">=</span><span class="n">sex_karyotype_ht</span><span class="p">[</span><span class="n">mt</span><span class="o">.</span><span class="n">col_key</span><span class="p">][</span><span class="n">sex_karyotype_field</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mt</span><span class="o">.</span><span class="n">annotate_entries</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">gt_field</span><span class="p">:</span> <span class="n">adjusted_sex_ploidy_expr</span><span class="p">(</span>
                    <span class="n">mt</span><span class="o">.</span><span class="n">locus</span><span class="p">,</span> <span class="n">mt</span><span class="p">[</span><span class="n">gt_field</span><span class="p">],</span> <span class="n">mt</span><span class="o">.</span><span class="n">sex_karyotype</span>
                <span class="p">)</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="c1"># Annotate with adj if needed.</span>
    <span class="k">if</span> <span class="n">adj</span> <span class="ow">and</span> <span class="s2">&quot;adj&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Annotating the MT with adj.&quot;</span><span class="p">)</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">annotate_adj</span><span class="p">(</span><span class="n">mt</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">agg_by_strata</span><span class="p">(</span>
        <span class="n">mt</span><span class="p">,</span>
        <span class="n">entry_agg_funcs</span><span class="p">,</span>
        <span class="n">group_membership_ht</span><span class="o">=</span><span class="n">group_membership_ht</span><span class="p">,</span>
        <span class="n">select_fields</span><span class="o">=</span><span class="n">row_keep_fields</span><span class="p">,</span>
        <span class="n">entry_agg_group_membership</span><span class="o">=</span><span class="n">entry_agg_group_membership</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">()</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">utils</span><span class="o">.</span><span class="n">new_temp_file</span><span class="p">(</span><span class="s2">&quot;agg_stats&quot;</span><span class="p">,</span> <span class="s2">&quot;ht&quot;</span><span class="p">))</span>

    <span class="n">group_globals</span> <span class="o">=</span> <span class="n">group_membership_ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">()</span>
    <span class="n">global_expr</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">if</span> <span class="n">no_strata</span><span class="p">:</span>
        <span class="c1"># If there was no stratification, move aggregated annotations to the top</span>
        <span class="c1"># level.</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">ann</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">ann</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">entry_agg_funcs</span><span class="p">})</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;sample_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_globals</span><span class="o">.</span><span class="n">freq_meta_sample_count</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># If there was stratification, add the metadata and sample count info for the</span>
        <span class="c1"># stratification to the globals.</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;strata_meta&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_globals</span><span class="o">.</span><span class="n">freq_meta</span>
        <span class="n">global_expr</span><span class="p">[</span><span class="s2">&quot;strata_sample_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">group_globals</span><span class="o">.</span><span class="n">freq_meta_sample_count</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span><span class="o">**</span><span class="n">global_expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="get_coverage_agg_func"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_coverage_agg_func">[docs]</a><span class="k">def</span> <span class="nf">get_coverage_agg_func</span><span class="p">(</span>
    <span class="n">dp_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;DP&quot;</span><span class="p">,</span> <span class="n">max_cov_bin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a transformation and aggregation function for computing coverage.</span>

<span class="sd">    Can be used as an entry aggregation function in `compute_stats_per_ref_site`.</span>

<span class="sd">    :param dp_field: Depth field to use for computing coverage. Default is &#39;DP&#39;.</span>
<span class="sd">    :param max_cov_bin: Maximum coverage bin (used when computing samples over X bin). Default is 100.</span>
<span class="sd">    :return: Tuple of functions to transform and aggregate coverage.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">dp_field</span><span class="p">])</span> <span class="o">|</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_nan</span><span class="p">(</span><span class="n">t</span><span class="p">[</span><span class="n">dp_field</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">t</span><span class="p">[</span><span class="n">dp_field</span><span class="p">]</span>
        <span class="p">),</span>
        <span class="k">lambda</span> <span class="n">dp</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="c1"># This expression creates a counter DP -&gt; number of samples for DP</span>
            <span class="c1"># between 0 and max_cov_bin.</span>
            <span class="n">coverage_counter</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">counter</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">max_cov_bin</span><span class="p">,</span> <span class="n">dp</span><span class="p">)),</span>
            <span class="n">mean</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">mean_dp</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_nan</span><span class="p">(</span><span class="n">mean_dp</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mean_dp</span><span class="p">),</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">dp</span><span class="p">),</span>
            <span class="p">),</span>
            <span class="n">median_approx</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">approx_median</span><span class="p">(</span><span class="n">dp</span><span class="p">),</span> <span class="mi">0</span><span class="p">),</span>
            <span class="n">total_DP</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dp</span><span class="p">),</span>
        <span class="p">),</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="compute_coverage_stats"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_coverage_stats">[docs]</a><span class="k">def</span> <span class="nf">compute_coverage_stats</span><span class="p">(</span>
    <span class="n">mtds</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">],</span>
    <span class="n">reference_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">interval_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coverage_over_x_bins</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">30</span><span class="p">,</span> <span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">],</span>
    <span class="n">row_key_fields</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;locus&quot;</span><span class="p">],</span>
    <span class="n">strata_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">group_membership_ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">dp_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;DP&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute coverage statistics for every base of the `reference_ht` provided.</span>

<span class="sd">    The following coverage stats are calculated:</span>
<span class="sd">        - mean</span>
<span class="sd">        - median</span>
<span class="sd">        - total DP</span>
<span class="sd">        - fraction of samples with coverage above X, for each x in `coverage_over_x_bins`</span>

<span class="sd">    The `reference_ht` is a Table that contains a row for each locus coverage that should be</span>
<span class="sd">    computed on. It needs to be keyed by `locus`. The `reference_ht` can e.g. be</span>
<span class="sd">    created using `get_reference_ht`.</span>

<span class="sd">    :param mtds: Input sparse MT or VDS.</span>
<span class="sd">    :param reference_ht: Input reference HT.</span>
<span class="sd">    :param interval_ht: Optional Table containing intervals to filter to.</span>
<span class="sd">    :param coverage_over_x_bins: List of boundaries for computing samples over X.</span>
<span class="sd">    :param row_key_fields: List of row key fields to use for joining `mtds` with</span>
<span class="sd">        `reference_ht`.</span>
<span class="sd">    :param strata_expr: Optional list of dicts containing expressions to stratify the</span>
<span class="sd">        coverage stats by. Only one of `group_membership_ht` or `strata_expr` can be</span>
<span class="sd">        specified.</span>
<span class="sd">    :param group_membership_ht: Optional Table containing group membership annotations</span>
<span class="sd">        to stratify the coverage stats by. Only one of `group_membership_ht` or</span>
<span class="sd">        `strata_expr` can be specified.</span>
<span class="sd">    :param dp_field: Name of sample depth field. Default is DP.</span>
<span class="sd">    :return: Table with per-base coverage stats.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">is_vds</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mtds</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">is_vds</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span><span class="o">.</span><span class="n">variant_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span>

    <span class="c1"># Determine the genotype field.</span>
    <span class="n">en</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
    <span class="n">gt_field</span> <span class="o">=</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;GT&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;LGT&quot;</span><span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gt_field</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No genotype field found in entry fields!&quot;</span><span class="p">)</span>

    <span class="n">gt_field</span> <span class="o">=</span> <span class="n">gt_field</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>

    <span class="c1"># Add function to compute coverage stats.</span>
    <span class="n">cov_bins</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">coverage_over_x_bins</span><span class="p">)</span>
    <span class="n">rev_cov_bins</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">cov_bins</span><span class="p">))</span>
    <span class="n">max_cov_bin</span> <span class="o">=</span> <span class="n">cov_bins</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cov_bins</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cov_bins</span><span class="p">)</span>
    <span class="n">entry_agg_funcs</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;coverage_stats&quot;</span><span class="p">:</span> <span class="n">get_coverage_agg_func</span><span class="p">(</span>
            <span class="n">dp_field</span><span class="o">=</span><span class="n">dp_field</span><span class="p">,</span> <span class="n">max_cov_bin</span><span class="o">=</span><span class="n">max_cov_bin</span>
        <span class="p">)</span>
    <span class="p">}</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">compute_stats_per_ref_site</span><span class="p">(</span>
        <span class="n">mtds</span><span class="p">,</span>
        <span class="n">reference_ht</span><span class="p">,</span>
        <span class="n">entry_agg_funcs</span><span class="p">,</span>
        <span class="n">row_key_fields</span><span class="o">=</span><span class="n">row_key_fields</span><span class="p">,</span>
        <span class="n">interval_ht</span><span class="o">=</span><span class="n">interval_ht</span><span class="p">,</span>
        <span class="n">entry_keep_fields</span><span class="o">=</span><span class="p">[</span><span class="n">gt_field</span><span class="p">,</span> <span class="n">dp_field</span><span class="p">],</span>
        <span class="n">strata_expr</span><span class="o">=</span><span class="n">strata_expr</span><span class="p">,</span>
        <span class="n">group_membership_ht</span><span class="o">=</span><span class="n">group_membership_ht</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># This expression aggregates the DP counter in reverse order of the cov_bins and</span>
    <span class="c1"># computes the cumulative sum over them. It needs to be in reverse order because we</span>
    <span class="c1"># want the sum over samples covered by &gt; X.</span>
    <span class="k">def</span> <span class="nf">_cov_stats</span><span class="p">(</span>
        <span class="n">cov_stat</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
        <span class="c1"># The coverage was already floored to the max_coverage_bin, so no more</span>
        <span class="c1"># aggregation is needed for the max bin.</span>
        <span class="n">count_expr</span> <span class="o">=</span> <span class="n">cov_stat</span><span class="o">.</span><span class="n">coverage_counter</span>
        <span class="n">max_bin_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">count_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">max_cov_bin</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

        <span class="c1"># For each of the other bins, coverage is summed between the boundaries.</span>
        <span class="n">bin_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">cov_bins</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">step</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">bin_expr</span> <span class="o">=</span> <span class="n">bin_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="n">cov_bins</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cov_bins</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">j</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int32</span><span class="p">(</span><span class="n">count_expr</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">bin_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cumulative_sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">max_bin_expr</span><span class="p">])</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bin_expr</span><span class="p">))</span>

        <span class="n">bin_expr</span> <span class="o">=</span> <span class="p">{</span><span class="sa">f</span><span class="s2">&quot;over_</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">bin_expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">n</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">rev_cov_bins</span><span class="p">)}</span>

        <span class="k">return</span> <span class="n">cov_stat</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">bin_expr</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;coverage_counter&quot;</span><span class="p">)</span>

    <span class="n">ht_globals</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">index_globals</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">coverage_stats</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">):</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span>
            <span class="n">coverage_stats_meta</span><span class="o">=</span><span class="n">ht_globals</span><span class="o">.</span><span class="n">strata_meta</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">dict</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">items</span><span class="p">()</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">m</span><span class="p">:</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;group&quot;</span><span class="p">))</span>
            <span class="p">),</span>
            <span class="n">coverage_stats_meta_sample_count</span><span class="o">=</span><span class="n">ht_globals</span><span class="o">.</span><span class="n">strata_sample_count</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">cov_stats_expr</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;coverage_stats&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="n">_cov_stats</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">n</span><span class="p">),</span>
                <span class="n">ht</span><span class="o">.</span><span class="n">coverage_stats</span><span class="p">,</span>
                <span class="n">ht_globals</span><span class="o">.</span><span class="n">strata_sample_count</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cov_stats_expr</span> <span class="o">=</span> <span class="n">_cov_stats</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">coverage_stats</span><span class="p">,</span> <span class="n">ht_globals</span><span class="o">.</span><span class="n">sample_count</span><span class="p">)</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">transmute</span><span class="p">(</span><span class="o">**</span><span class="n">cov_stats_expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="get_allele_number_agg_func"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.get_allele_number_agg_func">[docs]</a><span class="k">def</span> <span class="nf">get_allele_number_agg_func</span><span class="p">(</span><span class="n">gt_field</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;GT&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a transformation and aggregation function for computing the allele number.</span>

<span class="sd">    Can be used as an entry aggregation function in `compute_stats_per_ref_site`.</span>

<span class="sd">    :param gt_field: Genotype field to use for computing the allele number.</span>
<span class="sd">    :return: Tuple of functions to transform and aggregate the allele number.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">t</span><span class="p">[</span><span class="n">gt_field</span><span class="p">]</span><span class="o">.</span><span class="n">ploidy</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span></div>


<div class="viewcode-block" id="compute_allele_number_per_ref_site"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.compute_allele_number_per_ref_site">[docs]</a><span class="k">def</span> <span class="nf">compute_allele_number_per_ref_site</span><span class="p">(</span>
    <span class="n">mtds</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">],</span>
    <span class="n">reference_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the allele number per reference site.</span>

<span class="sd">    :param mtds: Input sparse Matrix Table or VariantDataset.</span>
<span class="sd">    :param reference_ht: Table of reference sites.</span>
<span class="sd">    :param kwargs: Keyword arguments to pass to `compute_stats_per_ref_site`.</span>
<span class="sd">    :return: Table of allele number per reference site.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mtds</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">vds</span><span class="o">.</span><span class="n">VariantDataset</span><span class="p">):</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span><span class="o">.</span><span class="n">variant_data</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">mt</span> <span class="o">=</span> <span class="n">mtds</span>

    <span class="c1"># Determine the genotype field.</span>
    <span class="n">en</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">mt</span><span class="o">.</span><span class="n">entry</span><span class="p">)</span>
    <span class="n">gt_field</span> <span class="o">=</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;GT&quot;</span><span class="p">}</span> <span class="ow">or</span> <span class="n">en</span> <span class="o">&amp;</span> <span class="p">{</span><span class="s2">&quot;LGT&quot;</span><span class="p">}</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">gt_field</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;No genotype field found in entry fields, needed for ploidy calculation!&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Use ploidy to determine the number of alleles for each sample at each site.</span>
    <span class="n">entry_agg_funcs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;AN&quot;</span><span class="p">:</span> <span class="n">get_allele_number_agg_func</span><span class="p">(</span><span class="n">gt_field</span><span class="o">.</span><span class="n">pop</span><span class="p">())}</span>

    <span class="k">return</span> <span class="n">compute_stats_per_ref_site</span><span class="p">(</span><span class="n">mtds</span><span class="p">,</span> <span class="n">reference_ht</span><span class="p">,</span> <span class="n">entry_agg_funcs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="filter_ref_blocks"><a class="viewcode-back" href="../../../api_reference/utils/sparse_mt.html#gnomad.utils.sparse_mt.filter_ref_blocks">[docs]</a><span class="k">def</span> <span class="nf">filter_ref_blocks</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter ref blocks out of the Table or MatrixTable.</span>

<span class="sd">    :param t: Input MT/HT</span>
<span class="sd">    :return: MT/HT with ref blocks removed</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">filter_rows</span><span class="p">((</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">filter</span><span class="p">((</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alleles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">t</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>