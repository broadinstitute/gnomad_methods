<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>gnomad.utils.constraint &mdash; gnomad master documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/theme_overrides.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            gnomad
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../getting_started.html">Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../api_reference/index.html">API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../resource_sources.html">Resource Sources</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/broadinstitute/gnomad_methods/releases">Change Log</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">gnomad</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">gnomad.utils.constraint</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for gnomad.utils.constraint</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;Script containing generic constraint functions that may be used in the constraint pipeline.&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span> <span class="nn">hail</span> <span class="k">as</span> <span class="nn">hl</span>
<span class="kn">from</span> <span class="nn">hail.utils.misc</span> <span class="kn">import</span> <span class="n">divide_null</span><span class="p">,</span> <span class="n">new_temp_file</span>

<span class="kn">from</span> <span class="nn">gnomad.utils.reference_genome</span> <span class="kn">import</span> <span class="n">get_reference_genome</span>
<span class="kn">from</span> <span class="nn">gnomad.utils.vep</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">add_most_severe_consequence_to_consequence</span><span class="p">,</span>
    <span class="n">explode_by_vep_annotation</span><span class="p">,</span>
    <span class="n">process_consequences</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">logging</span><span class="o">.</span><span class="n">basicConfig</span><span class="p">(</span>
    <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">%(asctime)s</span><span class="s2"> (</span><span class="si">%(name)s</span><span class="s2"> </span><span class="si">%(lineno)s</span><span class="s2">): </span><span class="si">%(message)s</span><span class="s2">&quot;</span><span class="p">,</span>
    <span class="n">datefmt</span><span class="o">=</span><span class="s2">&quot;%m/</span><span class="si">%d</span><span class="s2">/%Y %I:%M:%S %p&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s2">&quot;constraint_utils&quot;</span><span class="p">)</span>
<span class="n">logger</span><span class="o">.</span><span class="n">setLevel</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">)</span>

<span class="n">COVERAGE_CUTOFF</span> <span class="o">=</span> <span class="mi">30</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Minimum median exome coverage differentiating high coverage sites from low coverage sites.</span>

<span class="sd">Low coverage sites require an extra calibration when computing the proportion of expected variation.</span>
<span class="sd">&quot;&quot;&quot;</span>


<div class="viewcode-block" id="get_mu_annotation_expr"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.get_mu_annotation_expr">[docs]</a><span class="k">def</span> <span class="nf">get_mu_annotation_expr</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">mutation_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">mu_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;mu_snp&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get mutation rate annotation expression from the mutation rate Table.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Function expects that `ht` includes `mutation_ht`&#39;s key fields. Note that these</span>
<span class="sd">        annotations don&#39;t need to be the keys of `ht`. The standard keys used are:</span>
<span class="sd">        &#39;context&#39;, &#39;ref&#39;, &#39;alt&#39;, and &#39;methylation_level&#39;.</span>

<span class="sd">    This function converts the mutation rate Table into a dictionary and uses the</span>
<span class="sd">    mutation rate HT key fields in the input Table to get the mutation rate annotation</span>
<span class="sd">    expression. The dictionary is used instead of joining the mutation rate Table to</span>
<span class="sd">    the input Table to avoid unnecessary shuffling given the small size of the</span>
<span class="sd">    mutation rate Table.</span>

<span class="sd">    :param ht: Input Table that will be annotated with the returned mutation rate</span>
<span class="sd">        expression.</span>
<span class="sd">    :param mutation_ht: Mutation rate Table.</span>
<span class="sd">    :param mu_expr: Mutation rate expression or annotation name in `mutation_ht`.</span>
<span class="sd">        Default is &#39;mu_snp&#39;.</span>
<span class="sd">    :return: Mutation rate annotation expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mu_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">mu_expr</span> <span class="o">=</span> <span class="n">mutation_ht</span><span class="p">[</span><span class="n">mu_expr</span><span class="p">]</span>

    <span class="n">mutation_dict</span> <span class="o">=</span> <span class="n">mutation_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">mutation_ht</span><span class="o">.</span><span class="n">key</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect</span><span class="p">(</span><span class="n">mu_expr</span><span class="p">)),</span> <span class="n">_localize</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map_values</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">mutation_dict</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">mutation_ht</span><span class="o">.</span><span class="n">key</span><span class="p">}))</span></div>


<div class="viewcode-block" id="annotate_with_mu"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.annotate_with_mu">[docs]</a><span class="k">def</span> <span class="nf">annotate_with_mu</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">mutation_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">mu_annotation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;mu_snp&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate SNP mutation rate for the input Table.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Function expects that `ht` includes `mutation_ht`&#39;s key fields. Note that these</span>
<span class="sd">        annotations don&#39;t need to be the keys of `ht`. The standard keys used are:</span>
<span class="sd">        &#39;context&#39;, &#39;ref&#39;, &#39;alt&#39;, and &#39;methylation_level&#39;.</span>

<span class="sd">    :param ht: Input Table to annotate.</span>
<span class="sd">    :param mutation_ht: Mutation rate Table.</span>
<span class="sd">    :param mu_annotation: The name of mutation rate annotation in `mutation_ht`.</span>
<span class="sd">        Default is &#39;mu_snp&#39;.</span>
<span class="sd">    :return: Table with mutational rate annotation added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">mu</span> <span class="o">=</span> <span class="n">get_mu_annotation_expr</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">mutation_ht</span><span class="p">,</span> <span class="n">mutation_ht</span><span class="p">[</span><span class="n">mu_annotation</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span><span class="n">mu_annotation</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span><span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">mu</span><span class="p">),</span> <span class="n">mu</span><span class="p">)</span><span class="o">.</span><span class="n">or_error</span><span class="p">(</span><span class="s2">&quot;Missing mu&quot;</span><span class="p">)}</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="count_variants_by_group"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.count_variants_by_group">[docs]</a><span class="k">def</span> <span class="nf">count_variants_by_group</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">freq_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">freq_meta_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">count_singletons</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">count_downsamplings</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">additional_grouping</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">partition_hint</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">omit_methylation</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">use_table_group_by</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">singleton_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">max_af</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Count number of observed or possible variants by context, ref, alt, and optionally methylation_level.</span>

<span class="sd">    Performs variant count aggregations based on specified criteria</span>
<span class="sd">    (`count_singletons`, `count_downsamplings`, and `max_af`), and grouped by:</span>
<span class="sd">    &#39;context&#39;, &#39;ref&#39;, &#39;alt&#39;, &#39;methylation_level&#39; (optional), and all annotations</span>
<span class="sd">    provided in `additional_grouping`.</span>

<span class="sd">    If variant allele frequency information is required based on other parameter</span>
<span class="sd">    selections (described in detail below) and `freq_expr` is not supplied, `freq_expr`</span>
<span class="sd">    defaults to `ht.freq` if it exists.</span>

<span class="sd">    `freq_expr` should be an ArrayExpression of Structs with &#39;AC&#39; and &#39;AF&#39; annotations.</span>
<span class="sd">    This is the same format as the `freq` annotation that is created using</span>
<span class="sd">    `annotate_freq()`.</span>

<span class="sd">    Variant allele frequency information is needed when:</span>
<span class="sd">        - `max_af` is not None - `freq_expr[0].AF` is used to filter to only variants</span>
<span class="sd">          with a maximum allele frequency of `max_af` prior to counting variants. In</span>
<span class="sd">          the standard `freq` ArrayExpression annotated by `annotate_freq()`, this</span>
<span class="sd">          first element corresponds to the allele frequency information for high quality</span>
<span class="sd">          genotypes (adj).</span>
<span class="sd">        - `count_singletons` is True and `singleton_expr` is None - If singleton counts</span>
<span class="sd">          are requested and no expression is specified to determine whether a variant</span>
<span class="sd">          is a singleton, `singleton_expr` defaults to `freq_expr[0].AC == 1`. In the</span>
<span class="sd">          standard `freq` ArrayExpression annotated by `annotate_freq()`, this</span>
<span class="sd">          corresponds to allele count of only 1 in the callset after filtering to high</span>
<span class="sd">          quality genotypes.</span>
<span class="sd">        - `count_downsamplings` is not empty - When downsampling counts are requested,</span>
<span class="sd">          `freq_expr` needs to contain frequency information for downsamplings within</span>
<span class="sd">          each genetic ancestry group requested. In addition to needing `freq_expr`, this also</span>
<span class="sd">          requires the use of `freq_meta_expr`. If `freq_meta_expr` is None,</span>
<span class="sd">          `freq_meta_expr` it defaults to `ht.freq_meta` if it exists. Similar to</span>
<span class="sd">          `freq_expr`, `freq_meta_expr` is expected to have the same format as</span>
<span class="sd">          the `freq_meta` global annotation that is created using `annotate_freq()`.</span>
<span class="sd">          `freq_meta_expr` is used to determine the index of allele frequency</span>
<span class="sd">          information within `freq_expr` for each genetic ancestry group requested and it&#39;s</span>
<span class="sd">          downsamplings.</span>

<span class="sd">    This function will return a Table with annotations used for grouping (&#39;context&#39;,</span>
<span class="sd">    &#39;ref&#39;, &#39;alt&#39;, &#39;methylation_level&#39; (optional), `additional_grouping`) and</span>
<span class="sd">    &#39;variant_count&#39; annotation.</span>

<span class="sd">    .. note::</span>

<span class="sd">        The following annotations should be present in `ht`:</span>
<span class="sd">            - ref - the reference allele</span>
<span class="sd">            - alt - the alternate base</span>
<span class="sd">            - context - trinucleotide genomic context</span>
<span class="sd">            - methylation_level - methylation level (optional if omit_methylation==True)</span>
<span class="sd">            - freq - allele frequency information (AC, AN, AF, homozygote count; not</span>
<span class="sd">              required if `freq_expr` is given)</span>
<span class="sd">            - freq_meta - an ordered list containing the frequency aggregation group</span>
<span class="sd">              for each element of the `freq` array row annotation (not required if</span>
<span class="sd">              `freq_meta_expr` is given)</span>

<span class="sd">    :param ht: Input Hail Table.</span>
<span class="sd">    :param freq_expr: ArrayExpression of Structs with &#39;AC&#39; and &#39;AF&#39; annotations. If</span>
<span class="sd">        `freq_expr` is None and any of `count_downsamplings`, `max_af`, and</span>
<span class="sd">        `count_singletons` is True, `freq_expr` would be `ht.freq`.</span>
<span class="sd">    :param freq_meta_expr: ArrayExpression of meta dictionaries corresponding to</span>
<span class="sd">        `freq_expr`. If `count_downsamplings` and `freq_meta_expr` is None,</span>
<span class="sd">        `freq_meta_expr` would be `ht.freq_meta`.</span>
<span class="sd">    :param count_singletons: Whether to count singletons (defined by `singleton_expr`).</span>
<span class="sd">        Default is False.</span>
<span class="sd">    :param count_downsamplings: Tuple of genetic ancestry groups to use for downsampling counts.</span>
<span class="sd">        Default is ().</span>
<span class="sd">    :param downsamplings: Optional List of integers specifying what downsampling</span>
<span class="sd">        indices to obtain. Default is None, which will return all downsampling counts.</span>
<span class="sd">    :param additional_grouping: Additional features to group by. e.g. &#39;exome_coverage&#39;.</span>
<span class="sd">        Default is ().</span>
<span class="sd">    :param partition_hint: Target number of partitions for aggregation. Default is 100.</span>
<span class="sd">    :param omit_methylation: Whether to omit &#39;methylation_level&#39; from the grouping when</span>
<span class="sd">        counting variants. Default is False.</span>
<span class="sd">    :param use_table_group_by: Whether to group `ht` before aggregating the variant</span>
<span class="sd">        counts. If `use_table_group_by` is False, function will return a hl.</span>
<span class="sd">        StructExpression. Default is False.</span>
<span class="sd">    :param singleton_expr: Expression for defining a singleton. When `count_singletons`</span>
<span class="sd">        is True and `singleton_expr` is None, `singleton_expression` would be `freq_expr</span>
<span class="sd">        [0].AC == 1`. Default is None.</span>
<span class="sd">    :param max_af: Maximum variant allele frequency to keep. By default, no cutoff is</span>
<span class="sd">        applied.</span>
<span class="sd">    :return: Table including &#39;variant_count&#39; annotation and if requested,</span>
<span class="sd">        `singleton_count` and downsampling counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">freq_expr</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="p">(</span>
        <span class="n">count_downsamplings</span> <span class="ow">or</span> <span class="n">max_af</span> <span class="ow">or</span> <span class="p">(</span><span class="n">count_singletons</span> <span class="ow">and</span> <span class="n">singleton_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">)</span>
    <span class="p">):</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;freq_expr was not provided, using &#39;freq&#39; as the frequency annotation.&quot;</span>
        <span class="p">)</span>
        <span class="n">freq_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">freq</span>
    <span class="k">if</span> <span class="n">count_downsamplings</span> <span class="ow">and</span> <span class="n">freq_meta_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;freq_meta_expr was not provided, using &#39;freq_meta&#39; as the frequency&quot;</span>
            <span class="s2">&quot; metadata annotation.&quot;</span>
        <span class="p">)</span>
        <span class="n">freq_meta_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">freq_meta</span>
    <span class="k">if</span> <span class="n">count_singletons</span> <span class="ow">and</span> <span class="n">singleton_expr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;count_singletons is True and singleton_expr was not provided, using&quot;</span>
            <span class="s2">&quot; freq_expr[0].AC == 1 as the singleton expression.&quot;</span>
        <span class="p">)</span>
        <span class="n">singleton_expr</span> <span class="o">=</span> <span class="n">freq_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">1</span>

    <span class="n">grouping</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="n">ref</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">alt</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">omit_methylation</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;&#39;methylation_level&#39; annotation is included in the grouping when counting&quot;</span>
            <span class="s2">&quot; variants.&quot;</span>
        <span class="p">)</span>
        <span class="n">grouping</span> <span class="o">=</span> <span class="n">grouping</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">methylation_level</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">methylation_level</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">additional_grouping</span><span class="p">:</span>
        <span class="n">grouping</span> <span class="o">=</span> <span class="n">grouping</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">group</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">group</span><span class="p">]})</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
        <span class="s2">&quot;The following annotations will be used to group the input Table rows when&quot;</span>
        <span class="s2">&quot; counting variants: </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">grouping</span><span class="o">.</span><span class="n">keys</span><span class="p">()),</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">max_af</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;The maximum variant allele frequency to be included in `variant_count` is&quot;</span>
            <span class="s2">&quot; </span><span class="si">%.3f</span><span class="s2">.&quot;</span><span class="p">,</span>
            <span class="n">max_af</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">agg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variant_count&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span> <span class="o">&lt;=</span> <span class="n">max_af</span><span class="p">)}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">agg</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;variant_count&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count</span><span class="p">()}</span>

    <span class="k">if</span> <span class="n">count_singletons</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Counting singleton variants and adding as &#39;singleton_count&#39; annotation.&quot;</span>
        <span class="p">)</span>
        <span class="n">agg</span><span class="p">[</span><span class="s2">&quot;singleton_count&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count_where</span><span class="p">(</span><span class="n">singleton_expr</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">count_downsamplings</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s2">&quot;Counting variants in downsamplings for genetic ancestry group &#39;</span><span class="si">%s</span><span class="s2">&#39;, and adding as&quot;</span>
            <span class="s2">&quot; &#39;downsampling_counts_</span><span class="si">%s</span><span class="s2">&#39; annotation.&quot;</span><span class="p">,</span>
            <span class="n">gen_anc</span><span class="p">,</span>
            <span class="n">gen_anc</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">agg</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;downsampling_counts_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downsampling_counts_expr</span><span class="p">(</span>
            <span class="n">freq_expr</span><span class="p">,</span>
            <span class="n">freq_meta_expr</span><span class="p">,</span>
            <span class="n">gen_anc</span><span class="p">,</span>
            <span class="n">max_af</span><span class="o">=</span><span class="n">max_af</span><span class="p">,</span>
            <span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">count_singletons</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Counting singleton variants in downsamplings for genetic ancestry group &#39;</span><span class="si">%s</span><span class="s2">&#39;, and&quot;</span>
                <span class="s2">&quot; adding as &#39;singleton_downsampling_counts_</span><span class="si">%s</span><span class="s2">&#39; annotation.&quot;</span><span class="p">,</span>
                <span class="n">gen_anc</span><span class="p">,</span>
                <span class="n">gen_anc</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="n">agg</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;singleton_downsampling_counts_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">downsampling_counts_expr</span><span class="p">(</span>
                <span class="n">freq_expr</span><span class="p">,</span>
                <span class="n">freq_meta_expr</span><span class="p">,</span>
                <span class="n">gen_anc</span><span class="p">,</span>
                <span class="n">max_af</span><span class="o">=</span><span class="n">max_af</span><span class="p">,</span>
                <span class="n">downsamplings</span><span class="o">=</span><span class="n">downsamplings</span><span class="p">,</span>
                <span class="n">singleton</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>
    <span class="c1"># Apply each variant count aggregation in `agg` to get counts for all</span>
    <span class="c1"># combinations of `grouping`.</span>
    <span class="k">if</span> <span class="n">use_table_group_by</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="o">**</span><span class="n">grouping</span><span class="p">)</span><span class="o">.</span><span class="n">partition_hint</span><span class="p">(</span><span class="n">partition_hint</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="o">**</span><span class="n">agg</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">field</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">grouping</span><span class="p">,</span> <span class="n">agg</span><span class="p">[</span><span class="n">field</span><span class="p">])</span> <span class="k">for</span> <span class="n">field</span> <span class="ow">in</span> <span class="n">agg</span><span class="p">})</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="get_downsampling_freq_indices"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.get_downsampling_freq_indices">[docs]</a><span class="k">def</span> <span class="nf">get_downsampling_freq_indices</span><span class="p">(</span>
    <span class="n">freq_meta_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">gen_anc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
    <span class="n">variant_quality</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;adj&quot;</span><span class="p">,</span>
    <span class="n">genetic_ancestry_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get indices of dictionaries in meta dictionaries that only have the &quot;downsampling&quot; key with specified `genetic_ancestry_label` and &quot;variant_quality&quot; values.</span>

<span class="sd">    :param freq_meta_expr: ArrayExpression containing the set of groupings for each</span>
<span class="sd">        element of the `freq_expr` array (e.g., [{&#39;group&#39;: &#39;adj&#39;}, {&#39;group&#39;: &#39;adj&#39;,</span>
<span class="sd">        &#39;gen_anc&#39;: &#39;nfe&#39;}, {&#39;downsampling&#39;: &#39;5000&#39;, &#39;group&#39;: &#39;adj&#39;, &#39;gen_anc&#39;: &#39;global&#39;}]).</span>
<span class="sd">    :param gen_anc: Genetic ancestry group to use for filtering by the `genetic_ancestry_label` key in</span>
<span class="sd">        `freq_meta_expr`. Default is &#39;global&#39;.</span>
<span class="sd">    :param variant_quality: Variant quality to use for filtering by the &#39;group&#39; key in</span>
<span class="sd">        `freq_meta_expr`. Default is &#39;adj&#39;.</span>
<span class="sd">    :param genetic_ancestry_label: Label defining the genetic ancestry groups. If None,</span>
<span class="sd">        &quot;gen_anc&quot; or &quot;gen_anc&quot; is used (in that order of preference) if present. Default is</span>
<span class="sd">        None.</span>
<span class="sd">    :param subset: Subset to use for filtering by the &#39;subset&#39; key in `freq_meta_expr`.</span>
<span class="sd">        Default is None, which will return all downsampling indices without a &#39;subset&#39;</span>
<span class="sd">        key in `freq_meta_expr`.</span>
<span class="sd">    :param downsamplings: Optional List of integers specifying what downsampling</span>
<span class="sd">        indices to obtain. Default is None, which will return all downsampling indices.</span>
<span class="sd">    :return: ArrayExpression of indices of dictionaries in `freq_meta_expr` that only</span>
<span class="sd">        have the &quot;downsampling&quot; key with specified `genetic_ancestry_label` and</span>
<span class="sd">        &quot;variant_quality&quot; values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">genetic_ancestry_label</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gen_anc</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">,</span> <span class="s2">&quot;pop&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">gen_anc</span> <span class="o">=</span> <span class="p">[</span><span class="n">genetic_ancestry_label</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">_get_filter_expr</span><span class="p">(</span><span class="n">m</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">:</span>
        <span class="n">filter_expr</span> <span class="o">=</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;group&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">variant_quality</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">any</span><span class="p">([</span><span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">gen_anc</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">gen_anc</span><span class="p">]))</span>
            <span class="o">&amp;</span> <span class="n">m</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">downsamplings</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_expr</span> <span class="o">&amp;=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">downsamplings</span><span class="p">)</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;downsampling&quot;</span><span class="p">,</span> <span class="s2">&quot;0&quot;</span><span class="p">))</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filter_expr</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">m</span><span class="o">.</span><span class="n">contains</span><span class="p">(</span><span class="s2">&quot;subset&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">filter_expr</span> <span class="o">&amp;=</span> <span class="n">m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;subset&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="n">subset</span>
        <span class="k">return</span> <span class="n">filter_expr</span>

    <span class="n">indices</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">enumerate</span><span class="p">(</span><span class="n">freq_meta_expr</span><span class="p">)</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">_get_filter_expr</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

    <span class="c1"># Get an array of indices and meta dictionaries sorted by &quot;downsampling&quot; key.</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">sorted</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">f</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s2">&quot;downsampling&quot;</span><span class="p">]))</span></div>


<div class="viewcode-block" id="downsampling_counts_expr"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.downsampling_counts_expr">[docs]</a><span class="k">def</span> <span class="nf">downsampling_counts_expr</span><span class="p">(</span>
    <span class="n">freq_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">freq_meta_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">,</span>
    <span class="n">gen_anc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;global&quot;</span><span class="p">,</span>
    <span class="n">variant_quality</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;adj&quot;</span><span class="p">,</span>
    <span class="n">singleton</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">max_af</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">genetic_ancestry_label</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">subset</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">downsamplings</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return an aggregation expression to compute an array of counts of all downsamplings found in `freq_expr` where specified criteria is met.</span>

<span class="sd">    The frequency metadata (`freq_meta_expr`) should be in a similar format to the</span>
<span class="sd">    `freq_meta` annotation added by `annotate_freq()`. Each downsampling should have</span>
<span class="sd">    &#39;group&#39;, `genetic_ancestry_label`, and &#39;downsampling&#39; keys. Included downsamplings</span>
<span class="sd">    are those where &#39;group&#39; == `variant_quality` and `genetic_ancestry_label` == `gen_anc`.</span>

<span class="sd">    :param freq_expr: ArrayExpression of Structs with &#39;AC&#39; and &#39;AF&#39; annotations.</span>
<span class="sd">    :param freq_meta_expr: ArrayExpression containing the set of groupings for each</span>
<span class="sd">        element of the `freq_expr` array (e.g., [{&#39;group&#39;: &#39;adj&#39;}, {&#39;group&#39;: &#39;adj&#39;,</span>
<span class="sd">        &#39;gen_anc&#39;: &#39;nfe&#39;}, {&#39;downsampling&#39;: &#39;5000&#39;, &#39;group&#39;: &#39;adj&#39;, &#39;gen_anc&#39;: &#39;global&#39;}]).</span>
<span class="sd">    :param gen_anc: Genetic ancestry group to use for filtering by the `genetic_ancestry_label` key in</span>
<span class="sd">        `freq_meta_expr`. Default is &#39;global&#39;.</span>
<span class="sd">    :param variant_quality: Variant quality to use for filtering by the &#39;group&#39; key in</span>
<span class="sd">        `freq_meta_expr`. Default is &#39;adj&#39;.</span>
<span class="sd">    :param singleton: Whether to filter to only singletons before counting (AC == 1).</span>
<span class="sd">        Default is False.</span>
<span class="sd">    :param max_af: Maximum variant allele frequency to keep. By default no allele</span>
<span class="sd">        frequency cutoff is applied.</span>
<span class="sd">    :param genetic_ancestry_label: Label defining the genetic ancestry groups. If None,</span>
<span class="sd">        &quot;gen_anc&quot; or &quot;pop&quot; is used (in that order of preference) if present. Default is</span>
<span class="sd">        None.</span>
<span class="sd">    :param subset: Subset to use for filtering by the &#39;subset&#39; key in `freq_meta_expr`.</span>
<span class="sd">        Default is None, which will return all downsampling counts without a &#39;subset&#39;</span>
<span class="sd">        key in `freq_meta_expr`. If specified, only downsamplings with the specified</span>
<span class="sd">        subset will be included.</span>
<span class="sd">    :param downsamplings: Optional List of integers specifying what downsampling</span>
<span class="sd">        indices to obtain. Default is None, which will return all downsampling counts.</span>
<span class="sd">    :return: Aggregation Expression for an array of the variant counts in downsamplings</span>
<span class="sd">        for specified genetic ancestry group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Get an array of indices sorted by &quot;downsampling&quot; key.</span>
    <span class="n">sorted_indices</span> <span class="o">=</span> <span class="n">get_downsampling_freq_indices</span><span class="p">(</span>
        <span class="n">freq_meta_expr</span><span class="p">,</span>
        <span class="n">gen_anc</span><span class="p">,</span>
        <span class="n">variant_quality</span><span class="p">,</span>
        <span class="n">genetic_ancestry_label</span><span class="p">,</span>
        <span class="n">subset</span><span class="p">,</span>
        <span class="n">downsamplings</span><span class="p">,</span>
    <span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_criteria</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return 1 when variant meets specified criteria (`singleton` or `max_af`), if requested, or with an AC &gt; 0.</span>

<span class="sd">        :param i: The index of a downsampling.</span>
<span class="sd">        :return: Returns 1 if the variant in the downsampling with specified index met</span>
<span class="sd">            the criteria. Otherwise, returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">singleton</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">max_af</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">((</span><span class="n">freq_expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">freq_expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AF</span> <span class="o">&lt;=</span> <span class="n">max_af</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">int</span><span class="p">(</span><span class="n">freq_expr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">AC</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>

    <span class="c1"># Map `_get_criteria` function to each downsampling indexed by `sorted_indices` to</span>
    <span class="c1"># generate a list of 1&#39;s and 0&#39;s for each variant, where the length of the array is</span>
    <span class="c1"># the total number of downsamplings for the specified genetic ancestry group and each element</span>
    <span class="c1"># in the array indicates if the variant in the downsampling indexed by</span>
    <span class="c1"># `sorted_indices` meets the specified criteria.</span>
    <span class="c1"># Return an array sum aggregation that aggregates arrays generated from mapping.</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">_get_criteria</span><span class="p">,</span> <span class="n">sorted_indices</span><span class="p">))</span></div>


<div class="viewcode-block" id="explode_downsamplings_oe"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.explode_downsamplings_oe">[docs]</a><span class="k">def</span> <span class="nf">explode_downsamplings_oe</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">downsampling_meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span>
    <span class="n">metrics</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;syn&quot;</span><span class="p">,</span> <span class="s2">&quot;lof&quot;</span><span class="p">,</span> <span class="s2">&quot;mis&quot;</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Explode observed and expected downsampling counts for each genetic ancestry group and metric.</span>

<span class="sd">    The input `ht` must contain struct of downsampling information for genetic ancestry</span>
<span class="sd">    groups under each metric name. For example: &#39;lof&#39;: struct {gen_anc_exp: struct</span>
<span class="sd">    {global: array&lt;float64&gt;}.</span>

<span class="sd">    :param ht: Input Table.</span>
<span class="sd">    :param metrics: List of metrics to explode. Default is &#39;[&#39;syn&#39;, &#39;lof&#39;, &#39;mis&#39;]&#39;.</span>
<span class="sd">    :param downsampling_meta: Dictionary containing downsampling metadata. Keys are the</span>
<span class="sd">        genetic ancestry group names and values are the list of downsamplings for that</span>
<span class="sd">        genetic ancestry group. Example: {&#39;global&#39;: [&#39;5000&#39;, &#39;10000&#39;], &#39;afr&#39;: [&#39;5000&#39;,</span>
<span class="sd">        &#39;10000&#39;]}.</span>
<span class="sd">    :return: Table with downsampling counts exploded so that observed and expected</span>
<span class="sd">        metric counts for each pair of genetic ancestry groups and downsamplings is a</span>
<span class="sd">        separate row.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
        <span class="n">_data</span><span class="o">=</span><span class="p">[</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="n">gen_anc</span><span class="o">=</span><span class="n">gen_anc</span><span class="p">,</span>
                <span class="n">downsampling</span><span class="o">=</span><span class="n">downsampling</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">metric</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">oe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">ht</span><span class="p">[</span><span class="n">metric</span><span class="p">][</span><span class="sa">f</span><span class="s2">&quot;gen_anc_</span><span class="si">{</span><span class="n">oe</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">][</span><span class="n">gen_anc</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">oe</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">,</span> <span class="s2">&quot;exp&quot;</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">metric</span> <span class="ow">in</span> <span class="n">metrics</span>
                <span class="p">},</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">gen_anc</span><span class="p">,</span> <span class="n">downsamplings</span> <span class="ow">in</span> <span class="n">downsampling_meta</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">downsampling</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">downsamplings</span><span class="p">)</span>
        <span class="p">]</span>
    <span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="s2">&quot;_data&quot;</span><span class="p">)</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">transmute</span><span class="p">(</span><span class="o">**</span><span class="n">ht</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="annotate_mutation_type"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.annotate_mutation_type">[docs]</a><span class="k">def</span> <span class="nf">annotate_mutation_type</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
    <span class="n">context_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">num_scan_context_length</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate mutation types.</span>

<span class="sd">    The following annotations are added to the output Table:</span>
<span class="sd">        - cpg</span>
<span class="sd">        - transition</span>
<span class="sd">        - mutation_type - one of &quot;CpG&quot;, &quot;non-CpG transition&quot;, or &quot;transversion&quot;</span>
<span class="sd">        - mutation_type_model</span>

<span class="sd">    ..note:</span>

<span class="sd">        This function uses the term &#39;mutation_type&#39; because &#39;variant_type&#39; is already</span>
<span class="sd">        used in this repo to indicate a variant&#39;s multiallelic and SNP/indel status.</span>

<span class="sd">    :param t: Input Table or MatrixTable.</span>
<span class="sd">    :param context_length: Length of the &#39;context&#39; annotation in &#39;t&#39;. If this is not</span>
<span class="sd">        specified, the value will be determined by examining the first</span>
<span class="sd">        `num_scan_context_length` values of the &#39;context&#39; annotation. Default is None.</span>
<span class="sd">    :param num_scan_context_length: Number of values in the &#39;context&#39; annotation to use</span>
<span class="sd">        for determining `context_length` if it is not specified. If set to None, all</span>
<span class="sd">        values in &#39;context&#39; will be used. Default is 100.</span>
<span class="sd">    :return: Table with mutation type annotations added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">context_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># Determine the context length by collecting all the context lengths.</span>
        <span class="k">if</span> <span class="n">num_scan_context_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">context_lengths</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">collect_as_set</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">)))</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context_lengths</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">)</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">num_scan_context_length</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;the first </span><span class="si">{</span><span class="n">num_scan_context_length</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">context_lengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="nb">set</span><span class="p">(</span><span class="n">context_lengths</span><span class="p">)))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">context_lengths</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;More than one length was found among </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2"> &#39;context&#39; values. Length &quot;</span>
                <span class="s2">&quot;of &#39;context&#39; should be consistent.&quot;</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">context_length</span> <span class="o">=</span> <span class="n">context_lengths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s2">&quot;Detected a length of </span><span class="si">%d</span><span class="s2"> for context length using </span><span class="si">%s</span><span class="s2"> &#39;context&#39; values.&quot;</span><span class="p">,</span>
                <span class="n">context_length</span><span class="p">,</span>
                <span class="n">msg</span><span class="p">,</span>
            <span class="p">)</span>

    <span class="c1"># Determine the middle index of the context annotation.</span>
    <span class="k">if</span> <span class="n">context_length</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
        <span class="n">mid_index</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="k">elif</span> <span class="n">context_length</span> <span class="o">==</span> <span class="mi">7</span><span class="p">:</span>
        <span class="n">mid_index</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The length of context should be either 3 or 7, instead of&quot;</span>
            <span class="sa">f</span><span class="s2">&quot; </span><span class="si">{</span><span class="n">context_length</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="n">transition_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_transition</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ref</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">alt</span><span class="p">)</span>
    <span class="n">cpg_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alt</span> <span class="o">==</span> <span class="s2">&quot;A&quot;</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="n">mid_index</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">mid_index</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">|</span> <span class="p">(</span>
        <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="s2">&quot;C&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alt</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span>
        <span class="o">&amp;</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="n">mid_index</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:</span> <span class="n">mid_index</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">transition</span><span class="o">=</span><span class="n">transition_expr</span><span class="p">,</span> <span class="n">cpg</span><span class="o">=</span><span class="n">cpg_expr</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">transition</span><span class="o">=</span><span class="n">transition_expr</span><span class="p">,</span> <span class="n">cpg</span><span class="o">=</span><span class="n">cpg_expr</span><span class="p">)</span>
    <span class="n">mutation_type_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">switch</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">))</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span>
            <span class="n">context_length</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cpg</span><span class="p">,</span> <span class="s2">&quot;CpG&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">transition</span><span class="p">,</span> <span class="s2">&quot;non-CpG transition&quot;</span><span class="p">)</span>
            <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="s2">&quot;transversion&quot;</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="o">.</span><span class="n">or_error</span><span class="p">(</span><span class="s2">&quot;Found &#39;context&#39; value with unexpected context length!&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">mutation_type_model_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">cpg</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">,</span> <span class="s2">&quot;non-CpG&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span>
            <span class="n">mutation_type</span><span class="o">=</span><span class="n">mutation_type_expr</span><span class="p">,</span>
            <span class="n">mutation_type_model</span><span class="o">=</span><span class="n">mutation_type_model_expr</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
            <span class="n">mutation_type</span><span class="o">=</span><span class="n">mutation_type_expr</span><span class="p">,</span>
            <span class="n">mutation_type_model</span><span class="o">=</span><span class="n">mutation_type_model_expr</span><span class="p">,</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="trimer_from_heptamer"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.trimer_from_heptamer">[docs]</a><span class="k">def</span> <span class="nf">trimer_from_heptamer</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Trim heptamer context to create trimer context.</span>

<span class="sd">    :param t: Input MatrixTable or Table with context annotation.</span>
<span class="sd">    :return: MatrixTable or Table with trimer context annotated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">trimer_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">)</span> <span class="o">==</span> <span class="mi">7</span><span class="p">,</span> <span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">],</span> <span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">)</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">trimer_expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">context</span><span class="o">=</span><span class="n">trimer_expr</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="collapse_strand"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.collapse_strand">[docs]</a><span class="k">def</span> <span class="nf">collapse_strand</span><span class="p">(</span>
    <span class="n">t</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the deduplicated context by collapsing DNA strands.</span>

<span class="sd">    Function returns the reverse complement for &#39;ref, &#39;alt&#39;, and &#39;context&#39; if the</span>
<span class="sd">    reference allele is either &#39;G&#39; or &#39;T&#39;.</span>

<span class="sd">    The following annotations are added to the output Table:</span>
<span class="sd">        - was_flipped - whether the &#39;ref, &#39;alt&#39;, and &#39;context&#39; were flipped (reverse</span>
<span class="sd">          complement taken)</span>

<span class="sd">    :param ht: Input Table.</span>
<span class="sd">    :return: Table with deduplicated context annotation (ref, alt, context,</span>
<span class="sd">        was_flipped).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref_g_or_t_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="s2">&quot;G&quot;</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ref</span> <span class="o">==</span> <span class="s2">&quot;T&quot;</span><span class="p">)</span>
    <span class="n">collapse_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;ref&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">ref_g_or_t_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">ref</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">ref</span><span class="p">),</span>
        <span class="s2">&quot;alt&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">ref_g_or_t_expr</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">alt</span><span class="p">),</span> <span class="n">t</span><span class="o">.</span><span class="n">alt</span><span class="p">),</span>
        <span class="s2">&quot;context&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">ref_g_or_t_expr</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">reverse_complement</span><span class="p">(</span><span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">),</span>
            <span class="n">t</span><span class="o">.</span><span class="n">context</span><span class="p">,</span>
        <span class="p">),</span>
        <span class="s2">&quot;was_flipped&quot;</span><span class="p">:</span> <span class="n">ref_g_or_t_expr</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span>
        <span class="n">t</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">collapse_expr</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">)</span>
        <span class="k">else</span> <span class="n">t</span><span class="o">.</span><span class="n">annotate_rows</span><span class="p">(</span><span class="o">**</span><span class="n">collapse_expr</span><span class="p">)</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="transform_methylation_level"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.transform_methylation_level">[docs]</a><span class="k">def</span> <span class="nf">transform_methylation_level</span><span class="p">(</span>
    <span class="n">methylation_expr</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;methylation_level&quot;</span><span class="p">,</span>
    <span class="n">methylation_cutoffs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">NumericExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Transform methylation level into a 0 to 2 scale.</span>

<span class="sd">    The methylation level is transformed to a 0-2 scale based on the provided cutoffs.</span>
<span class="sd">    The methylation level is assigned a value of 2 if it is greater than the second</span>
<span class="sd">    cutoff, 1 if it is greater than the first cutoff (but less than or equal to the</span>
<span class="sd">    second), and 0 otherwise.</span>

<span class="sd">    :param methylation_expr: Methylation level expression or annotation name in `ht`. If</span>
<span class="sd">        `methylation_expr` is a string, `ht` must be provided.</span>
<span class="sd">    :param methylation_cutoffs: Tuple of two integers/floats representing the cutoffs</span>
<span class="sd">        for the methylation level transformation. Default is (0, 5).</span>
<span class="sd">    :param ht: Input Table. Default is None.</span>
<span class="sd">    :return: Table with methylation level annotation added or methylation level</span>
<span class="sd">        expression.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">methylation_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">ht</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;ht must be provided if methylation_expr is a string.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">methylation_expr</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
        <span class="n">methylation_expr</span> <span class="o">=</span> <span class="n">ht</span><span class="p">[</span><span class="n">methylation_expr</span><span class="p">]</span>

    <span class="n">methylation_expr</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">case</span><span class="p">()</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">methylation_expr</span> <span class="o">&gt;</span> <span class="n">methylation_cutoffs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="o">.</span><span class="n">when</span><span class="p">(</span><span class="n">methylation_expr</span> <span class="o">&gt;</span> <span class="n">methylation_cutoffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">.</span><span class="n">default</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="k">if</span> <span class="n">ht</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">methylation_level</span><span class="o">=</span><span class="n">methylation_expr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">methylation_expr</span></div>


<div class="viewcode-block" id="assemble_constraint_context_ht"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.assemble_constraint_context_ht">[docs]</a><span class="k">def</span> <span class="nf">assemble_constraint_context_ht</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">methylation_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">gerp_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">coverage_hts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">an_hts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">freq_hts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">filter_hts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">transformation_funcs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Assemble context Table with necessary annotations for constraint calculations.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Checks for &#39;was_split&#39; annotation in Table. If not present, splits</span>
<span class="sd">        multiallelic sites.</span>

<span class="sd">    The following annotations are added to the output Table:</span>

<span class="sd">        - ref: Reference allele.</span>
<span class="sd">        - alt: Alternate allele.</span>
<span class="sd">        - context: Trimer context.</span>
<span class="sd">        - annotations added by `annotate_mutation_type()`, `collapse_strand()`, and</span>
<span class="sd">          `add_most_severe_csq_to_tc_within_vep_root()`.</span>

<span class="sd">    Depending on the annotations provided, the following annotations may also be added:</span>

<span class="sd">        - &#39;methylation_level&#39;: Methylation level annotation will be added if</span>
<span class="sd">          `methylation_ht` is provided.</span>
<span class="sd">        - &#39;gerp&#39;: GERP annotation will be added if `gerp_ht` is provided.</span>
<span class="sd">        - &#39;coverage&#39;: Coverage annotations will be added if `coverage_hts` is provided.</span>
<span class="sd">        - &#39;AN&#39;: Allele number annotations will be added if `an_hts` is provided.</span>
<span class="sd">        - &#39;freq&#39;: Frequency annotations will be added if `freq_hts` is provided.</span>
<span class="sd">        - &#39;filters&#39;: Filter annotations will be added if `filter_hts` is provided.</span>

<span class="sd">    The `transformation_funcs` parameter can be used to transform the HTs before adding</span>
<span class="sd">    annotations. The keys should be the annotation names (&#39;coverage&#39;, &#39;gerp&#39;, etc.) and</span>
<span class="sd">    the values should be functions that take the annotation Table and the ht that is</span>
<span class="sd">    being annotated as input and return the transformed and keyed annotation. If not</span>
<span class="sd">    provided, the following default transformations are used:</span>

<span class="sd">        - &#39;methylation_level&#39;: Uses the &#39;methylation_level&#39; annotation in the</span>
<span class="sd">          Methylation Table after transforming the methylation level to a 0-2 scale</span>
<span class="sd">          using `transform_grch37_methylation()` or `transform_grch38_methylation()`.</span>
<span class="sd">        - &#39;gerp&#39;: Uses the &#39;S&#39; annotation in the GERP Table. If &#39;S&#39; is missing, it</span>
<span class="sd">          defaults to 0.</span>
<span class="sd">        - &#39;coverage&#39;: If necessary, pulls out the first element of coverage statistics</span>
<span class="sd">          (which includes all samples). Relevant to v4, where coverage stats include</span>
<span class="sd">          additional elements to stratify by UK Biobank subset and platforms.</span>
<span class="sd">        - &#39;AN&#39;: Uses the &#39;AN&#39; annotation in the allele number Table.</span>
<span class="sd">        - &#39;freq&#39;: Uses the &#39;freq&#39; annotation in the frequency Table.</span>
<span class="sd">        - &#39;filters&#39;: Uses the &#39;filters&#39; annotation in the filter Table.</span>

<span class="sd">    The following global annotations may also be added to the output Table:</span>

<span class="sd">        - &#39;an_globals&#39;: Global allele number annotations &#39;strata_sample_count&#39; and</span>
<span class="sd">          &#39;strata_meta&#39; will be added if `an_hts` is provided.</span>
<span class="sd">        - &#39;freq_globals&#39;: Global frequency annotations &#39;freq_meta_sample_count&#39; and</span>
<span class="sd">          &#39;freq_meta&#39; will be added if `freq_hts` is provided.</span>

<span class="sd">    :param ht: Input context Table with VEP annotation.</span>
<span class="sd">    :param methylation_ht: Optional Table with methylation annotation. Default is None.</span>
<span class="sd">    :param gerp_ht: Optional Table with GERP annotation. Default is None.</span>
<span class="sd">    :param coverage_hts: An optional Dictionary with key as one of &#39;exomes&#39; or</span>
<span class="sd">        &#39;genomes&#39; and values as corresponding coverage Tables. Default is None.</span>
<span class="sd">    :param an_hts: A Dictionary with key as one of &#39;exomes&#39; or &#39;genomes&#39; and</span>
<span class="sd">        values as corresponding allele number Tables. Default is None.</span>
<span class="sd">    :param transformation_funcs: An optional Dictionary to transform the HTs before</span>
<span class="sd">        adding annotations. Default is None, which will use some default transformations</span>
<span class="sd">        as described above.</span>
<span class="sd">    :return: Table with sites split and necessary annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ref</span> <span class="o">=</span> <span class="n">get_reference_genome</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">locus</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">ref</span> <span class="o">==</span> <span class="n">hl</span><span class="o">.</span><span class="n">get_reference</span><span class="p">(</span><span class="s2">&quot;GRCh37&quot;</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">gnomad.resources.grch37</span> <span class="kn">import</span> <span class="n">transform_grch37_methylation</span> <span class="k">as</span> <span class="n">trans_methyl</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">gnomad.resources.grch38</span> <span class="kn">import</span> <span class="n">transform_grch38_methylation</span> <span class="k">as</span> <span class="n">trans_methyl</span>

    <span class="c1"># Check if context Table is split, and if not, split multiallelic sites.</span>
    <span class="k">if</span> <span class="s2">&quot;was_split&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">row</span><span class="p">):</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">split_multi_hts</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="c1"># Only need to keep the keys (locus, alleles) and the context and vep annotations.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s2">&quot;context&quot;</span><span class="p">,</span> <span class="s2">&quot;vep&quot;</span><span class="p">)</span>

    <span class="c1"># Filter Table to only contigs 1-22, X, Y.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">filter_intervals</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">,</span> <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">parse_locus_interval</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="o">.</span><span class="n">name</span><span class="p">)</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">ref</span><span class="o">.</span><span class="n">contigs</span><span class="p">[:</span><span class="mi">24</span><span class="p">]]</span>
    <span class="p">)</span>

    <span class="c1"># Add annotations for &#39;ref&#39; and &#39;alt&#39;.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">ref</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alt</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">alleles</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Trim heptamer context to create trimer context.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">trimer_from_heptamer</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="c1"># Annotate mutation type (such as &quot;CpG&quot;, &quot;non-CpG transition&quot;, &quot;transversion&quot;) and</span>
    <span class="c1"># collapse strands to deduplicate the context.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">annotate_mutation_type</span><span class="p">(</span><span class="n">collapse_strand</span><span class="p">(</span><span class="n">ht</span><span class="p">))</span>

    <span class="c1"># Add most_severe_consequence annotation to &#39;transcript_consequences&#39; within the</span>
    <span class="c1"># vep root annotation.</span>
    <span class="n">csqs</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">vep</span><span class="o">.</span><span class="n">transcript_consequences</span>
    <span class="n">csqs</span> <span class="o">=</span> <span class="n">add_most_severe_consequence_to_consequence</span><span class="p">(</span><span class="n">csqs</span><span class="p">)</span>
    <span class="n">vep_csq_fields</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;transcript_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gene_id&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gene_symbol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;biotype&quot;</span><span class="p">,</span>
        <span class="s2">&quot;most_severe_consequence&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mane_select&quot;</span><span class="p">,</span>
        <span class="s2">&quot;canonical&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lof&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lof_flags&quot;</span><span class="p">,</span>
    <span class="p">]</span>
    <span class="n">vep_csq_fields</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">vep_csq_fields</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">csqs</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">element_type</span><span class="p">]</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">vep</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">vep</span><span class="o">.</span><span class="n">select</span><span class="p">(</span>
            <span class="s2">&quot;most_severe_consequence&quot;</span><span class="p">,</span>
            <span class="n">transcript_consequences</span><span class="o">=</span><span class="n">csqs</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">vep_csq_fields</span><span class="p">)),</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Add &#39;methylation_level&#39; and &#39;gerp&#39; annotations if specified.</span>
    <span class="n">transformation_funcs</span> <span class="o">=</span> <span class="n">transformation_funcs</span> <span class="ow">or</span> <span class="p">{}</span>

    <span class="k">if</span> <span class="s2">&quot;methylation_level&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation_funcs</span><span class="p">:</span>
        <span class="n">transformation_funcs</span><span class="p">[</span><span class="s2">&quot;methylation_level&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">ht</span><span class="o">.</span><span class="n">cpg</span><span class="p">,</span> <span class="n">trans_methyl</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">]</span><span class="o">.</span><span class="n">methylation_level</span><span class="p">,</span> <span class="mi">0</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;gerp&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation_funcs</span><span class="p">:</span>
        <span class="n">transformation_funcs</span><span class="p">[</span><span class="s2">&quot;gerp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_missing</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">]</span><span class="o">.</span><span class="n">S</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">]</span><span class="o">.</span><span class="n">S</span>
        <span class="p">)</span>

    <span class="c1"># If necessary, pull out first element of coverage statistics (which includes all</span>
    <span class="c1"># samples). Relevant to v4, where coverage stats include additional elements to</span>
    <span class="c1"># stratify by ukb subset and platforms.</span>
    <span class="k">if</span> <span class="s2">&quot;coverage&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation_funcs</span><span class="p">:</span>
        <span class="n">transformation_funcs</span><span class="p">[</span><span class="s2">&quot;coverage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="p">(</span>
            <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">]</span><span class="o">.</span><span class="n">coverage_stats</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="s2">&quot;coverage_stats&quot;</span> <span class="ow">in</span> <span class="n">x</span><span class="o">.</span><span class="n">row</span> <span class="k">else</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="s2">&quot;AN&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation_funcs</span><span class="p">:</span>
        <span class="n">transformation_funcs</span><span class="p">[</span><span class="s2">&quot;AN&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">locus</span><span class="p">]</span><span class="o">.</span><span class="n">AN</span>

    <span class="k">if</span> <span class="s2">&quot;freq&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation_funcs</span><span class="p">:</span>
        <span class="n">transformation_funcs</span><span class="p">[</span><span class="s2">&quot;freq&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">freq</span>

    <span class="k">if</span> <span class="s2">&quot;filters&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">transformation_funcs</span><span class="p">:</span>
        <span class="n">transformation_funcs</span><span class="p">[</span><span class="s2">&quot;filters&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="n">t</span><span class="o">.</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">filters</span>

    <span class="n">hts</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;methylation_level&quot;</span><span class="p">:</span> <span class="n">methylation_ht</span><span class="p">,</span>
        <span class="s2">&quot;gerp&quot;</span><span class="p">:</span> <span class="n">gerp_ht</span><span class="p">,</span>
        <span class="s2">&quot;coverage&quot;</span><span class="p">:</span> <span class="n">coverage_hts</span><span class="p">,</span>
        <span class="s2">&quot;AN&quot;</span><span class="p">:</span> <span class="n">an_hts</span><span class="p">,</span>
        <span class="s2">&quot;freq&quot;</span><span class="p">:</span> <span class="n">freq_hts</span><span class="p">,</span>
        <span class="s2">&quot;filters&quot;</span><span class="p">:</span> <span class="n">filter_hts</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">hts</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">hts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
    <span class="n">exprs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">ann</span><span class="p">,</span> <span class="n">ann_ht</span> <span class="ow">in</span> <span class="n">hts</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ann_ht</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">ann_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">transformation_funcs</span><span class="p">[</span><span class="n">ann</span><span class="p">](</span><span class="n">v</span><span class="p">,</span> <span class="n">ht</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">ann_ht</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ann_expr</span> <span class="o">=</span> <span class="n">transformation_funcs</span><span class="p">[</span><span class="n">ann</span><span class="p">](</span><span class="n">ann_ht</span><span class="p">,</span> <span class="n">ht</span><span class="p">)</span>

        <span class="n">exprs</span><span class="p">[</span><span class="n">ann</span><span class="p">]</span> <span class="o">=</span> <span class="n">ann_expr</span>

    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">exprs</span><span class="p">)</span>

    <span class="c1"># Add global annotations for &#39;AN&#39; and &#39;freq&#39; if HTs are provided.</span>
    <span class="n">global_anns</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;an_globals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">an_hts</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;strata_sample_count&quot;</span><span class="p">,</span> <span class="s2">&quot;strata_meta&quot;</span><span class="p">]),</span>
        <span class="s2">&quot;freq_globals&quot;</span><span class="p">:</span> <span class="p">(</span><span class="n">freq_hts</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;freq_meta_sample_count&quot;</span><span class="p">,</span> <span class="s2">&quot;freq_meta&quot;</span><span class="p">]),</span>
    <span class="p">}</span>
    <span class="n">global_anns</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">global_anns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">}</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate_globals</span><span class="p">(</span>
        <span class="o">**</span><span class="p">{</span>
            <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
                <span class="o">**</span><span class="p">{</span>
                    <span class="n">data_type</span><span class="p">:</span> <span class="n">ann_ht</span><span class="o">.</span><span class="n">select_globals</span><span class="p">(</span>
                        <span class="o">*</span><span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">g</span> <span class="k">if</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ann_ht</span><span class="o">.</span><span class="n">globals</span><span class="p">]</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">index_globals</span><span class="p">()</span>
                    <span class="k">for</span> <span class="n">data_type</span><span class="p">,</span> <span class="n">ann_ht</span> <span class="ow">in</span> <span class="n">hts</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
                <span class="p">}</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">hts</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="n">global_anns</span><span class="o">.</span><span class="n">items</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span></div>


<div class="viewcode-block" id="build_models"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.build_models">[docs]</a><span class="k">def</span> <span class="nf">build_models</span><span class="p">(</span>
    <span class="n">coverage_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">coverage_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span>
    <span class="n">weighted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">gen_ancs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">keys</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
        <span class="s2">&quot;context&quot;</span><span class="p">,</span>
        <span class="s2">&quot;ref&quot;</span><span class="p">,</span>
        <span class="s2">&quot;alt&quot;</span><span class="p">,</span>
        <span class="s2">&quot;methylation_level&quot;</span><span class="p">,</span>
        <span class="s2">&quot;mu_snp&quot;</span><span class="p">,</span>
    <span class="p">),</span>
    <span class="n">high_cov_definition</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">COVERAGE_CUTOFF</span><span class="p">,</span>
    <span class="n">upper_cov_cutoff</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">skip_coverage_model</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="n">log10_coverage</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Optional</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]],</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build coverage and plateau models.</span>

<span class="sd">    This function builds models (plateau_models) using linear regression to calibrate</span>
<span class="sd">    mutation rate estimates against the proportion observed of each substitution,</span>
<span class="sd">    context, and methylation level in `coverage_ht`.</span>

<span class="sd">    Two plateau models are fit, one for CpG transitions, and one for the remainder of</span>
<span class="sd">    sites (transversions and non CpG transitions).</span>

<span class="sd">    The plateau models only consider high coverage sites, or sites above a median</span>
<span class="sd">    coverage of `high_cov_definition` and median coverage below `upper_cov_cutoff`.</span>

<span class="sd">    Plateau model: adjusts proportion of expected variation based on location in the</span>
<span class="sd">    genome and CpG status.</span>
<span class="sd">    The x and y of the plateau models:</span>
<span class="sd">    - x: `mu_snp` - mutation rate</span>
<span class="sd">    - y: proportion observed (&#39;observed_variants&#39; or &#39;observed_{gen_anc}&#39; / &#39;possible_variants&#39;)</span>

<span class="sd">    This function also builds models (coverage models) to calibrate the proportion of</span>
<span class="sd">    expected variation at low coverage sites (sites below `high_cov_definition`).</span>

<span class="sd">    The coverage models are built by creating a scaling factor across all high coverage</span>
<span class="sd">    sites, applying this ratio to the low coverage sites, and running a linear</span>
<span class="sd">    regression.</span>

<span class="sd">    Coverage model: corrects proportion of expected variation at low coverage sites.</span>
<span class="sd">    Low coverage sites are defined as sites with median coverage &lt; `high_cov_definition`.</span>

<span class="sd">    The x and y of the coverage model:</span>
<span class="sd">    - x: log10 groupings of exome coverage at low coverage sites</span>
<span class="sd">    - y: sum(&#39;observed_variants&#39;)/ (`high_coverage_scale_factor` * sum(&#39;possible_variants&#39; * &#39;mu_snp&#39;) at low coverage sites</span>

<span class="sd">    `high_coverage_scale_factor` = sum(&#39;observed_variants&#39;) /</span>
<span class="sd">                        sum(&#39;possible_variants&#39; * &#39;mu_snp&#39;) at high coverage sites</span>

<span class="sd">    .. note::</span>

<span class="sd">        This function expects that the input Table(`coverage_ht`) was created using</span>
<span class="sd">        `get_proportion_observed_by_coverage`, which means that `coverage_ht` should</span>
<span class="sd">        contain only high quality synonymous variants below 0.1% frequency.</span>

<span class="sd">        This function also expects that the following fields are present in</span>
<span class="sd">        `coverage_ht`:</span>
<span class="sd">        - context - trinucleotide genomic context</span>
<span class="sd">        - ref - the reference allele</span>
<span class="sd">        - alt - the alternate allele</span>
<span class="sd">        - methylation_level - methylation level</span>
<span class="sd">        - cpg - whether the site is CpG site</span>
<span class="sd">        - observed_variants - the number of observed variants in the dataset for each</span>
<span class="sd">        variant. Note that the term &quot;variant&quot; here refers to a specific substitution,</span>
<span class="sd">        context, methylation level, and coverage combination</span>
<span class="sd">        - downsampling_counts_{gen_anc} (optional) - array of observed variant counts per</span>
<span class="sd">        genetic ancestry group after downsampling. Used only when `gen_ancs` is specified.</span>
<span class="sd">        - mu_snp - mutation rate</span>
<span class="sd">        - possible_variants - the number of possible variants in the dataset for each</span>
<span class="sd">        variant</span>

<span class="sd">    :param coverage_ht: Input coverage Table.</span>
<span class="sd">    :param coverage_expr: Expression that defines the coverage metric.</span>
<span class="sd">    :param weighted: Whether to weight the plateau models (a linear regression</span>
<span class="sd">        model) by &#39;possible_variants&#39;. Default is False.</span>
<span class="sd">    :param gen_ancs: List of genetic ancestry groups used to build plateau models.</span>
<span class="sd">        Default is ().</span>
<span class="sd">    :param keys: Annotations used to group observed and possible variant counts.</span>
<span class="sd">        Default is (&quot;context&quot;, &quot;ref&quot;, &quot;alt&quot;, &quot;methylation_level&quot;, &quot;mu_snp&quot;).</span>
<span class="sd">    :param high_cov_definition: Lower median coverage cutoff. Sites with coverage above this cutoff</span>
<span class="sd">        are considered well covered. Default is `COVERAGE_CUTOFF`.</span>
<span class="sd">    :param upper_cov_cutoff: Upper median coverage cutoff. Sites with coverage above this cutoff</span>
<span class="sd">        are excluded from the high coverage Table. Default is None.</span>
<span class="sd">    :param skip_coverage_model: Whether to skip generating the coverage model. If set to True,</span>
<span class="sd">        None is returned instead of the coverage model. Default is False.</span>
<span class="sd">    :param log10_coverage: Whether to convert coverage sites with log10 when building</span>
<span class="sd">        the coverage model. Default is True.</span>
<span class="sd">    :return: Coverage model and plateau models.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Annotate coverage_ht with coverage_expr set as a temporary annotation</span>
    <span class="c1"># &#39;_coverage_metric&#39; before modifying the coverage_ht.</span>
    <span class="n">coverage_ht</span> <span class="o">=</span> <span class="n">coverage_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">_coverage_metric</span><span class="o">=</span><span class="n">coverage_expr</span><span class="p">)</span>

    <span class="c1"># Filter to sites with coverage_expr equal to or above `high_cov_definition`.</span>
    <span class="n">high_cov_ht</span> <span class="o">=</span> <span class="n">coverage_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
        <span class="n">coverage_ht</span><span class="o">.</span><span class="n">_coverage_metric</span> <span class="o">&gt;=</span> <span class="n">high_cov_definition</span>
    <span class="p">)</span>

    <span class="c1"># Filter to sites with coverage_expr equal to or below `upper_cov_cutoff` if</span>
    <span class="c1"># specified.</span>
    <span class="k">if</span> <span class="n">upper_cov_cutoff</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">high_cov_ht</span> <span class="o">=</span> <span class="n">high_cov_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="n">high_cov_ht</span><span class="o">.</span><span class="n">_coverage_metric</span> <span class="o">&lt;=</span> <span class="n">upper_cov_cutoff</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;observed_variants&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">high_cov_ht</span><span class="o">.</span><span class="n">observed_variants</span><span class="p">),</span>
        <span class="s2">&quot;possible_variants&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">high_cov_ht</span><span class="o">.</span><span class="n">possible_variants</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">gen_ancs</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;observed_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">(</span>
            <span class="n">high_cov_ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;downsampling_counts_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># Generate a Table with all necessary annotations (x and y listed above)</span>
    <span class="c1"># for the plateau models.</span>
    <span class="n">high_cov_group_ht</span> <span class="o">=</span> <span class="n">high_cov_ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="o">*</span><span class="n">keys</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="o">**</span><span class="n">agg_expr</span><span class="p">)</span>
    <span class="n">high_cov_group_ht</span> <span class="o">=</span> <span class="n">annotate_mutation_type</span><span class="p">(</span><span class="n">high_cov_group_ht</span><span class="p">)</span>

    <span class="c1"># Build plateau models.</span>
    <span class="n">plateau_models_agg_expr</span> <span class="o">=</span> <span class="n">build_plateau_models</span><span class="p">(</span>
        <span class="n">cpg_expr</span><span class="o">=</span><span class="n">high_cov_group_ht</span><span class="o">.</span><span class="n">cpg</span><span class="p">,</span>
        <span class="n">mu_snp_expr</span><span class="o">=</span><span class="n">high_cov_group_ht</span><span class="o">.</span><span class="n">mu_snp</span><span class="p">,</span>
        <span class="n">observed_variants_expr</span><span class="o">=</span><span class="n">high_cov_group_ht</span><span class="o">.</span><span class="n">observed_variants</span><span class="p">,</span>
        <span class="n">possible_variants_expr</span><span class="o">=</span><span class="n">high_cov_group_ht</span><span class="o">.</span><span class="n">possible_variants</span><span class="p">,</span>
        <span class="n">gen_ancs_observed_variants_array_expr</span><span class="o">=</span><span class="p">[</span>
            <span class="n">high_cov_group_ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;observed_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">gen_ancs</span>
        <span class="p">],</span>
        <span class="n">weighted</span><span class="o">=</span><span class="n">weighted</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">gen_ancs</span><span class="p">:</span>
        <span class="c1"># Map the models to their corresponding genetic ancestry groups if</span>
        <span class="c1"># gen_ancs is specified.</span>
        <span class="n">_plateau_models</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">high_cov_group_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">plateau_models_agg_expr</span><span class="p">))</span>
        <span class="p">)</span>
        <span class="n">gen_anc_models</span> <span class="o">=</span> <span class="n">_plateau_models</span><span class="p">[</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">]</span>
        <span class="n">plateau_models</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">gen_anc</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">gen_anc_models</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">gen_ancs</span><span class="p">)</span>
        <span class="p">}</span>
        <span class="n">plateau_models</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_plateau_models</span><span class="p">[</span><span class="s2">&quot;total&quot;</span><span class="p">]</span>
        <span class="n">plateau_models</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">plateau_models</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plateau_models</span> <span class="o">=</span> <span class="n">high_cov_group_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">plateau_models_agg_expr</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_coverage_model</span><span class="p">:</span>
        <span class="c1"># Filter to sites with coverage below `high_cov_definition` and larger than 0.</span>
        <span class="n">low_cov_ht</span> <span class="o">=</span> <span class="n">coverage_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="p">(</span><span class="n">coverage_ht</span><span class="o">.</span><span class="n">_coverage_metric</span> <span class="o">&lt;</span> <span class="n">high_cov_definition</span><span class="p">)</span>
            <span class="o">&amp;</span> <span class="p">(</span><span class="n">coverage_ht</span><span class="o">.</span><span class="n">_coverage_metric</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Create a metric that represents the relative mutability of the exome calculated</span>
        <span class="c1"># on high coverage sites and will be used as scaling factor when building the</span>
        <span class="c1"># coverage model.</span>
        <span class="n">high_coverage_scale_factor</span> <span class="o">=</span> <span class="n">high_cov_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">high_cov_ht</span><span class="o">.</span><span class="n">observed_variants</span><span class="p">)</span>
            <span class="o">/</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">high_cov_ht</span><span class="o">.</span><span class="n">possible_variants</span> <span class="o">*</span> <span class="n">high_cov_ht</span><span class="o">.</span><span class="n">mu_snp</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Generate a Table with all necessary annotations (x and y listed above)</span>
        <span class="c1"># for the coverage model.</span>
        <span class="k">if</span> <span class="n">log10_coverage</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Converting coverage sites by log10.&quot;</span><span class="p">)</span>
            <span class="n">cov_value</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">low_cov_ht</span><span class="o">.</span><span class="n">_coverage_metric</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cov_value</span> <span class="o">=</span> <span class="n">low_cov_ht</span><span class="o">.</span><span class="n">_coverage_metric</span>

        <span class="n">low_cov_group_ht</span> <span class="o">=</span> <span class="n">low_cov_ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">cov_value</span><span class="o">=</span><span class="n">cov_value</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
            <span class="n">low_coverage_oe</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">low_cov_ht</span><span class="o">.</span><span class="n">observed_variants</span><span class="p">)</span>
            <span class="o">/</span> <span class="p">(</span>
                <span class="n">high_coverage_scale_factor</span>
                <span class="o">*</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">low_cov_ht</span><span class="o">.</span><span class="n">possible_variants</span> <span class="o">*</span> <span class="n">low_cov_ht</span><span class="o">.</span><span class="n">mu_snp</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Build the coverage model.</span>
        <span class="c1"># TODO: consider weighting here as well.</span>
        <span class="n">coverage_model_expr</span> <span class="o">=</span> <span class="n">build_coverage_model</span><span class="p">(</span>
            <span class="n">low_coverage_oe_expr</span><span class="o">=</span><span class="n">low_cov_group_ht</span><span class="o">.</span><span class="n">low_coverage_oe</span><span class="p">,</span>
            <span class="n">coverage_expr</span><span class="o">=</span><span class="n">low_cov_group_ht</span><span class="o">.</span><span class="n">cov_value</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">coverage_model</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">low_cov_group_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span><span class="n">coverage_model_expr</span><span class="p">)</span><span class="o">.</span><span class="n">beta</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">coverage_model</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">return</span> <span class="n">coverage_model</span><span class="p">,</span> <span class="n">plateau_models</span></div>


<div class="viewcode-block" id="build_plateau_models"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.build_plateau_models">[docs]</a><span class="k">def</span> <span class="nf">build_plateau_models</span><span class="p">(</span>
    <span class="n">cpg_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">mu_snp_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">observed_variants_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">,</span>
    <span class="n">possible_variants_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">,</span>
    <span class="n">gen_ancs_observed_variants_array_expr</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]</span> <span class="o">=</span> <span class="p">[],</span>
    <span class="n">weighted</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">bool</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">],</span> <span class="n">hl</span><span class="o">.</span><span class="n">ArrayExpression</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build plateau models to calibrate mutation rate to compute predicted proportion observed value.</span>

<span class="sd">    The x and y of the plateau models:</span>
<span class="sd">    - x: `mu_snp_expr`</span>
<span class="sd">    - y: `observed_variants_expr` / `possible_variants_expr`</span>
<span class="sd">    or `gen_ancs_observed_variants_array_expr`[index] / `possible_variants_expr`</span>
<span class="sd">    if `gen_ancs` is specified</span>

<span class="sd">    :param cpg_expr: BooleanExpression noting whether a site is a CPG site.</span>
<span class="sd">    :param mu_snp_expr: Float64Expression of the mutation rate.</span>
<span class="sd">    :param observed_variants_expr: Int64Expression of the observed variant counts.</span>
<span class="sd">    :param possible_variants_expr: Int64Expression of the possible variant counts.</span>
<span class="sd">    :param gen_ancs_observed_variants_array_expr: Nested ArrayExpression with all observed</span>
<span class="sd">        variant counts ArrayNumericExpressions for specified genetic ancestry groups. e.g., `[[1,1,</span>
<span class="sd">        1],[1,1,1]]`. Default is None.</span>
<span class="sd">    :param weighted: Whether to generalize the model to weighted least squares using</span>
<span class="sd">        &#39;possible_variants&#39;. Default is False.</span>
<span class="sd">    :return: A dictionary of intercepts and slopes of plateau models. The keys are</span>
<span class="sd">        &#39;total&#39; (for all sites) and &#39;gen_anc&#39; (optional; for genetic ancestry groups). The values for</span>
<span class="sd">        &#39;total&#39; is a dictionary (e.g., &lt;DictExpression of type dict&lt;bool,</span>
<span class="sd">        array&lt;float64&gt;&gt;&gt;), and the value for &#39;gen_anc&#39; is a nested list of dictionaries (e.</span>
<span class="sd">        g., &lt;ArrayExpression of type array&lt;array&lt;dict&lt;bool, array&lt;float64&gt;&gt;&gt;&gt;&gt;). The</span>
<span class="sd">        key of the dictionary in the nested list is CpG status (BooleanExpression), and</span>
<span class="sd">        the value is an ArrayExpression containing intercept and slope values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Build plateau models for all sites</span>
    <span class="n">plateau_models_agg_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;total&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
            <span class="n">cpg_expr</span><span class="p">,</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span>
                <span class="n">observed_variants_expr</span> <span class="o">/</span> <span class="n">possible_variants_expr</span><span class="p">,</span>
                <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mu_snp_expr</span><span class="p">],</span>
                <span class="n">weight</span><span class="o">=</span><span class="n">possible_variants_expr</span> <span class="k">if</span> <span class="n">weighted</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
            <span class="p">)</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">gen_ancs_observed_variants_array_expr</span><span class="p">:</span>
        <span class="c1"># Build plateau models using sites in genetic ancestry group downsamplings if</span>
        <span class="c1"># genetic ancestry group is specified.</span>
        <span class="n">plateau_models_agg_expr</span><span class="p">[</span><span class="s2">&quot;gen_anc&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">gen_anc_obs_var_array_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_agg</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">gen_anc_observed_variants</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span>
                    <span class="n">cpg_expr</span><span class="p">,</span>
                    <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span>
                        <span class="n">gen_anc_observed_variants</span> <span class="o">/</span> <span class="n">possible_variants_expr</span><span class="p">,</span>
                        <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">mu_snp_expr</span><span class="p">],</span>
                        <span class="n">weight</span><span class="o">=</span><span class="n">possible_variants_expr</span><span class="p">,</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">beta</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">gen_anc_obs_var_array_expr</span><span class="p">,</span>
            <span class="p">),</span>
            <span class="n">gen_ancs_observed_variants_array_expr</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">plateau_models_agg_expr</span></div>


<div class="viewcode-block" id="build_coverage_model"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.build_coverage_model">[docs]</a><span class="k">def</span> <span class="nf">build_coverage_model</span><span class="p">(</span>
    <span class="n">low_coverage_oe_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">coverage_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Build coverage model.</span>

<span class="sd">    This function uses linear regression to build a model of coverage to correct</span>
<span class="sd">    proportion of expected variation at low coverage sites.</span>

<span class="sd">    The x and y of the coverage model:</span>
<span class="sd">    - x: `coverage_expr`</span>
<span class="sd">    - y: `low_coverage_oe_expr`</span>

<span class="sd">    :param low_coverage_oe_expr: The Float64Expression of observed:expected ratio</span>
<span class="sd">        for a given coverage level.</span>
<span class="sd">    :param coverage_expr: The Float64Expression of the coverage expression.</span>
<span class="sd">    :return: StructExpression with intercept and slope of the model.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">linreg</span><span class="p">(</span><span class="n">low_coverage_oe_expr</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="n">coverage_expr</span><span class="p">])</span></div>


<div class="viewcode-block" id="get_all_gen_anc_lengths"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.get_all_gen_anc_lengths">[docs]</a><span class="k">def</span> <span class="nf">get_all_gen_anc_lengths</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">gen_ancs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
    <span class="n">obs_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get the minimum length of observed variant counts array for each genetic ancestry group downsampling.</span>

<span class="sd">    The observed variant counts for each genetic ancestry group in `gen_ancs` are specified by</span>
<span class="sd">    annotations on the `obs_expr` expression.</span>

<span class="sd">    The function also performs a check that arrays of variant counts within genetic ancestry group</span>
<span class="sd">    downsamplings all have the same lengths.</span>

<span class="sd">    :param ht: Input Table containing `obs_expr`.</span>
<span class="sd">    :param gen_ancs: Genetic ancestry groups used to categorize observed variant counts in downsamplings.</span>
<span class="sd">    :param obs_expr: Expression for the genetic ancestry group observed variant counts. Should be a</span>
<span class="sd">        struct containing an array for each gen_anc in `gen_ancs`.</span>
<span class="sd">    :return: A Dictionary with the minimum array length for each genetic ancestry group.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># TODO: This function will be converted into doing just the length check if there</span>
    <span class="c1">#  is no usage of gen_anc_lengths in the constraint pipeline.</span>
    <span class="c1"># Get minimum length of downsamplings for each genetic ancestry group.</span>
    <span class="n">gen_anc_downsampling_lengths</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">obs_expr</span><span class="p">[</span><span class="n">gen_anc</span><span class="p">]))</span> <span class="k">for</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">gen_ancs</span><span class="p">]</span>
    <span class="p">)</span>

    <span class="c1"># Zip genetic ancestry group name with their downsampling length.</span>
    <span class="n">gen_anc_lengths</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">gen_anc_downsampling_lengths</span><span class="p">,</span> <span class="n">gen_ancs</span><span class="p">))</span>
    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Found: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">gen_anc_lengths</span><span class="p">)))</span>

    <span class="k">assert</span> <span class="n">ht</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
        <span class="n">hl</span><span class="o">.</span><span class="n">all</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span>
            <span class="p">[</span>
                <span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">obs_expr</span><span class="p">[</span><span class="n">gen_anc</span><span class="p">])</span> <span class="o">==</span> <span class="n">length</span>
                <span class="k">for</span> <span class="n">length</span><span class="p">,</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">gen_anc_lengths</span>
            <span class="p">],</span>
        <span class="p">)</span>
    <span class="p">),</span> <span class="p">(</span>
        <span class="s2">&quot;The arrays of variant counts within genetic ancestry group downsamplings have different&quot;</span>
        <span class="s2">&quot; lengths!&quot;</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">gen_anc_lengths</span></div>


<div class="viewcode-block" id="get_constraint_grouping_expr"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.get_constraint_grouping_expr">[docs]</a><span class="k">def</span> <span class="nf">get_constraint_grouping_expr</span><span class="p">(</span>
    <span class="n">vep_annotation_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
    <span class="n">coverage_expr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">include_transcript_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_canonical_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_mane_select_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Collect annotations used for constraint groupings.</span>

<span class="sd">    Function collects the following annotations:</span>
<span class="sd">        - annotation - &#39;most_severe_consequence&#39; annotation in `vep_annotation_expr`</span>
<span class="sd">        - modifier - classic lof annotation from &#39;lof&#39; annotation in</span>
<span class="sd">            `vep_annotation_expr`, LOFTEE annotation from &#39;lof&#39; annotation in</span>
<span class="sd">            `vep_annotation_expr`, PolyPhen annotation from &#39;polyphen_prediction&#39; in</span>
<span class="sd">            `vep_annotation_expr`, or &quot;None&quot; if neither is defined</span>
<span class="sd">        - gene - &#39;gene_symbol&#39; annotation inside `vep_annotation_expr`</span>
<span class="sd">        - coverage - exome coverage if `coverage_expr` is specified</span>
<span class="sd">        - transcript - id from &#39;transcript_id&#39; in `vep_annotation_expr` (added when</span>
<span class="sd">            `include_transcript_group` is True)</span>
<span class="sd">        - canonical from `vep_annotation_expr` (added when `include_canonical_group` is</span>
<span class="sd">            True)</span>
<span class="sd">        - mane_select from `vep_annotation_expr` (added when `include_mane_select_group` is</span>
<span class="sd">            True)</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function expects that the following fields are present in</span>
<span class="sd">        `vep_annotation_expr`:</span>
<span class="sd">        - lof</span>
<span class="sd">        - polyphen_prediction</span>
<span class="sd">        - most_severe_consequence</span>
<span class="sd">        - gene_symbol</span>
<span class="sd">        - transcript_id (if `include_transcript_group` is True)</span>
<span class="sd">        - canonical (if `include_canonical_group` is True)</span>
<span class="sd">        - mane_select (if `include_mane_select_group` is True)</span>

<span class="sd">    :param vep_annotation_expr: StructExpression of VEP annotation.</span>
<span class="sd">    :param coverage_expr: Optional Int32Expression of exome coverage. Default is None.</span>
<span class="sd">    :param include_transcript_group: Whether to include the transcript annotation in the</span>
<span class="sd">        groupings. Default is True.</span>
<span class="sd">    :param include_canonical_group: Whether to include canonical annotation in the</span>
<span class="sd">        groupings. Default is True.</span>
<span class="sd">    :param include_mane_select_group: Whether to include mane_select annotation in the</span>
<span class="sd">        groupings. Default is False.</span>

<span class="sd">    :return: A dictionary with keys as annotation names and values as actual</span>
<span class="sd">        annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lof_expr</span> <span class="o">=</span> <span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">lof</span>
    <span class="n">polyphen_prediction_expr</span> <span class="o">=</span> <span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">polyphen_prediction</span>

    <span class="c1"># Create constraint annotations to be used for groupings.</span>
    <span class="n">groupings</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">most_severe_consequence</span><span class="p">,</span>
        <span class="s2">&quot;modifier&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="n">lof_expr</span><span class="p">,</span> <span class="n">polyphen_prediction_expr</span><span class="p">,</span> <span class="s2">&quot;None&quot;</span><span class="p">),</span>
        <span class="s2">&quot;gene&quot;</span><span class="p">:</span> <span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">gene_symbol</span><span class="p">,</span>
        <span class="s2">&quot;gene_id&quot;</span><span class="p">:</span> <span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">gene_id</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="n">coverage_expr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">groupings</span><span class="p">[</span><span class="s2">&quot;coverage&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">coverage_expr</span>

    <span class="c1"># Add &#39;transcript&#39; and &#39;canonical&#39; annotation if requested.</span>
    <span class="k">if</span> <span class="n">include_transcript_group</span><span class="p">:</span>
        <span class="n">groupings</span><span class="p">[</span><span class="s2">&quot;transcript&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">transcript_id</span>
    <span class="k">if</span> <span class="n">include_canonical_group</span><span class="p">:</span>
        <span class="n">groupings</span><span class="p">[</span><span class="s2">&quot;canonical&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">canonical</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">include_mane_select_group</span><span class="p">:</span>
        <span class="n">groupings</span><span class="p">[</span><span class="s2">&quot;mane_select&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span>
            <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">vep_annotation_expr</span><span class="o">.</span><span class="n">mane_select</span><span class="p">),</span> <span class="kc">False</span>
        <span class="p">)</span>

    <span class="k">return</span> <span class="n">groupings</span></div>


<div class="viewcode-block" id="annotate_exploded_vep_for_constraint_groupings"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.annotate_exploded_vep_for_constraint_groupings">[docs]</a><span class="k">def</span> <span class="nf">annotate_exploded_vep_for_constraint_groupings</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">coverage_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int32Expression</span><span class="p">,</span>
    <span class="n">vep_annotation</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;transcript_consequences&quot;</span><span class="p">,</span>
    <span class="n">include_canonical_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">include_mane_select_group</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">MatrixTable</span><span class="p">],</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Annotate Table with annotations used for constraint groupings.</span>

<span class="sd">    Function explodes the specified VEP annotation (`vep_annotation`) and adds the following annotations:</span>
<span class="sd">        - annotation -&#39;most_severe_consequence&#39; annotation in `vep_annotation`</span>
<span class="sd">        - modifier - classic lof annotation from &#39;lof&#39; annotation in</span>
<span class="sd">            `vep_annotation`, LOFTEE annotation from &#39;lof&#39; annotation in</span>
<span class="sd">            `vep_annotation`, PolyPhen annotation from &#39;polyphen_prediction&#39; in</span>
<span class="sd">            `vep_annotation`, or &quot;None&quot; if neither is defined</span>
<span class="sd">        - gene - &#39;gene_symbol&#39; annotation inside `vep_annotation`</span>
<span class="sd">        - transcript - id from &#39;transcript_id&#39; in `vep_annotation` (added when</span>
<span class="sd">            `include_transcript_group` is True)</span>
<span class="sd">        - canonical from `vep_annotation` (added when `include_canonical_group` is</span>
<span class="sd">            True)</span>
<span class="sd">        - mane_select from `vep_annotation` (added when `include_mane_select_group` is</span>
<span class="sd">            True)</span>

<span class="sd">    .. note::</span>
<span class="sd">        This function expects that the following annotations are present in `ht`:</span>
<span class="sd">        - vep</span>
<span class="sd">        - exome_coverage</span>

<span class="sd">    :param ht: Input Table or MatrixTable.</span>
<span class="sd">    :param coverage_expr: Expression that defines the coverage metric.</span>
<span class="sd">    :param vep_annotation: Name of annotation in &#39;vep&#39; annotation (one of</span>
<span class="sd">        &quot;transcript_consequences&quot; and &quot;worst_csq_by_gene&quot;) that will be used for</span>
<span class="sd">        obtaining constraint annotations. Default is &quot;transcript_consequences&quot;.</span>
<span class="sd">    :param include_canonical_group: Whether to include &#39;canonical&#39; annotation in the</span>
<span class="sd">        groupings. Default is True. Ignored unless `vep_annotation` is  &quot;transcript_consequences&quot;.</span>
<span class="sd">    :param include_mane_select_group: Whether to include &#39;mane_select&#39; annotation in the</span>
<span class="sd">        groupings. Default is False. Ignored unless `vep_annotation` is  &quot;transcript_consequences&quot;.</span>
<span class="sd">    :return: A tuple of input Table or MatrixTable with grouping annotations added and</span>
<span class="sd">        the names of added annotations.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Annotate ht with coverage_expr set as a temporary annotation &#39;_coverage_metric&#39;</span>
    <span class="c1"># before modifying ht.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">_coverage_metric</span><span class="o">=</span><span class="n">coverage_expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">vep_annotation</span> <span class="o">==</span> <span class="s2">&quot;transcript_consequences&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">include_canonical_group</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">include_mane_select_group</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;If &#39;vep_annotation&#39; is &#39;transcript_consequences&#39;, one of either&quot;</span>
                <span class="s2">&quot; &#39;include_canonical_group&#39; or &#39;include_mane_select_group&#39; must be set!&quot;</span>
            <span class="p">)</span>
        <span class="n">include_transcript_group</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
            <span class="s2">&quot;Setting both &#39;include_canonical_group&#39; and &#39;include_mane_select_group&#39; to&quot;</span>
            <span class="s2">&quot; False (options cannot be used unless &#39;vep_annotation&#39; is&quot;</span>
            <span class="s2">&quot; &#39;transcript_consequences&#39;).&quot;</span>
        <span class="p">)</span>
        <span class="n">include_transcript_group</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">include_canonical_group</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">include_mane_select_group</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="c1"># Annotate &#39;worst_csq_by_gene&#39; to `ht` if it&#39;s specified for `vep_annotation`.</span>
    <span class="k">if</span> <span class="n">vep_annotation</span> <span class="o">==</span> <span class="s2">&quot;worst_csq_by_gene&quot;</span><span class="p">:</span>
        <span class="n">ht</span> <span class="o">=</span> <span class="n">process_consequences</span><span class="p">(</span><span class="n">ht</span><span class="p">)</span>

    <span class="c1"># Explode the specified VEP annotation.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">explode_by_vep_annotation</span><span class="p">(</span><span class="n">ht</span><span class="p">,</span> <span class="n">vep_annotation</span><span class="p">)</span>

    <span class="c1"># Collect the annotations used for groupings.</span>
    <span class="n">groupings</span> <span class="o">=</span> <span class="n">get_constraint_grouping_expr</span><span class="p">(</span>
        <span class="n">ht</span><span class="p">[</span><span class="n">vep_annotation</span><span class="p">],</span>
        <span class="n">coverage_expr</span><span class="o">=</span><span class="n">ht</span><span class="o">.</span><span class="n">_coverage_metric</span><span class="p">,</span>
        <span class="n">include_transcript_group</span><span class="o">=</span><span class="n">include_transcript_group</span><span class="p">,</span>
        <span class="n">include_canonical_group</span><span class="o">=</span><span class="n">include_canonical_group</span><span class="p">,</span>
        <span class="n">include_mane_select_group</span><span class="o">=</span><span class="n">include_mane_select_group</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="k">return</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">groupings</span><span class="p">),</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">groupings</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span></div>


<div class="viewcode-block" id="compute_expected_variants"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.compute_expected_variants">[docs]</a><span class="k">def</span> <span class="nf">compute_expected_variants</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">plateau_models_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">,</span>
    <span class="n">mu_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">cov_corr_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">possible_variants_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">,</span>
    <span class="n">cpg_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">gen_anc</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">hl</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">]]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply plateau models for all sites and for a genetic ancestry group (if specified) to compute predicted proportion observed ratio and expected variant counts.</span>

<span class="sd">    :param ht: Input Table.</span>
<span class="sd">    :param plateau_models_expr: Linear models (output of `build_models()`, with the values</span>
<span class="sd">        of the dictionary formatted as a StructExpression of intercept and slope, that</span>
<span class="sd">        calibrates mutation rate to proportion observed for high coverage exomes. It</span>
<span class="sd">        includes models for CpG, non-CpG sites, and each genetic ancestry group if specified.</span>
<span class="sd">    :param mu_expr: Float64Expression of mutation rate.</span>
<span class="sd">    :param possible_variants_expr: Int64Expression of possible variant counts.</span>
<span class="sd">    :param cov_corr_expr: Float64Expression of corrected coverage expression.</span>
<span class="sd">    :param cpg_expr: BooleanExpression noting whether a site is a CPG site.</span>
<span class="sd">    :param gen_anc: Optional genetic ancestry group to use when applying plateau model. Default is</span>
<span class="sd">        None.</span>
<span class="sd">    :return: A dictionary with predicted proportion observed ratio and expected variant</span>
<span class="sd">        counts.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">gen_anc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">gen_anc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">plateau_model</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">plateau_models_expr</span><span class="o">.</span><span class="n">total</span><span class="p">)[</span><span class="n">cpg_expr</span><span class="p">]</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">plateau_model</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">intercept</span> <span class="o">=</span> <span class="n">plateau_model</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">agg_func</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span>
        <span class="n">ann_to_sum</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;observed_variants&quot;</span><span class="p">,</span> <span class="s2">&quot;possible_variants&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">plateau_model</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">literal</span><span class="p">(</span><span class="n">plateau_models_expr</span><span class="p">[</span><span class="n">gen_anc</span><span class="p">])</span>
        <span class="n">slope</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="n">cpg_expr</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">plateau_model</span><span class="p">)</span>
        <span class="n">intercept</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">f</span><span class="p">:</span> <span class="n">f</span><span class="p">[</span><span class="n">cpg_expr</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">plateau_model</span><span class="p">)</span>
        <span class="n">agg_func</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span>
        <span class="n">gen_anc</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">ann_to_sum</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;downsampling_counts</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">]</span>

    <span class="c1"># Apply plateau models for specified genetic ancestry group.</span>
    <span class="n">ppo_expr</span> <span class="o">=</span> <span class="n">mu_expr</span> <span class="o">*</span> <span class="n">slope</span> <span class="o">+</span> <span class="n">intercept</span>

    <span class="c1"># Generate sum aggregators for &#39;predicted_proportion_observed&#39; and</span>
    <span class="c1"># &#39;expected_variants&#39;, for specified genetic ancestry group.</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s2">&quot;predicted_proportion_observed</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">ppo_expr</span><span class="p">),</span>
        <span class="sa">f</span><span class="s2">&quot;expected_variants</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span>
            <span class="n">ppo_expr</span> <span class="o">*</span> <span class="n">cov_corr_expr</span> <span class="o">*</span> <span class="n">possible_variants_expr</span>
        <span class="p">),</span>
    <span class="p">}</span>

    <span class="c1"># Generate sum aggregators for &#39;observed_variants&#39; and &#39;possible_variants&#39; on</span>
    <span class="c1"># the entire dataset if gen_anc is None, and for &#39;downsampling_counts&#39; for</span>
    <span class="c1"># specified genetic ancestry group if gen_anc is not None.</span>
    <span class="n">agg_expr</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">ann</span><span class="p">:</span> <span class="n">agg_func</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="n">ann</span><span class="p">])</span> <span class="k">for</span> <span class="n">ann</span> <span class="ow">in</span> <span class="n">ann_to_sum</span><span class="p">})</span>

    <span class="k">return</span> <span class="n">agg_expr</span></div>


<div class="viewcode-block" id="oe_aggregation_expr"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.oe_aggregation_expr">[docs]</a><span class="k">def</span> <span class="nf">oe_aggregation_expr</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">filter_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">BooleanExpression</span><span class="p">,</span>
    <span class="n">gen_ancs</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">(),</span>
    <span class="n">exclude_mu_sum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get aggregation expressions to compute the observed:expected ratio for rows defined by `filter_expr`.</span>

<span class="sd">    Return a Struct containing aggregation expressions to sum the number of observed</span>
<span class="sd">    variants, possible variants, expected variants, and mutation rate (if</span>
<span class="sd">    `exclude_mu_sum` is not True) for rows defined by `filter_expr`. The Struct also</span>
<span class="sd">    includes an aggregation expression for the observed:expected ratio.</span>

<span class="sd">    The following annotations are in the returned StructExpression:</span>
<span class="sd">        - obs - the sum of observed variants filtered to `filter_expr`.</span>
<span class="sd">        - mu - the sum of mutation rate of variants filtered to `filter_expr`.</span>
<span class="sd">        - possible - possible number of variants filtered to `filter_expr`.</span>
<span class="sd">        - exp - expected number of variants filtered to `filter_expr`.</span>
<span class="sd">        - oe - observed:expected ratio of variants filtered to `filter_expr`.</span>

<span class="sd">        If `gen_ancs` is specified:</span>
<span class="sd">            - gen_anc_exp - Struct with the expected number of variants per genetic ancestry group (for</span>
<span class="sd">              all gen_anc in `gen_ancs`) filtered to `filter_expr`.</span>
<span class="sd">            - gen_anc_obs - Struct with the observed number of variants per genetic ancestry group (for</span>
<span class="sd">              all gen_anc in `gen_ancs`) filtered to `filter_expr`.</span>

<span class="sd">    .. note::</span>
<span class="sd">        The following annotations should be present in `ht`:</span>
<span class="sd">            - observed_variants</span>
<span class="sd">            - mu</span>
<span class="sd">            - possible_variants</span>
<span class="sd">            - expected_variants</span>
<span class="sd">        If `gen_ancs` is specified, the following annotations should also be present:</span>
<span class="sd">            - expected_variants_{gen_anc} for all gen_anc in `gen_ancs`</span>
<span class="sd">            - downsampling_counts_{gen_anc} for all gen_anc in `gen_ancs`</span>

<span class="sd">    :param ht: Input Table to create observed:expected ratio aggregation expressions for.</span>
<span class="sd">    :param filter_expr: Boolean expression used to filter `ht` before aggregation.</span>
<span class="sd">    :param gen_ancs: List of genetic ancestry groups to compute constraint metrics for. Default is ().</span>
<span class="sd">    :param exclude_mu_sum: Whether to exclude mu sum aggregation expression from</span>
<span class="sd">        returned struct. Default is False.</span>
<span class="sd">    :return: StructExpression with observed:expected ratio aggregation expressions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create aggregators that sum the number of observed variants, possible variants,</span>
    <span class="c1"># and expected variants and compute observed:expected ratio.</span>
    <span class="n">agg_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;obs&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">observed_variants</span><span class="p">),</span>
        <span class="s2">&quot;exp&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">expected_variants</span><span class="p">),</span>
        <span class="s2">&quot;possible&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">possible_variants</span><span class="p">),</span>
    <span class="p">}</span>
    <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;oe&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">divide_null</span><span class="p">(</span><span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;obs&quot;</span><span class="p">],</span> <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;exp&quot;</span><span class="p">])</span>

    <span class="c1"># Create an aggregator that sums the mutation rate.</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">exclude_mu_sum</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;mu&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ht</span><span class="o">.</span><span class="n">mu</span><span class="p">)</span>

    <span class="c1"># Create aggregators that sum the number of observed variants</span>
    <span class="c1"># and expected variants for each genetic ancestry group if gen_ancs is specified.</span>
    <span class="k">if</span> <span class="n">gen_ancs</span><span class="p">:</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;gen_anc_exp&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">gen_anc</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;expected_variants_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">gen_ancs</span>
            <span class="p">}</span>
        <span class="p">)</span>
        <span class="n">agg_expr</span><span class="p">[</span><span class="s2">&quot;gen_anc_obs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
            <span class="o">**</span><span class="p">{</span>
                <span class="n">gen_anc</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">array_sum</span><span class="p">(</span><span class="n">ht</span><span class="p">[</span><span class="sa">f</span><span class="s2">&quot;downsampling_counts_</span><span class="si">{</span><span class="n">gen_anc</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">gen_anc</span> <span class="ow">in</span> <span class="n">gen_ancs</span>
            <span class="p">}</span>
        <span class="p">)</span>

    <span class="n">agg_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="n">agg_expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">filter_expr</span><span class="p">,</span> <span class="n">agg_expr</span><span class="p">)</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">missing</span><span class="p">(</span><span class="n">agg_expr</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span></div>


<div class="viewcode-block" id="compute_pli"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.compute_pli">[docs]</a><span class="k">def</span> <span class="nf">compute_pli</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">obs_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">,</span>
    <span class="n">exp_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">expected_values</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">min_diff_convergence</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the pLI score using the observed and expected variant counts.</span>

<span class="sd">    Full details on pLI can be found in the ExAC paper: Lek, M., Karczewski, K.,</span>
<span class="sd">    Minikel, E. et al. Analysis of protein-coding genetic variation in 60,706 humans.</span>
<span class="sd">    Nature 536, 285–291 (2016).</span>

<span class="sd">    pLI is the probability of being loss-of-function intolerant, and this function</span>
<span class="sd">    computes that probability using the expectation-maximization (EM) algorithm.</span>

<span class="sd">    We assume a 3 state model, where each gene fits into one of three categories</span>
<span class="sd">    with respect loss-of-function variation sensitivity:</span>

<span class="sd">        - Null: where protein truncating variation is completely tolerated by natural</span>
<span class="sd">          selection.</span>
<span class="sd">        - Recessive (Rec): where heterozygous pLoFs are tolerated but homozygous pLoFs</span>
<span class="sd">          are not.</span>
<span class="sd">        - Haploinsufficient (LI): where heterozygous pLoFs are not tolerated.</span>

<span class="sd">    The function requires the expected amount of loss-of-function depletion for each of</span>
<span class="sd">    these states. The default provided is based on the observed depletion of</span>
<span class="sd">    protein-truncating variation in the Blekhman autosomal recessive and ClinGen</span>
<span class="sd">    dosage sensitivity gene sets (Supplementary Information Table 12 of the above</span>
<span class="sd">    reference):</span>

<span class="sd">        - Null: 1.0, assume tolerant genes have the expected amount of truncating</span>
<span class="sd">          variation.</span>
<span class="sd">        - Rec: 0.463, derived from the empirical mean observed/expected rate of</span>
<span class="sd">          truncating variation for recessive disease genes (0.463).</span>
<span class="sd">        - LI: 0.089, derived from the empirical mean observed/expected rate of</span>
<span class="sd">          truncating variation for severe haploinsufficient genes.</span>

<span class="sd">    The output StructExpression will include the following annotations:</span>

<span class="sd">        - pLI: Probability of loss-of-function intolerance; probability that transcript</span>
<span class="sd">          falls into distribution of haploinsufficient genes.</span>
<span class="sd">        - pNull: Probability that transcript falls into distribution of unconstrained</span>
<span class="sd">          genes.</span>
<span class="sd">        - pRec: Probability that transcript falls into distribution of recessive genes.</span>

<span class="sd">    :param ht: Input Table containing `obs_expr` and `exp_expr`.</span>
<span class="sd">    :param obs_expr: Expression for the number of observed variants on each gene or</span>
<span class="sd">        transcript in `ht`.</span>
<span class="sd">    :param exp_expr: Expression for the number of expected variants on each gene or</span>
<span class="sd">        transcript in `ht`.</span>
<span class="sd">    :param expected_values: Dictionary containing the expected values for &#39;Null&#39;,</span>
<span class="sd">        &#39;Rec&#39;, and &#39;LI&#39; to use as starting values.</span>
<span class="sd">    :param min_diff_convergence: Minimum iteration change in LI to consider the EM</span>
<span class="sd">        model convergence criteria as met. Default is 0.001.</span>
<span class="sd">    :return: StructExpression for pLI scores.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">expected_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">expected_values</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;Null&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="s2">&quot;Rec&quot;</span><span class="p">:</span> <span class="mf">0.463</span><span class="p">,</span> <span class="s2">&quot;LI&quot;</span><span class="p">:</span> <span class="mf">0.089</span><span class="p">}</span>

    <span class="c1"># Set up initial values.</span>
    <span class="n">last_pi</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">expected_values</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">expected_values</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">expected_values</span><span class="o">.</span><span class="n">keys</span><span class="p">()}</span>

    <span class="n">dpois_expr</span> <span class="o">=</span> <span class="p">{</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span>
            <span class="n">exp_expr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">dpois</span><span class="p">(</span><span class="n">obs_expr</span><span class="p">,</span> <span class="n">exp_expr</span> <span class="o">*</span> <span class="n">expected_values</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="p">)</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pi</span>
    <span class="p">}</span>
    <span class="n">_ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">dpois</span><span class="o">=</span><span class="n">dpois_expr</span><span class="p">)</span>
    <span class="c1"># Checkpoint the temp HT because it will need to be aggregated several times.</span>
    <span class="n">_ht</span> <span class="o">=</span> <span class="n">_ht</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span><span class="n">new_temp_file</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;compute_pli&quot;</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s2">&quot;ht&quot;</span><span class="p">))</span>

    <span class="c1"># Calculate pLI scores.</span>
    <span class="k">while</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pi</span><span class="p">[</span><span class="s2">&quot;LI&quot;</span><span class="p">]</span> <span class="o">-</span> <span class="n">last_pi</span><span class="p">[</span><span class="s2">&quot;LI&quot;</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">min_diff_convergence</span><span class="p">:</span>
        <span class="n">last_pi</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">pi</span><span class="p">)</span>
        <span class="n">pi_expr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">*</span> <span class="n">_ht</span><span class="o">.</span><span class="n">dpois</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pi</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">row_sum_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">pi_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pi</span><span class="p">])</span>
        <span class="n">pi_expr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">pi_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">row_sum_expr</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pi</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">pi</span> <span class="o">=</span> <span class="n">_ht</span><span class="o">.</span><span class="n">aggregate</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pi_expr</span><span class="p">[</span><span class="n">k</span><span class="p">])</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pi</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span>

    <span class="c1"># Get expression for pLI scores.</span>
    <span class="n">pli_expr</span> <span class="o">=</span> <span class="p">{</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">*</span> <span class="n">dpois_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">pi</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
    <span class="n">row_sum_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span><span class="n">pli_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pi</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="sa">f</span><span class="s2">&quot;p</span><span class="si">{</span><span class="n">k</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">pli_expr</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">/</span> <span class="n">row_sum_expr</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">pi</span><span class="o">.</span><span class="n">keys</span><span class="p">()})</span></div>


<div class="viewcode-block" id="oe_confidence_interval"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.oe_confidence_interval">[docs]</a><span class="k">def</span> <span class="nf">oe_confidence_interval</span><span class="p">(</span>
    <span class="n">obs_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">,</span>
    <span class="n">exp_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">alpha</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the confidence interval around the observed:expected ratio.</span>

<span class="sd">    For a given pair of observed (`obs_expr`) and expected (`exp_expr`) values, the</span>
<span class="sd">    function computes the density of the Poisson distribution (performed using Hail&#39;s</span>
<span class="sd">    `dpois` module) with fixed k (`x` in `dpois` is set to the observed number of</span>
<span class="sd">    variants) over a range of lambda (`lamb` in `dpois`) values, which are given by the</span>
<span class="sd">    expected number of variants times a varying parameter ranging between 0 and 2 (the</span>
<span class="sd">    observed:expected ratio is typically between 0 and 1, so we want to extend the</span>
<span class="sd">    upper bound of the confidence interval to capture this). The cumulative density</span>
<span class="sd">    function of the Poisson distribution density is computed and the value of the</span>
<span class="sd">    varying parameter is extracted at points corresponding to `alpha` (defaults to 5%)</span>
<span class="sd">    and 1-`alpha` (defaults to 95%) to indicate the lower and upper bounds of the</span>
<span class="sd">    confidence interval.</span>

<span class="sd">    The following annotations are in the output StructExpression:</span>
<span class="sd">        - lower - the lower bound of confidence interval</span>
<span class="sd">        - upper - the upper bound of confidence interval</span>

<span class="sd">    :param obs_expr: Expression for the observed variant counts of pLoF, missense, or</span>
<span class="sd">        synonymous variants in `ht`.</span>
<span class="sd">    :param exp_expr: Expression for the expected variant counts of pLoF, missense, or</span>
<span class="sd">        synonymous variants in `ht`.</span>
<span class="sd">    :param alpha: The significance level used to compute the confidence interval.</span>
<span class="sd">        Default is 0.05.</span>
<span class="sd">    :return: StructExpression for the confidence interval lower and upper bounds.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Set up range between 0 and 2.</span>
    <span class="n">range_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">float64</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">)</span>
    <span class="n">range_dpois_expr</span> <span class="o">=</span> <span class="n">range_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">dpois</span><span class="p">(</span><span class="n">obs_expr</span><span class="p">,</span> <span class="n">exp_expr</span> <span class="o">*</span> <span class="n">x</span><span class="p">))</span>

    <span class="c1"># Compute cumulative density function of the Poisson distribution density.</span>
    <span class="n">cumulative_dpois_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">cumulative_sum</span><span class="p">(</span><span class="n">range_dpois_expr</span><span class="p">)</span>
    <span class="n">max_cumulative_dpois_expr</span> <span class="o">=</span> <span class="n">cumulative_dpois_expr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">norm_dpois_expr</span> <span class="o">=</span> <span class="n">cumulative_dpois_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">/</span> <span class="n">max_cumulative_dpois_expr</span><span class="p">)</span>

    <span class="c1"># Extract the value of the varying parameter within specified range.</span>
    <span class="n">lower_idx_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span>
        <span class="n">norm_dpois_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="n">upper_idx_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span>
        <span class="n">norm_dpois_expr</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_missing</span><span class="p">(</span><span class="n">x</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">alpha</span><span class="p">,</span> <span class="n">x</span><span class="p">))</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">struct</span><span class="p">(</span>
        <span class="n">lower</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">obs_expr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="n">range_expr</span><span class="p">[</span><span class="n">lower_idx_expr</span><span class="p">],</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">upper</span><span class="o">=</span><span class="n">range_expr</span><span class="p">[</span><span class="n">upper_idx_expr</span><span class="p">],</span>
    <span class="p">)</span></div>


<div class="viewcode-block" id="calculate_raw_z_score"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.calculate_raw_z_score">[docs]</a><span class="k">def</span> <span class="nf">calculate_raw_z_score</span><span class="p">(</span>
    <span class="n">obs_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Int64Expression</span><span class="p">,</span>
    <span class="n">exp_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StructExpression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Compute the signed raw z-score using observed and expected variant counts.</span>

<span class="sd">    The raw z-scores are positive when the transcript had fewer variants than expected,</span>
<span class="sd">    and are negative when transcripts had more variants than expected.</span>

<span class="sd">    :param obs_expr: Observed variant count expression.</span>
<span class="sd">    :param exp_expr: Expected variant count expression.</span>
<span class="sd">    :return: StructExpression for the raw z-score.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">chisq_expr</span> <span class="o">=</span> <span class="n">divide_null</span><span class="p">((</span><span class="n">obs_expr</span> <span class="o">-</span> <span class="n">exp_expr</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">,</span> <span class="n">exp_expr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">chisq_expr</span><span class="p">)</span> <span class="o">*</span> <span class="n">hl</span><span class="o">.</span><span class="n">if_else</span><span class="p">(</span><span class="n">obs_expr</span> <span class="o">&gt;</span> <span class="n">exp_expr</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="get_constraint_flags"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.get_constraint_flags">[docs]</a><span class="k">def</span> <span class="nf">get_constraint_flags</span><span class="p">(</span>
    <span class="n">exp_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">raw_z_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">raw_z_lower_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">5.0</span><span class="p">,</span>
    <span class="n">raw_z_upper_threshold</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">5.0</span><span class="p">,</span>
    <span class="n">flag_postfix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">]:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Determine the constraint flags that define why constraint will not be calculated.</span>

<span class="sd">    Flags which are added:</span>
<span class="sd">        - &quot;no_exp_{flag_postfix}&quot; - for genes that have missing or zero expected variants.</span>
<span class="sd">        - &quot;outlier_{flag_postfix}&quot; - for genes that are raw z-score outliers:</span>
<span class="sd">          (`raw_z_expr` &lt; `raw_z_lower_threshold`) or (`raw_z_expr` &gt;</span>
<span class="sd">          `raw_z_upper_threshold`).</span>

<span class="sd">    :param exp_expr: Expression for the expected variant counts of pLoF, missense, or</span>
<span class="sd">        synonymous variants.</span>
<span class="sd">    :param raw_z_expr: Expression for the signed raw z-score of pLoF, missense, or</span>
<span class="sd">        synonymous variants.</span>
<span class="sd">    :param raw_z_lower_threshold: Lower threshold for the raw z-score. When `raw_z_expr`</span>
<span class="sd">        is less than this threshold it is considered an &#39;outlier&#39;. Default is -5.0.</span>
<span class="sd">    :param raw_z_upper_threshold: Upper threshold for the raw z-score. When `raw_z_expr`</span>
<span class="sd">        is greater than this threshold it is considered an &#39;outlier&#39;. Default is 5.0.</span>
<span class="sd">    :param flag_postfix: Postfix to add to the end of the constraint flag names.</span>
<span class="sd">    :return: Dictionary containing expressions for constraint flags.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">outlier_expr</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">raw_z_lower_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outlier_expr</span> <span class="o">|=</span> <span class="n">raw_z_expr</span> <span class="o">&lt;</span> <span class="n">raw_z_lower_threshold</span>
    <span class="k">if</span> <span class="n">raw_z_upper_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">outlier_expr</span> <span class="o">|=</span> <span class="n">raw_z_expr</span> <span class="o">&gt;</span> <span class="n">raw_z_upper_threshold</span>

    <span class="k">if</span> <span class="n">flag_postfix</span><span class="p">:</span>
        <span class="n">flag_postfix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;_</span><span class="si">{</span><span class="n">flag_postfix</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="n">constraint_flags</span> <span class="o">=</span> <span class="p">{</span>
        <span class="sa">f</span><span class="s2">&quot;no_exp</span><span class="si">{</span><span class="n">flag_postfix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">exp_expr</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">True</span><span class="p">),</span>
        <span class="sa">f</span><span class="s2">&quot;outlier</span><span class="si">{</span><span class="n">flag_postfix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">or_else</span><span class="p">(</span><span class="n">outlier_expr</span><span class="p">,</span> <span class="kc">False</span><span class="p">),</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">constraint_flags</span></div>


<div class="viewcode-block" id="calculate_raw_z_score_sd"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.calculate_raw_z_score_sd">[docs]</a><span class="k">def</span> <span class="nf">calculate_raw_z_score_sd</span><span class="p">(</span>
    <span class="n">raw_z_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Float64Expression</span><span class="p">,</span>
    <span class="n">flag_expr</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">StringExpression</span><span class="p">,</span>
    <span class="n">mirror_neg_raw_z</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">expr</span><span class="o">.</span><span class="n">Expression</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the standard deviation of the raw z-score.</span>

<span class="sd">    When using `mirror_neg_raw_z` is True, all the negative raw z-scores (defined by</span>
<span class="sd">    `raw_z_expr`) are combined with those same z-scores multiplied by -1 (to create a</span>
<span class="sd">    mirrored distribution).</span>

<span class="sd">    :param raw_z_expr: Expression for the raw z-score.</span>
<span class="sd">    :param flag_expr: Expression for the constraint flags. z-score will not be</span>
<span class="sd">        calculated if flags are present.</span>
<span class="sd">    :param mirror_neg_raw_z: Whether the standard deviation should be computed using a</span>
<span class="sd">        mirrored distribution of negative `raw_z_expr`.</span>
<span class="sd">    :return: StructExpression containing standard deviation of the raw z-score and</span>
<span class="sd">        the z-score.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">filter_expr</span> <span class="o">=</span> <span class="p">(</span><span class="n">hl</span><span class="o">.</span><span class="n">len</span><span class="p">(</span><span class="n">flag_expr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">hl</span><span class="o">.</span><span class="n">is_defined</span><span class="p">(</span><span class="n">raw_z_expr</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">mirror_neg_raw_z</span><span class="p">:</span>
        <span class="n">filter_expr</span> <span class="o">&amp;=</span> <span class="n">raw_z_expr</span> <span class="o">&lt;</span> <span class="mi">0</span>
        <span class="n">sd_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span>
            <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="p">[</span><span class="n">raw_z_expr</span><span class="p">,</span> <span class="o">-</span><span class="n">raw_z_expr</span><span class="p">]</span>
        <span class="p">)</span><span class="o">.</span><span class="n">stdev</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">sd_expr</span> <span class="o">=</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">stats</span><span class="p">(</span><span class="n">raw_z_expr</span><span class="p">)</span><span class="o">.</span><span class="n">stdev</span>

    <span class="k">return</span> <span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">filter_expr</span><span class="p">,</span> <span class="n">sd_expr</span><span class="p">)</span></div>


<div class="viewcode-block" id="add_gencode_transcript_annotations"><a class="viewcode-back" href="../../../api_reference/utils/constraint.html#gnomad.utils.constraint.add_gencode_transcript_annotations">[docs]</a><span class="k">def</span> <span class="nf">add_gencode_transcript_annotations</span><span class="p">(</span>
    <span class="n">ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">gencode_ht</span><span class="p">:</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">,</span>
    <span class="n">annotations</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="s2">&quot;transcript_id_version&quot;</span><span class="p">,</span>
        <span class="s2">&quot;gene_id_version&quot;</span><span class="p">,</span>
        <span class="s2">&quot;level&quot;</span><span class="p">,</span>
        <span class="s2">&quot;transcript_type&quot;</span><span class="p">,</span>
        <span class="s2">&quot;start_position&quot;</span><span class="p">,</span>
        <span class="s2">&quot;end_position&quot;</span><span class="p">,</span>
    <span class="p">],</span>
    <span class="n">remove_y_par</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">hl</span><span class="o">.</span><span class="n">Table</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Add GENCODE annotations to Table based on transcript id.</span>

<span class="sd">    .. note::</span>

<span class="sd">        Added annotations by default are:</span>
<span class="sd">        - level</span>
<span class="sd">        - transcript_type</span>
<span class="sd">        - start_position (start of the transcript)</span>
<span class="sd">        - end_position (end of the transcript)</span>

<span class="sd">        Computed annotations are:</span>
<span class="sd">        - chromosome</span>
<span class="sd">        - cds_length</span>
<span class="sd">        - num_coding_exons</span>

<span class="sd">    :param ht: Input Table.</span>
<span class="sd">    :param gencode_ht: Table with GENCODE annotations.</span>
<span class="sd">    :param annotations: List of GENCODE annotations to add. Default is</span>
<span class="sd">        [&quot;transcript_id_version&quot;, &quot;gene_id_version&quot;, &quot;level&quot;, &quot;transcript_type&quot;,</span>
<span class="sd">        &quot;start_position&quot;, &quot;end_position&quot;].</span>
<span class="sd">    :param remove_y_par: Whether to remove features for the Y chromosome PAR regions.</span>
<span class="sd">        Default is True because the Y chromosome PAR regions are typically not included</span>
<span class="sd">        in the constraint calculations and both chrX and chrY will have the same</span>
<span class="sd">        &#39;transcript_id&#39; field for these regions. This parameter can only be True if</span>
<span class="sd">        `gencode_ht` includes a &#39;transcript_id_version&#39; field because Y_PAR is included</span>
<span class="sd">        in the version of the transcript, which has been stripped from the</span>
<span class="sd">        &#39;transcript_id&#39; field.</span>
<span class="sd">    :return: Table with transcript annotations from GENCODE added.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">remove_y_par</span> <span class="ow">and</span> <span class="s2">&quot;transcript_id_version&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">gencode_ht</span><span class="o">.</span><span class="n">row</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;remove_y_par is True but &#39;transcript_id_version&#39; is not in gencode_ht&quot;</span>
        <span class="p">)</span>

    <span class="k">if</span> <span class="n">remove_y_par</span><span class="p">:</span>
        <span class="n">gencode_ht</span> <span class="o">=</span> <span class="n">gencode_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span>
            <span class="o">~</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">transcript_id_version</span><span class="o">.</span><span class="n">endswith</span><span class="p">(</span><span class="s2">&quot;Y_PAR&quot;</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="n">gencode_ht</span> <span class="o">=</span> <span class="n">gencode_ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span>
        <span class="n">length</span><span class="o">=</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span>
        <span class="o">-</span> <span class="n">gencode_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span>
        <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">chromosome</span><span class="o">=</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">contig</span><span class="p">,</span>
        <span class="n">start_position</span><span class="o">=</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">start</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
        <span class="n">end_position</span><span class="o">=</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">interval</span><span class="o">.</span><span class="n">end</span><span class="o">.</span><span class="n">position</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add transcript annotations to input Table.</span>
    <span class="n">annotations_to_add</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">annotations</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;chromosome&quot;</span><span class="p">,</span> <span class="s2">&quot;transcript_id&quot;</span><span class="p">])</span>
    <span class="n">gencode_transcript_ht</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">gencode_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">feature</span> <span class="o">==</span> <span class="s2">&quot;transcript&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">annotations_to_add</span><span class="p">)</span>
        <span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;transcript_id&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Obtain CDS annotations from GENCODE file and calculate CDS length and</span>
    <span class="c1"># number of exons.</span>
    <span class="n">annotations_to_add</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">annotations</span> <span class="o">+</span> <span class="p">[</span><span class="s2">&quot;chromosome&quot;</span><span class="p">,</span> <span class="s2">&quot;transcript_id&quot;</span><span class="p">,</span> <span class="s2">&quot;length&quot;</span><span class="p">])</span>

    <span class="n">gencode_cds_ht</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">gencode_ht</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">gencode_ht</span><span class="o">.</span><span class="n">feature</span> <span class="o">==</span> <span class="s2">&quot;CDS&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">annotations_to_add</span><span class="p">)</span>
        <span class="o">.</span><span class="n">key_by</span><span class="p">(</span><span class="s2">&quot;transcript_id&quot;</span><span class="p">)</span>
        <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;interval&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="n">annotations_to_add</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s2">&quot;length&quot;</span><span class="p">)</span>

    <span class="n">gencode_cds_ht</span> <span class="o">=</span> <span class="n">gencode_cds_ht</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;transcript_id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">aggregate</span><span class="p">(</span>
        <span class="n">cds_length</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">gencode_cds_ht</span><span class="o">.</span><span class="n">length</span><span class="p">),</span>
        <span class="n">num_coding_exons</span><span class="o">=</span><span class="n">hl</span><span class="o">.</span><span class="n">agg</span><span class="o">.</span><span class="n">count</span><span class="p">(),</span>
    <span class="p">)</span>

    <span class="c1"># Join the transcript and CDS annotations.</span>
    <span class="n">gencode_transcript_ht</span> <span class="o">=</span> <span class="n">gencode_transcript_ht</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">gencode_cds_ht</span><span class="p">)</span><span class="o">.</span><span class="n">checkpoint</span><span class="p">(</span>
        <span class="n">new_temp_file</span><span class="p">(</span><span class="n">prefix</span><span class="o">=</span><span class="s2">&quot;gencode&quot;</span><span class="p">,</span> <span class="n">extension</span><span class="o">=</span><span class="s2">&quot;ht&quot;</span><span class="p">)</span>
    <span class="p">)</span>

    <span class="c1"># Add GENCODE annotations to input Table.</span>
    <span class="n">ht</span> <span class="o">=</span> <span class="n">ht</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="o">**</span><span class="n">gencode_transcript_ht</span><span class="p">[</span><span class="n">ht</span><span class="o">.</span><span class="n">transcript</span><span class="p">])</span>

    <span class="k">return</span> <span class="n">ht</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p></p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>